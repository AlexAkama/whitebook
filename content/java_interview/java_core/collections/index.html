<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Collections</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb"><a href="../">Collections</a></h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>collections</p>
    </div>
    <h4 class="no_mt">Вопросы: <span class="submenu-total">(показать все)</span></h4>
    <ol class="menu">
        <li>
            <div class="mb10">
                <a href="#base_interface">Базовые интерфейсы</a>
                <span class="submenu-button"></span>
            </div>
            <div class="menu no-display">
                <ul>
                    <li><a href="#wtf_collection">Что такое "коллекция"?</a></li>
                    <li><a href="#collection_data">Какие данные могут хранить коллекции?</a></li>
                    <li>
                        <a href="#collection_vs_array">
                            Преимущества использования коллекций по сравнению с массивами?
                        </a>
                    </li>
                    <li>
                        <a href="#base_hierarchy">
                            Какие есть типы коллекций?
                            <br>Как они характеризуются?
                            <br>Расскажите про иерархию коллекций List, Set, Map.</a>
                    </li>
                </ul>
            </div>
        </li>
        <li><a href="#collection">Интерфейс Collection</a></li>
        <li><a href="#list">Реализации интерфейса List</a></li>
        <li><a href="#set">Реализации интерфейса Set</a></li>
        <li><a href="#queue">Реализации интерфейса Queue</a></li>
        <li><a href="#map">Реализации интерфейса Map</a></li>
        <li><a href="#other">Другие коллекции</a></li>
        <li><a href="#synchronized">Синхронизированные коллекции</a></li>
        <li><a href="#loadFactor_capacity">loadFactor и capacity</a></li>
    </ol>
</section>

<section class="container" id="base_interface">
    <h1><a href="#">Базовые интерфейсы</a></h1>
    <div class="after-h1 margined">
        <ul>
            <li><a href="#wtf_collection">Что такое "коллекция"?</a></li>
            <li><a href="#collection_data">Какие данные могут хранить коллекции?</a></li>
            <li>
                <a href="#collection_vs_array">
                    Преимущества использования коллекций по сравнению с массивами?
                </a>
            </li>
            <li>
                <a href="#base_hierarchy">
                    Какие есть типы коллекций?
                    <br>Как они характеризуются?
                    <br>Расскажите про иерархию коллекций List, Set, Map</a>
            </li>
        </ul>
    </div>
    <div>
        <p>
            В библиотеке коллекций Java существует <strong>два базовых интерфейса</strong>,
            реализации которых и представляют совокупность всех классов коллекций:
        </p>
        <ol class="sparse-li">
            <li>
                <strong>Collection</strong> - коллекция содержит набор объектов (элементов). Здесь определены основные
                методы для манипуляции с
                данными, такие как вставка (add, addAll), удаление (remove, removeAll, clear), поиск (contains)
            </li>
            <li>
                <p>
                    <strong>Map</strong> - описывает коллекцию, состоящую из пар “ключ — значение”. У каждого ключа
                    только
                    одно значение, что соответствует математическому понятию однозначной функции или отображения.
                </p>
                <p>
                    Такую коллекцию часто называют еще словарем (dictionary) или ассоциативным массивом (associative
                    array).
                </p>
                <p>Никак НЕ относится к интерфейсу Collection и является самостоятельным.</p>
            </li>
        </ol>

        <p class="no_mb">
            Хотя фреймворк называется Java Collections Framework, интерфейс Map и его реализации входят во фреймворк
            также!
        </p>
        <p class="no_mb">Интерфейсы Collection и Map являются базовыми, но они не есть единственными.</p>
        <p>Их расширяют другие интерфейсы, добавляющие дополнительный функционал.</p>
    </div>

    <hr>
    <div id="wtf_collection">
        <h3>Что такое "коллекция"?</h3>
        <div>
            Коллекция это набор объектов (элементов).
        </div>
        <a class="button button--to_content_menu" href="#base_interface"></a>
    </div>

    <hr>
    <div id="collection_data">
        <h3>Какие данные могут хранить коллекции?</h3>
        <div>
            Любые "объектные" типы.
        </div>
        <a class="button button--to_content_menu" href="#base_interface"></a>
    </div>

    <hr>
    <div id="collection_vs_array">
        <h3>Преимущества использования коллекций по сравнению с массивами?</h3>
        <div>
            <ul class="margined">
                <li class="term">
                    <span>Динамический размер:</span>
                    Коллекции позволяют добавлять и удалять элементы во время выполнения
                    программы, без необходимости заранее определенного размера. Это особенно полезно, когда неизвестно
                    заранее, сколько элементов будет содержаться в коллекции. Напротив, массивы имеют фиксированный
                    размер, который нужно определить при их создании.

                </li>
                <li class="term">
                    <span>Удобные методы:</span>
                    Коллекции предоставляют множество полезных методов для работы с элементами, таких
                    как сортировка, поиск, фильтрация и многое другое. Это упрощает манипуляцию с данными и обработку
                    элементов коллекции. В отличие от массивов, где вам нужно написать свои собственные алгоритмы для
                    выполнения таких операций.
                </li>
                <li class="term">
                    <span>Гибкость:</span>
                    Коллекции предоставляют различные типы коллекций, такие как списки, множества и
                    отображения, которые подходят для различных сценариев использования.
                    <br>Например, список (ArrayList)
                    хорошо подходит для хранения упорядоченных элементов, множество (HashSet) гарантирует уникальность
                    элементов, а отображение (HashMap) используется для хранения пар "ключ-значение".

                </li>
                <li class="term">
                    <span>Высокий уровень абстракции:</span>
                    Коллекции представляют собой высокоуровневый инструмент для работы с данными, который скрывает
                    детали реализации и предоставляет простой и понятный интерфейс для работы с данными.
                    <br>Например, вам не нужно беспокоиться о выделении памяти или управлении индексами
                    при использовании коллекций.
                </li>
            </ul>
            <p>
                В целом, использование коллекций в&nbsp;JAVA предоставляет более гибкий и удобный способ работы с данными,
                чем
                использование массивов. Они позволяют динамически изменять размер коллекции, предоставляют полезные
                методы для манипуляции с данными и поддерживают различные типы коллекций для различных сценариев
                использования.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#base_interface"></a>
    </div>

    <hr>
    <div id="base_hierarchy">
        <h3><a href="#base_interface">
            Какие есть типы коллекций?
            <br>Как они характеризуются?
            <br>Расскажите про иерархию коллекций List, Set, Map.</a></h3>
        <div>
            <p>смотри <a href="#base_interface">Базовые интерфейсы</a></p>
        </div>
        <a class="button button--to_content_menu" href="#base_interface"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="collection">
    <h1><a href="#">Интерфейс Collection</a></h1>
    <div>
        <div class="image-box">
            <img class="image" src="./img/collection.png" alt="Интерфейс Collection">
        </div>
        <p class="no_mb">
            Интерфейс <strong>Collection</strong> не является базовым. Он <strong>расширяет</strong>
            интерфейс <strong>Iterable</strong>, у которого есть только один метод iterator().
        </p>
        <p>
            Это значит что любая коллекция будет возвращать итератор, а также ее можно без всяких трудностей
            использовать в
            конструкции foreach.
        </p>
        <p class="main-mind">
            Итератор – объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции.<br>
            Итератор это паттерн позволяющий получить доступ к элементам любой коллекции без вникания в суть ее
            реализации.
        </p>
        <p>Интерфейс Collection расширяют интерфейсы List, Set и Queue:</p>

        <ul class="sparse-li">
            <li>
                <p class="bold">List</p>
                <p>
                    Это <strong>упорядоченная коллекция</strong>,
                    в которой <strong>допустимы дублирующие значения</strong>.</p>
                <p>Иногда их называют последовательностями (sequence).</p>
                <p>
                    Элементы такой коллекции <strong>пронумерованы</strong>,
                    начиная от нуля, к ним <strong>можно обратиться по индексу</strong>.
                </p>
            </li>
            <li>
                <p class="bold">Set</p>
                <p>Описывает коллекцию, <strong>не содержащую повторяющихся элементов</strong>.</p>
                <p>Это соответствует математическому понятию множества (set).</p>
            </li>
            <li>
                <p class="bold">Queue</p>
                <p>
                    <strong>Для хранения элементов в порядке, нужном для их обработки</strong>.
                    В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные
                    операции
                    вставки, получения и контроля.
                </p>
            </li>
        </ul>
    </div>

    <hr>
    <div id="iterator">
        <h3><a href="#">Что такое итератор?</a></h3>
        <div>
            <p class="term">
                <span>Iterator</span> - это интерфейс, предоставляющий функциональность для итерации по любой коллекции
                Java.
                <br>Итераторы позволяют <strong>безопасно удалять элементы во время обхода</strong> коллекций.
            </p>
            <p>Итератор предоставляет методы для выполнения следующих операций:</p>
            <ol class="margined">
                <li>
                    <p class="term">
                        <span>hasNext()</span>:
                        Возвращает true, если в коллекции остались элементы для перехода.
                        <br>В противном случае он возвращает false.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>next()</span>:
                        Возвращает следующий элемент из коллекции. Если таких элементов нет, он вызывает
                        исключение NoSuchElementException.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>remove()</span>:
                        Удаляет последний элемент, который был возвращен итератором.
                        <br>Этот метод можно вызвать только один раз для каждого вызова next().
                        <br>Если метод next() не был вызван, или remove() уже был вызван после последнего вызова next(),
                        этот метод вызывает исключение IllegalStateException.
                    </p>
                </li>
            </ol>
            <p>
                Важно отметить, что итераторы обеспечивают <b>fail-fast поведение</b>, что означает, что если коллекция
                изменяется в процессе итерации (кроме использования самого метода remove()), итератор быстро завершится,
                вызвав <b>ConcurrentModification<wbr>Exception</b>.
                <br>Это помогает предотвратить непредсказуемое поведение, возникающее при одновременном изменении
                коллекции во время итерации.
            </p>
            <p>
                <a class="link-to-source" href="https://metanit.com/java/tutorial/5.10.php" target="_blank">
                    еще про ListIterator</a>
            </p>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="iterator_vs_iterable">
        <h3><a href="#">В чем разница между Iterator и Iterable?</a></h3>
        <div>
            <p class="term">
                <span>Iterable</span> и <span>Iterator</span>
                - два различных интерфейса в&nbsp;JAVA, которые оба играют важную роль в работе с коллекциями данных.
            </p>

            <p>Они тесно связаны, но имеют разные цели:</p>
            <ul class="margined">
                <li>
                    <p class="term">
                        <span>Iterable</span>
                        - это интерфейс, который реализуется любым объектом, который может вернуть Iterator.
                        <br>Он определяет единственный метод,
                        <span>iterator()</span>, который возвращает новый Iterator.
                        <br>Это позволяет объекту быть целью для "foreach" конструкции.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>Iterator</span>
                        - это интерфейс, который используется для обхода коллекции.
                        <br>Он позволяет последовательно проходить по коллекции, не заботясь о том, как она
                        структурирована внутри.
                        <br>Определяет методы <span>hasNext()</span>, <span>next()</span> и <span>remove()</span>.
                    </p>
                </li>
            </ul>


            <p>Вот базовая идея:</p>
            <p class="main-mind">

                Если у вас есть коллекция элементов и вы хотите сделать ее доступной для обхода, вы реализуете Iterable
                на этой коллекции.
                <br>Это позволяет другим использовать цикл for-each с вашей коллекцией.
            </p>
            <p class="main-mind">
                Когда вы хотите обойти коллекцию, вы используете Iterator, который предоставляет коллекция.
                <br>Это позволяет вам проверить, есть ли следующий элемент (hasNext()), получить следующий элемент
                (next()) и удалить текущий элемент (remove()).
            </p>
        </div>
        <a class="button button--to_content_menu" href="#collection"></a>
    </div>

    <hr>
    <div id="iterator_vs_enumeration">
        <h3><a href="#">В чем разница между Iterator и Enumeration?</a></h3>
        <div>
            <p class="term">
                <span>Iterator</span> и <span>Enumeration</span>
                являются двумя концепциями в&nbsp;JAVA, которые используются <strong>для обхода коллекций</strong>.
            </p>
            <p>Они оба служат похожим целям, но есть несколько ключевых различий:</p>
            <ol class="margined">
                <li>
                    <p class="term">
                        <span>Методы</span>:
                        Iterator имеет три метода: <span>hasNext(), next(), и remove()</span>,
                        в то время как Enumeration имеет только два метода:
                        <span>hasMoreElements() и nextElement()</span>.
                        <br>
                        <strong>
                            Метод remove() в Iterator предоставляет возможность удаления элементов из коллекции во время
                            обхода, что Enumeration не может делать.
                        </strong>
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>Безопасность</span>:
                        Iterator является более безопасным, поскольку он не позволяет изменять коллекцию во время
                        обхода, кроме использования метода remove().
                        <br>Если коллекция изменяется в процессе итерации (не считая использования remove()),
                        Iterator быстро завершится, вызвав ConcurrentModification<wbr>Exception.
                        <br>Enumeration не предоставляет этой защиты.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>Использование</span>:
                        Iterator широко используется в новых реализациях Java Collection Framework, в то время как
                        Enumeration используется во многих старых классах, таких как Vector и Properties, и сейчас он
                        считается устаревшим.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>Производительность</span>:
                        В то время как Iterator является немного более медленным из-за дополнительной
                        проверки безопасности, он обеспечивает более сильную устойчивость к ошибкам.
                    </p>
                </li>
            </ol>



            <p>
                В общем, в современном Java программировании рекомендуется использовать Iterator вместо Enumeration
                из-за его расширенной функциональности и улучшенной безопасности.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#collection"></a>
    </div>

    <hr>
    <div id="collection_sort">
        <h3><a href="#">
            Как задается порядок следования объектов в коллекции?
            <br>Как отсортировать коллекцию?
        </a></h3>
        <div>

        </div>
        <a class="button button--to_content_menu" href="#collection"></a>
    </div>

    <hr>
    <div id="collection_natural_order">
        <h3><a href="#">Что такое сортировка по принципу Natural Order?</a></h3>
        <div>

        </div>
        <a class="button button--to_content_menu" href="#collection"></a>
    </div>

    <hr>
    <div id="comparable_vs_comparator?">
        <h3><a href="#">Чем отличается Comparable от Comparator?</a></h3>
        <div>

        </div>
        <a class="button button--to_content_menu" href="#collection"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="list">
    <h1><a href="#">Реализации интерфейса List</a></h1>
    <div>
        <div class="image-box">
            <img class="image" src="./img/list.png" alt="Интерфейс List">
        </div>
        <p>
            Красным выделены интерфейсы, зеленым – абстрактные классы, а синим готовые реализации.
            Здесь не вся иерархия, а только основная её часть.
        </p>
        <p>
            Mежду интерфейсом и конкретной реализацией коллекции существует несколько абстрактных классов.
            Это сделано для того, что бы вынести общий функционал в абстрактный класс, таким образом реализовать
            повторное
            использование кода.
        </p>
        <p>
            <span class="bold">ArrayList</span> – пожалуй самая часто используемая коллекция. Он инкапсулирует в себе
            обычный массив, длина которого может увеличиваться при добавлении новых элементов. Так как ArrayList
            использует
            массив, то время доступа к элементу по индексу минимально (В отличии от LinkedList). При удалении
            произвольного
            элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево, при этом реальный
            размер
            массива (его емкость, capacity) не изменяется. Если при добавлении элемента, оказывается, что массив
            полностью
            заполнен, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого
            массива + новый, добавляемый элемент.
        </p>
        <p>
            <span class="bold">LinkedList</span> – Двусвязный список. Это структура данных, состоящая из узлов, каждый
            из
            которых содержит как
            собственно
            данные, так и две ссылки («связки») на следующий и предыдущий узел списка. Доступ к произвольному элементу
            осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за
            константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец
            списка
            вовсе не значит, что прийдется перебирать весь список в поисках последнего элемента).
        </p>
    </div>

    <hr>
    <div id="arraylist_vs_linkedlist">
        <h3><a href="#">В чём отличие ArrayList от LinkedList?</a></h3>
        <div>
            <p>Массив - Двусвязный список</p>
        </div>
        <a class="button button--to_content_menu" href="#list"></a>
    </div>

    <hr>
    <div id="arraylist_remove">
        <h3><a href="#">Как происходит удаление элементов из ArrayList?</a></h3>
        <div>
        </div>
        <a class="button button--to_content_menu" href="#list"></a>
    </div>

    <hr>
    <div id="linkedlist_remove">
        <h3><a href="#">Как происходит удаление элементов из LinkedList?</a></h3>
        <div>
        </div>
        <a class="button button--to_content_menu" href="#list"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="set">
    <h1><a href="#">Реализации интерфейса Set</a></h1>
    <div>
        <div class="code">
            <img class="image" src="./img/set.png" alt="Интерфейс Set">
        </div>
        <p class="no_mb">
            <span class="bold">HashSet</span> – коллекция, не позволяющая хранить одинаковые объекты (как и любой Set).
        </p>
        <p class="no_mb">
            <strong>HashSet инкапсулирует в себе объект HashMap</strong> (то-есть использует для хранения хэш-таблицу).
        </p>
        <p class="no_mb">
            Хеш-таблица хранит информацию, используя, так называемый, механизм хеширования, в котором содержимое ключа
            используется для определения уникального значения, называемого хеш-кодом.
            Этот хеш-код затем применяется в качестве индекса, с которым ассоциируются данные, доступные по этому ключу.
        </p>
        <p class="no_mb">
            Если Вы хотите использовать HashSet для хранения объектов своих классов, то вы
            <strong>должны переопределить методы hashCode() и equals()</strong>, иначе два логически-одинаковых объекта
            будут считаться разными по хеш-коду, так как при добавлении элемента в коллекцию будет вызываться метод
            hashCode() класса Object (который скорее-всего вернет разный хэш-код для ваших объектов).
        </p>
        <p>
            Класс HashSet <strong>не гарантирует упорядоченности элементов</strong>, поскольку процесс
            хеширования сам по себе обычно не порождает сортированных наборов. Если нужны сортированные наборы, то
            лучшим выбором может быть другой тип коллекций - TreeSet.
        </p>
        <p>
            <span class="bold"> LinkedHashSet</span>
            – поддерживает связный список элементов набора <strong>в том порядке, в котором они вставлялись</strong>.
            Это позволяет организовать упорядоченную итерацию вставки в набор. То есть, когда идет перебор объекта
            класса
            LinkedHashSet с применением итератора, элементы извлекаются в том порядке, в каком они были добавлены.
        </p>
        <p>
            <span class="bold">TreeSet</span>
            – коллекция, которая хранит свои элементы в виде упорядоченного по значениям дерева. TreeSet инкапсулирует в
            себе TreeMap, который в свою очередь
            <strong>использует сбалансированное бинарное красно-черное дерево</strong>
            для хранения элементов.
            <br>TreeSet хорош тем, что для операций add, remove и contains потребуется гарантированное время log(n).
        </p>
    </div>

    <hr>
    <div id="hashset_vs_treeset">
        <h3><a href="#">В чём отличие HashSet от TreeSet?</a></h3>
        <div>
        </div>
        <a class="button button--to_content_menu" href="#set"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="queue">
    <h1><a href="#">Реализации интерфейса Queue</a></h1>
    <div class="image-box">
        <img class="image" src="./img/queue.png" alt="Интерфейс Queue">
    </div>
    <p>
        <span class="bold">PriorityQueue</span>
        – единственная прямая реализация интерфейса Queue (не считая LinkedList, который больше является
        списком, чем очередью).
    </p>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="map">
    <h1><a href="#">Реализации интерфейса Map</a></h1>
    <p>
        Интерфейс Map соотносит уникальные ключи со значениями. Ключ — это объект, который используется для
        последующего извлечения данных. Задавая ключ и значение, можно помещать значения в объект карты.
        После того как это значение сохранено, можно получить его по ключу.
    </p>
    <div class="image-box">
        <img class="image" src="./img/map.png" alt="Интерфейс Map">
    </div>
    <hr>
    <h4>HashMap</h4>
    <p>Реализация основана на хэш-таблицах, реализует интерфейс Map. </p>
    <p><strong>Ключи и значения могут быть любых типов, в том числе и null</strong>.</p>
    <p>Данная реализация <strong>не дает гарантий относительно порядка элементов.</strong></p>
    <hr>
    <h4>LinkedHashMap</h4>
    <p>Реализация <strong>расширяет класс HashMap</strong>.</p>
    <p class="no_mb">
        Класс создает <strong>связный список</strong> элементов в карте, расположенных в том порядке,
        <strong>в котором они вставлялись</strong>. Это позволяет организовать перебор карты в порядке вставки.
    </p>
    <p class="example">
        То есть,когда происходит итерация по коллекционному представлению объекта класса LinkedHashMap, элементы будут
        возвращаться в том порядке, в котором они вставлялись.
    </p>
    <p>
        Также <strong>можно</strong> создать объект класса LinkedHashMap, возвращающий свои <strong>элементы в том
        порядке, в котором к ним в последний раз осуществлялся доступ</strong>.
    </p>
    <hr>
    <h4>TreeMap</h4>
    <p>
        <strong>Красно-черное дерево</strong> реализующее <strong>интерфейс NavigableMap</strong>.
    </p>
    <p>
        Коллекция <strong>сортируется по естественному</strong> упорядочиванию (natural ordering) ее ключей
        <strong>или</strong> используя <strong>интерфейс Comparator</strong> который задается при создании
        коллекции.
    </p>
    <p class="no_mb">Эта имплементация гарантирует время доступа log(n) для следующих методов: </p>
    <p>
        <span class="code-word example">containsKey</span>,
        <span class="code-word example">get</span>,
        <span class="code-word example">put</span>, и
        <span class="code-word example">remove</span>
    </p>
    <hr>
    <h4>WeakHashMap</h4>
    <p>
        Основан на хэш-таблицах, реализует интерфейс Map с так называемыми слабыми ключами (weak&nbsp;keys).
        Пара в данной коллекции автоматически будет удалена когда ссылка на ключ больше нигде не используется. Другими
        словами, нахождение объекта представленного ключем в данной коллекции не блокирует сборщик мусора от зачистки.
        После того как ключ будет зачищен вся пара будет удалена из коллекции.
    </p>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="other">
    <h1><a href="#">Другие коллекции</a></h1>
    <p class="no_mb">Их еще называют "устаревшими".</p>
    <p class="example">Но нет аннотации @Deprecated или каких-либо иных, которые бы запрещали их использование в
        коде.</p>
    <hr>
    <h4>Enumeration</h4>
    <p>Интерфейс. В современной версии Java рекомендуется применять Iterator. </p>
    <hr>
    <h4>Dictionary</h4>
    <p class="no_mb">Абстрактный класс, аналог интерфейса Map.</p>
    <p>Реализации не имеет, рекомендуют его рассматривать как интерфейс. Наиболее известная реализация – Hashtable.</p>
    <hr>
    <h4>Hashtable</h4>
    <p class="no_mb">Класс. Имплементирует классическую структуру данных – хэш таблицу.</p>
    <p>В современных версиях Java рекомендуется использовать HashMap.</p>
    <hr>
    <h4>Vector</h4>
    <p class="no_mb">Класс. Аналог класса ArrayList. </p>
    <p>Поддерживает упорядоченный список элементов, хранимых во "внутреннем" массиве.</p>
    <hr>
    <h4>Stack</h4>
    <p class="no_mb">Класс. Производный от Vector.</p>
    <p>
        Добавлены методы "вталкивания" (push) и "выталкивания" (pop) элементов, так что список может трактоваться в
        терминах, принятых для описания структуры данных стека (stack).
    </p>
    <p class="main-mind">
        Все методы Hashtable, Stack, Vector являются синхронизированными, что делает их менее эффективными в
        однопоточных приложениях.
    </p>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="synchronized">
    <h1><a href="#">Синхронизирован<wbr>ные коллекции</a></h1>
    <p>
        Получить синхронизированные объекты коллекций можно используя <strong>статические методы класса
        Collections: </strong>
        <span class="code-word">synchronizedMap</span> и
        <span class="code-word">synchronizedList</span>
    </p>
    <div class="code">
        <p>Map m = Collections.synchronizedMap(new HashMap());</p>
        <p>List l = Collections.synchronizedList(new ArrayList());</p>
    </div>
    <p>
        Синхронизированные обрамления коллекций synchronizedMap и synchronizedList иногда называют условно потоко
        безопасными – все операции в отдельности потокобезопасны, но последовательности операций, где управляющий поток
        зависит от результатов предыдущих операций, могут быть причиной конкуренции за данные.
    </p>
    <p>
        Условная безопасность потоков, обеспечиваемая synchronizedList и synchronizedMap представляет скрытую угрозу –
        разработчики полагают, что, раз эти коллекции синхронизированы, значит, они полностью потокобезопасны, и
        пренебрегают должной синхронизацией составных операций. В результате, хотя эти программы и работают при лёгкой
        нагрузке, но при серьёзной нагрузке они могут начать выкидывать NullPointerException или
        ConcurrentModification<wbr>Exception.
    </p>
    <p>Кроме того всегда существует возможность "классической" синхронизации с помощью блока synchronized.</p>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="loadFactor_capacity">
    <h1><a href="#">loadFactor и capacity</a></h1>
    <div>
        <ul class="margined">
            <li>
                <p class="term">
                    <span>loadFactor</span> — коэффициент загрузки (заполненость).
                </p>
            </li>
            <li>
                <p class="term">
                    <span>capacity</span> - емкость.
                </p>
            </li>
        </ul>
    </div>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="source">
    <h1><a href="#">Дополнительно</a></h1>
    <a class="link-to-source" href="https://habr.com/ru/articles/162017/" target="_blank">Можно почитать</a>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../generics/">Дженерики</a>
    <a class="navi-button navi--next" href="../functional_interfaces/">Функциональные интерфейсы</a>
</div>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

<a href="#" class="button button--top"></a>


</body>

<script src="../../../../js/image.js"></script>
<script src="../../../../js/submenu.js"></script>

</html>