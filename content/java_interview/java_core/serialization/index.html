<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Serialization</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb"><a href="../">Сериализация и копирование</a></h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>Serialization</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Сериализация</a></li>
        <li><a href="#q2">Процесс с использованием Serializable</a></li>
        <li><a href="#q3">Изменение и настрой сериализации</a></li>
        <li><a href="#q4">Клонирование объектов</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1><a href="#">Сериализация</a></h1>
    <h4 class="no_mb example">Что такое сериализация и как она реализована в Java?</h4>
    <p class="main-mind">
        Сериализация (Serialization) - процесс преобразования структуры данных в линейную
        последовательность байтов для дальнейшей передачи или сохранения.
    </p>
    <p>Сериализованные объекты можно затем восстановить (десериализовать).</p>
    <p>
        В Java, согласно спецификации Java Object Serialization существует два стандартных способа
        сериализации: стандартная сериализация, через использование интерфейса java.io.Serializable и
        «расширенная» сериализация - java.io.Externalizable.
    </p>
    <p class="no_mb">Сериализация позволяет в определенных пределах изменять класс.</p>
    <p class="no_mb">
        Вот наиболее важные изменения, с которыми спецификация Java Object Serialization может справляться
        автоматически:
    </p>
    <ul class="tab-2">
        <li>добавление в класс новых полей;</li>
        <li>изменение полей из статических в нестатические;</li>
        <li>изменение полей из транзитных в нетранзитные.</li>
    </ul>
    <p>
        Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные)
        или удаление полей требуют определенной дополнительной обработки в зависимости от того,
        какая степень обратной совместимости необходима.
    </p>
    <p>
        Сериализация работает быстрее, чем JSON и XML, за счет того что это бинарные данные (байты).
    </p>

    <h4 class="no_mb">Для чего нужна сериализация?</h4>
    <p>для передачи или сохранения объектов (данных).</p>


    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="q2">
    <h1><a href="#">Процесс сериализации/десериализации с использованием Serializable</a></h1>
    <p class="no_mb">
        При использовании Serializable применяется алгоритм сериализации, который с помощью
        рефлексии (Reflection API) выполняет:
    </p>
    <ul class="tab-2">
        <li>
            <strong>запись в поток метаданных о классе</strong>, ассоциированном с объектом (имя класса,
            идентификатор SerialVersionUID, идентификаторы полей класса);
        </li>
        <li>
            <strong>рекурсивную запись в поток описания суперклассов </strong>
            (загоняются все классы по очереди) до класса java.lang.Object (не включительно);
        </li>
        <li>
            <strong>запись примитивных значений полей</strong> сериализуемого экземпляра, начиная с полей самого
            верхнего суперкласса;
        </li>
        <li>
            <strong>рекурсивную запись объектов</strong>, которые являются полями сериализуемого объекта.
        </li>
    </ul>
    <p class="main-mind no_mb">
        Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных
        о программе во время её выполнения.
    </p>
    <p>Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.</p>

    <p>
        При этом ранее сериализованные объекты повторно не сериализуются, что позволяет
        алгоритму корректно работать с циклическими ссылками.
    </p>
    <p>
        Для выполнения десериализации под объект выделяется память, после чего его поля
        заполняются значениями из потока. <strong>Конструктор объекта при этом не вызывается</strong>.
    </p>
    <p>
        Однако при десериализации будет вызван конструктор без параметров родительского
        несериализуемого класса, а его отсутствие повлечет ошибку десериализации.
    </p>
    <p class="no_mb">
        <strong>Для сериализации</strong> объектов в поток используется класс
        <strong>ObjectOutputStream</strong>.
    </p>
    <p><span class="code-word">void writeObject(Object obj)</span> - записывает в поток отдельный объект</p>
    <p><span class="code-word">void close()</span> - закрывает поток</p>
    <p><span class="code-word">void flush()</span> - очищает буфер и сбрасывает его содержимое в выходной поток</p>
    <p class="no_mb"><strong>Для десериализации – ObjectInputStream</strong>. </p>
    <p><span class="code-word">Object readObject()</span>считывает из потока объект</p>
    <p><span class="code-word">void close()</span> - закрывает поток</p>



    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="q3">
    <h1><a href="#">Изменение и настройка сериализации</a></h1>
    <hr>
    <h4>Как изменить стандартное поведение сериализации/десериализации?</h4>
    <p>
        <strong>Реализовать интерфейс java.io.Externalizable</strong>, который позволяет применение
        пользовательской логики сериализации.
    </p>
    <p>
        Способ сериализации и десериализации описывается в методах
        <strong>writeExternal()</strong> и <strong>readExternal()</strong>.
    </p>
    <p>
        Во время десериализации вызывается конструктор без параметров,
        а потом уже на созданном объекте вызывается метод readExternal.
    </p>
    <p>
        Для «мегакастомной» сериализации. Не пишется мета-информация и инфа о суперклассах.
    </p>
    <p class="no_mb">

        Если у сериализуемого объекта реализован один из следующих методов, то механизм
        сериализации будет использовать его, а не метод по умолчанию :
    </p>
    <p><span class="code-word">writeObject()</span> - запись объекта в поток</p>
    <p><span class="code-word">readObject()</span> - чтение объекта из потока</p>
    <p><span class="code-word">writeReplace()</span>
        - позволяет заменить себя экземпляром другого класса перед записью </p>
    <p><span class="code-word">readResolve()</span> - озволяет заменить на себя другой объект после чтения</p>
    <hr>
    <h4>Будет ли сериализовано final поле?</h4>
    <p>Да</p>
    <hr>
    <h4>Какие поля не будут сериализованы при сериализации?</h4>
    <p>
        Поля класса, помеченные модификатором <span class="code-word">transient</span>,
        <strong>не сериализуются</strong>.
    </p>
    <p>
        Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще
        вычислить. Другой пример такого поля - ссылка на экземпляр объекта, который не требует
        сериализации или не может быть сериализован.
    </p>
    <p class="no_mb">
        При стандартной сериализации поля, имеющие модификатор
        <span class="code-word">static</span>, <strong>не сериализуются</strong>.
    </p>
    <p> Соответственно, после десериализации это поле значения не меняет. </p>
    <p>
        При использовании реализации Externalizable сериализовать и десериализовать статическое поле можно, но не
        рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.
    </p>
    <p class="no_mb">
        Поля с модификатором <span class="code-word">final</span> <strong>сериализуются</strong> как и обычные.
    </p>
    <p>
        За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final поля
        должны быть инициализированы в конструкторе, а после этого в readExternal() изменить значение этого поля
        будет невозможно. Соответственно, если необходимо сериализовать объект с final полем
        необходимо использовать только стандартную сериализацию.
    </p>
    <hr>
    <h4>Как создать собственный протокол сериализации?</h4>
    <p>
        Для создания собственного протокола сериализации достаточно <strong>реализовать интерфейс
        Externalizable</strong>, который содержит два метода:
    </p>
    <p>
    <p class="code-word" style="white-space: normal">
        public void writeExternal(ObjectOutput out) throws IOException;</p>
    <p class="code-word" style="white-space: normal">
        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException
    </p>
    <hr>
    <h4>Какая роль поля serialVersionUID в сериализации?</h4>
    <p class="main-mind">
        serialVersionUID используется для указании версии сериализованных данных.
    </p>
    <p class="no_mb">
        Когда мы не объявляем serialVersionUID в нашем классе явно, среда выполнения Java делает
        это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей,
        тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр.
    </p>
    <p>
        Рекомендуется явно объявлять serialVersionUID т.к. при добавлении, удалении атрибутов
        класса динамически сгенерированное значение может измениться и в момент выполнения будет
        выброшено исключение InvalidClassException.
    </p>
    <div class="code">
        <p>private static final long serialVersionUID = 20161013L;</p>
    </div>
    <h4>Когда стоит изменять значение поля serialVersionUID?</h4>
    <p>
        serialVersionUID нужно изменять при внесении в класс несовместимых изменений, например
        при удалении какого-либо его атрибута.
    </p>
    <hr>
    <h4>Как не допустить сериализацию</h4>
    <p class="main-mind">
        Чтобы не допустить автоматическую сериализацию можно переопределить private
        методы для создания исключительной ситуации NotSerializableException.
    </p>
    <div class="code">
        <p>private void writeObject(ObjectOutputStream out) throws IOException {</p>
        <p class="tab-1">throw new NotSerializableException();</p>
        <p>}</p>
        <p>private void readObject(ObjectInputStream in) throws IOException {</p>
        <p class="tab-1">throw new NotSerializableException();</p>
        <p>}</p>
    </div>
    <p> Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации. </p>
    <hr>
    <h4>В чем проблема сериализации Singleton?</h4>
    <p>
        Проблема в том, что после десериализации мы <strong>получим другой объект</strong>. Таким образом,
        сериализация дает возможность создать Singleton еще раз, что недопустимо.
    </p>
    <p class="no_mb">Существует два способа избежать этого:</p>
    <ul class="tab-2">
        <li>явный запрет сериализации</li>
        <li>
            <p>определение метода с сигнатурой</p>
            <p class="code no_mb">default/public/private/protected Object readResolve() throws ObjectStreamException</p>
            <p>назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.</p>
        </li>
    </ul>


    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="q4">
    <h1><a href="#">Клонирование объектов</a></h1>
    <h3>3 СПОСОБА</h3>
    ...<br>
    ...<br>
    ...
    <hr>
    <h4>Какой способ клонирования предпочтительней?</h4>
    <p class="no_mb">
        Наиболее безопасным и следовательно предпочтительным способом клонирования является
        <strong>использование специализированного конструктора копирования</strong>:
    </p>
    <ul>
        <li>
            Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые
            поля, которые не будут склонированы через метод clone());
        </li>
        <li>Поля для клонирования указываются явно;</li>
        <li>Возможность клонировать даже final поля.</li>
    </ul>
    <p>. </p>
    <hr>
    <h4>Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?</h4>
    <p>
        Метод <span class="code-word">clone()</span> объявлен в классе Object с указанием модификатора
        <span class="code-word">native</span>, чтобы обеспечить доступ к стандартному механизму поверхностного
        копирования объектов.
    </p>
    <p>
        Одновременно он объявлен и как <span class="code-word">protected</span>,
        чтобы нельзя было вызвать этот метод у не переопределивших его объектов.
    </p>
    <p>
        Непосредственно <strong>интерфейс Cloneable является маркерным</strong> (не содержит объявлений
        методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы
        быть клонированным.
    </p>
    <p>
        Вызов переопределённого метода clone() у не Cloneable объекта вызовет
        выбрасывание CloneNotSupportedException.
    </p>

    <hr>
    <h4>Как создать глубокую копию объекта?</h4>
    <p class="no_mb">Два способа:</p>
    <ol>
        <li>через конструктор копирования</li>
        <li>через перепределение clone()</li>
    </ol>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../exceptions/">Исключения</a>
    <a class="navi-button navi--next" href="../generics/">Generics</a>
</div>

<a href="#" class="button button--top"></a>


<footer>
        <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

</body>

<script src="../../../../js/image.js"></script>

</html>