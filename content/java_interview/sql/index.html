<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb"><a href="../">SQL и Базы данных</a></h1>
    <div class="after-h1">Вопросы и ответы для подготовки к собеседованиям</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="..">Questions</a></p>
        <p>SQL</p>
    </div>
    <h3 class="no_mt">Вопросы: <span class="submenu-total"></span></h3>
    <ul class="menu">
        <li><a href="#relation_db">Реляционная база данных</a></li>
        <li><a href="#sql_about">Что такое SQL</a></li>
        <li>
            <p class="mb10">
                <a href="#sql_command">Команды SQL</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#ddl">DDL <span class="example">(Data Definition Language)</span></a></li>
                <li><a href="#dcl">DCL <span class="example">(Data Control Language)</span></a></li>
                <li><a href="#tcl">TCL <span class="example">(Тгаnsасtiоn Соntrol Language)</span></a></li>
                <li><a href="#dml">DML <span class="example">(Data Manipulation Language)</span></a></li>
            </ul>
        </li>
        <li>
            <p class="mb10">
                <a href="#datatype">Типы данных</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#string_datatype">Строковые</a></li>
                <li><a href="#float_integer_datatype">С плавающей точкой и целые числа</a></li>
                <li><a href="#datetime_datatype">Дата и время</a></li>
                <li><a href="#null">Нюансы работы с NULL в SQL</a></li>
            </ul>
        </li>
        <li><a href="#saved-triggers">Хранимы процедуры и триггеры</a></li>
        <li><a href="#view-temptable">VIEW и временные таблицы</a></li>
        <li>
            <p class="mb10">
                <a href="#transactions">Транзакции</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#transaction">Определение</a></li>
                <li><a href="#acid">ACID</a></li>
                <li><a href="#anomalies">Аномалии</a></li>
                <li><a href="#isolation_levels">Уровни изоляций в SQL</a></li>
                <li><a href="#propagation">Распространение транзакций</a></li>
                <li><a href="#problem">Грабли @Transactional</a></li>
            </ul>
        </li>
        <li>
            <p class="mb10">
                <a href="#joins">Виды JOIN</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#join_about">Определение</a></li>
                <li><a href="#join_inner">INNER JOIN</a></li>
                <li><a href="#join_outer">OUTER JOIN</a></li>
                <li><a href="#join_cross">CROSS JOIN</a></li>
                <li><a href="#join_self">SELF JOIN</a></li>
            </ul>
        </li>
        <li>
            <p class="mb10">
                <a href="#outer_joins">OUTER JOIN's</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#outer_left">LEFT JOIN</a></li>
                <li><a href="#outer_right">RIGHT JOIN</a></li>
                <li><a href="#outer_full">FULL JOIN</a></li>
                <li><a href="#outer_left_null">LEFT JOIN c NULL</a></li>
                <li><a href="#outer_right_null">RIGHT JOIN c NULL</a></li>
                <li><a href="#outer_full_null">FULL JOIN c NULL</a></li>
            </ul>
        </li>
        <li>
            <p class="mb10">
                <a href="#add">Дополнительные вопросы</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#join_or_subquery">Что лучше использовать JOIN или подзапросы?</a></li>
                <li><a href="#union">Что делает UNION?</a></li>
                <li><a href="#having">Чем WHERE отличается от HAVING?</a></li>
                <li><a href="#order_by">Что такое ORDER BY?</a></li>
                <li><a href="#group_by">Что такое GROUP BY?</a></li>
                <li><a href="#distinct">Что такое DISTINCT?</a></li>
                <li><a href="#limit">Что такое LIMIT?</a></li>
                <li><a href="#exist">Что такое EXISTS?</a></li>
            </ul>
        </li>
        <li><a href="#aggregation">Агрегатные функции</a></li>
        <li>
            <p class="mb10">
                <a href="#constraints_keys">Ограничения и ключи</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#constraints">Ограничения (constraints)</a></li>
                <li><a href="#keys">Ключи</a></li>
                <li><a href="#primary_unique_diff">Какие отличия между ограничениями PRIMARY и UNIQUE?</a></li>
                <li><a href="#fk_null">Может FOREIGN KEY = NULL?</a></li>
                <li><a href="#surrogate">Что такое суррогатные ключи?</a></li>
            </ul>
        </li>
        <li>
            <p class="mb10">
                <a href="#indexes">Индексы</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#index">Определение</a></li>
                <li>
                    <p class="mb10">
                        <a href="#index_type">Типы индексов</a>
                        <span class="submenu-button"></span>
                    </p>
                    <ul class="menu no-display">
                        <li><a href="#by_order">По порядку сортировки</a></li>
                        <li><a href="#by_sourse">По источнику данных</a></li>
                        <li><a href="#by_impact">По воздействию на источник данных</a></li>
                        <li><a href="#by_structure">По структуре</a></li>
                        <li><a href="#by_volume">По количественному составу</a></li>
                        <li><a href="#by_content">По характеристике содержимого</a></li>
                        <li><a href="#by_update">По механизму обновления</a></li>
                        <li><a href="#by_coverage">По покрытию индексируемого содержимого</a></li>
                        <li><a href="#index_cluster_system">Индексы в кластерных системах</a></li>
                    </ul>
                </li>
                <li><a href="#index_cluster_diff">В чем отличие между кластерными и некластерными индексами?</a></li>
                <li><a href="#index_not_selective">
                    Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?
                </a></li>
                <li><a href="#index_full_scan">Когда полное сканирование набора данных выгоднее доступа по индексу?</a>
                </li>
                <li><a href="#index_create">Как создать индекс?</a></li>
            </ul>
        </li>
        <li><a href="#replication-sharding">Репликация и шардирование</a></li>
        <li>
            <p class="mb10">
                <a href="#normal_form">Нормализация и нормальные формы</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#normalization">Нормализация</a></li>
                <li><a href="#nf_about">Нормальные формы</a></li>
                <li><a href="#1nf">Первая нормальная форма (1NF)</a></li>
                <li><a href="#2nf">Вторая нормальная форма (2NF)</a></li>
                <li><a href="#3nf">Третья нормальная форма (3NF)</a></li>
                <li><a href="#bcnf">Нормальная форма Бойса-Кодда (BCNF)</a></li>
                <li><a href="#4nf">Четвёртая нормальная форма (4NF)</a></li>
                <li><a href="#5nf">Пятая нормальная форма (5NF)</a></li>
                <li><a href="#dknf">Доменно-ключевая нормальная форма (DKNF)</a></li>
                <li><a href="#6nf">Шестая нормальная форма (6NF)</a></li>
            </ul>
        </li>
    </ul>
</section>

<section class="container" id="relation_db">
    <h1><a href="#">Реляционная база данных</a></h1>
    <div>
        <p class="term mb10">
            <span>Реляционная база данных</span>
            -&nbsp;база данных, основанная на реляционной модели данных.
        </p>
        <p>
            Реляционной называется база данных, в которой все данные, доступные пользователю,
            организованы в виде таблиц, а все oпepaции базы данных выполняются над этими таблицами.
        </p>
        <p>Столбцов не может быть 0, строк может быть 0.</p>
        <p class="term mb10">
            В правильно построенной реляционной базе данных в каждой таблице есть
            столбец (или комбинация столбцов), для которого значения во всех строках различны.
            Этот столбец (столбцы) называется <span>первичным ключом (primary key)</span>.
        </p>
        <p class="term mb10">
            Таблица, в которой все строки отличаются друг от друга, в математических
            терминах называется <span>отношением (relation)</span>.
        </p>

        <p>Двенадцать правил, которым должна соответствовать настоящая реляционная база данных:</p>
        <ol class="tab-3">
            <li>
                <p class="term mb10">
                    <span>Правило представления информации.</span><br>
                    Вся информация в реляционной базе данных должна быть представлена исключительно на логическом уровне
                    и только одним способом - в виде значений, содержащихся в таблицах.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило гарантированного доступа.</span><br>
                    Логический доступ ко всем и каждому элементу данных (атомарному значению) в реляционной базе данных
                    должен обеспечиваться путем использования комбинации имени таблицы,
                    значения первичного ключа и имени столбца.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Систематическая трактовка значения NULL.</span><br>
                    В настоящей реляционной базе данных должна быть реализована полная поддержка значений NULL
                    (которые отличаются от строки символов нулевой длины, строки пробельных символов,
                    а также от нуля или любого другого числа), которые используются для представления отсутствующей и
                    неприменимой информации систематическим образом независимо от типа этих данных.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило динамического каталога.</span><br>
                    Описание базы данных на логическом уровне должно быть представлено в том же виде, что и обычные
                    данные, чтобы пользователи, обладающие соответствующими правами,
                    могли работать с ним с помощью того же реляционного языка,
                    который они применяют для работы с основными данными.
                </p>
            </li>
            <li>
                <p class="term">
                    <span>Правило исчерпывающего подъязыка данных.</span><br>
                    Реляционная система может поддерживать несколько языков и режимов взаимодействия с пользователем.
                </p>
                <div>
                    <p>
                        Однако должен существовать по крайней мере один язык, инструкции
                        которого можно представить в виде строк символов в соответствии с некоторым
                        точно определенным синтаксисом и который в полной мере поддерживает
                        все следующие элементы:
                    </p>
                    <ul class="tab-2">
                        <li>определение данных;</li>
                        <li>определение представлений;</li>
                        <li>обработку данных (интерактивную и программную);</li>
                        <li>ограничения целостности данных;</li>
                        <li>авторизацию;</li>
                        <li>границы транзакций (начало, фиксацию и откат).</li>
                    </ul>
                </div>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило обновления представлений.</span><br>
                    Все представления, которые теоретически можно обновить,
                    должны быть доступны для обновления системой.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило высокоуровневого добавления, обновления и удаления.</span><br>
                    Операции вставки, обновления и удаления должны применяться к отношению в целом.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило физической независимости данных.</span><br>
                    Прикладные программы и утилиты для работы с данными на логическом уровне должны
                    оставаться неизменными при любых изменениях способов хранения данных или методов доступа к ним.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило логической независимости данных.</span><br>
                    Прикладные программы и утилиты для работы с данными должны на логическом уровне
                    оставаться нетронутыми при внесении в базовые таблицы любых изменений, которые теоретически
                    позволяют сохранить нетронутыми содержащиеся в этих таблицах данные.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило независимости контроля целостности.</span><br>
                    Должна существовать возможность определять условия целостности, специфичные для конкретной
                    реляционной базы данных, на подъязыке этой базы данных и хранить их в каталоге,
                    а не в прикладной программе.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Правило независимости распространения.</span><br>
                    Реляционная база данных должна быть переносима не только в пределах системы, но и по сети.
                </p>
            </li>
            <li>
                <p class="term">
                    <span>Правило согласования языковых уровней.</span><br>
                    Если в реляционной системе есть низкоуровневый язык (обрабатывающий одну запись за один раз), то он
                    не должен иметь возможность обходить правила и условия целостности данных,
                    выраженные на реляционном языке высокого уровня (обрабатывающем несколько записей за один раз).
                </p>
                <p class="example mb10">
                    Т.е. предотвращает использование других средств работы с базой данных, помимо ее подъязыка,
                    поскольку это может нарушить ее целостность
                </p>
            </li>
        </ol>
    </div>

    <a class="button button--to_top_menu" href="#"></a>

</section>

<section class="container" id="sql_about">
    <h1><a href="#">Что такое SQL</a></h1>
    <div>
        <p class="term mb10">
            <span> SQL (Structured Query Language)</span>
            -&nbsp;язык структурированных запросов.
        </p>
        <p class="term mb10">
            <span>SQL</span>
            является инструментом, предназначенным для организации, управления,
            выборки и обработки информации, содержащейся в реляционных базах данных.
        </p>
        <div>
            <p class="bold">Что умеет SQL:</p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>Определение данных.</span><br>
                        SQL позволяет пользователю определить структуру и организацию хранимых данных и взаимоотношения
                        между элементами сохраненных данных.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Выборка данных.</span><br>
                        SQL дает пользователю или приложению возможность извлекать из базы содержащиеся в ней данные и
                        пользоваться ими.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Обработка данных.</span><br>
                        SQL позволяет пользователю или приложению изменять базу данных, т.е. добавлять в нее новые
                        данные, а
                        также удалять или обновлять уже имеющиеся в ней данные.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Управление доступом.</span><br>
                        С помощью SQL можно ограничить возможности пользователя по выборке, добавлению и изменению
                        данных и
                        защитить их от несанкционированного доступа.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Совместное использование данных.</span><br>
                        SQL применяется для координации совместного использования данных пользователями,
                        работающими одновременно, с тем чтобы изменения, вносимые одним пользователем,
                        не приводили к непреднамеренному уничтожению изменений,
                        вносимых примерно в то же время иным пользователем.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Целостность данных.</span><br>
                        SQL позволяет обеспечить целостность базы данных,
                        защищая ее от разрушения из-за несогласованных изменений или
                        отказа системы.
                    </p>
                </li>
            </ul>
        </div>
        <div>
            <p>
                Сердцем СУБД является механизм базы данных (database engine, часто называемый просто движком).
                Oн отвечает за структурирование данных, сохранение и получение их из базы данных. Он принимает
                SQL-запросы
                от других компонентов СУБД, от пользовательских приложений и даже от других вычислительных систем.
            </p>
            <p>
                Язык SQL относится к непроцедурным (nonprocedural) языкам — он лишь описывает нужные компоненты
                (например, таблицы) и желаемые результаты, не указывая, как именно эти результаты должны быть получены.
                Каждая реализация SQL является надстройкой над процессором базы данных (database engine), который
                интерпретирует операторы SQL и определяет порядок обращения к структурам БД для корректного и
                эффективного формирования желаемого результата.
            </p>
        </div>
        <p class="spoiler-string">
            Несколько свойства SQL, обеспечивающие такой его успех в течение последних десятилетий...
        </p>
        <div class="spoiler">
            <ul>
                <li>Независимость от конкретных СУБД</li>
                <li>Межплатформенная переносимость</li>
                <li>Наличие стандартов</li>
                <li>Поддержка со стороны компании IВМ</li>
                <li>Поддержка со стороны компании Microsoft</li>
                <li>Построение на реляционной модели</li>
                <li>Высокоуровневая структура, напоминающая естественный язык</li>
                <li>Возможность выполнения специальных интерактивных запросов</li>
                <li>Обеспечение программного доступа к базам данных</li>
                <li>Возможность различного представления данных</li>
                <li>Полноценность в качестве языка, предназначенного для работы с базами данных</li>
                <li>Возможность динамического определения данных</li>
                <li>Поддержка архитектуры клиент/ сервер</li>
                <li>Поддержка приложений уровня предприятия</li>
                <li>Расширяемость и поддержка объектно-ориентированных технологий</li>
                <li>Возможность доступа к данным в Интернете</li>
                <li>Интеграция с языком java (протокол JDВC)</li>
                <li>Поддержка открытого кода</li>
                <li>Промышленная инфраструктура</li>
            </ul>
        </div>
    </div>
    <div>
        <p class="bold mb10">Итого:</p>
        <ul class="margined">
            <li>SQL основан на реляционной модели данных, в которой данные организованы в виде коллекции таблиц.</li>
            <li>Каждая таблица имеет уникальное имя.</li>
            <li>
                В каждой таблице есть один или несколько именованных столбцов, расположенных в определенном порядке
                слева направо.
            </li>
            <li>
                В каждой таблице есть нуль или более строк, каждая из которых содержит одно значение данных в каждом
                столбце; строки в таблице не упорядочены.
            </li>
            <li>
                Все значения данных в одном столбце имеют одинаковый тип данных и входят в набор допустимых значений,
                который называется доменом столбца.
                <br>Отношения между таблицами реализуются с помощью содержащихся в них данных. В реляционной модели
                данных для представления этих отношений используются первичные и внешние ключи.
            </li>
            <li>
                Первичным ключом может быть столбец или комбинация столбцов таблицы, значения которых уникальным образом
                идентифицируют каждую строку таблицы.
                <br>У таблицы есть только один первичный ключ.
            </li>
            <li>
                Внешним ключом является столбец или группа столбцов таблицы, значения которых совпадают со значениями
                первичного ключа другой таблицы.
                <br>Таблица может содержать несколько внешних ключей, связывающих ее с одной или несколькими другими
                таблицами.
            </li>
            <li>
                Пара "первичный ключ-внешний ключ" создает отношение "предок-потомок" между таблицами, содержащими их.
            </li>
        </ul>
    </div>
    <p><a class="link-to-source" href="https://sql-language.ru/" target="_blank">сайтик про SQL</a></p>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="sql_command">
    <h1><a href="#">Команды SQL</a></h1>
    <div class="after-h1">
        <h3>Группы команд SQL</h3>
        <ul class="margined">
            <li>
                <p class="term">
                    <a href="#ddl">
                        <span>DDL (Data Definition Language)</span>
                    </a>
                    <br> Команды языка определения данных.
                </p>
                <p class="example">
                    Эти SQL команды можно использовать для создания,
                    изменения и удаления различных объектов базы данных.
                </p>
            </li>
            <li>
                <p class="term">
                    <a href="#dcl">
                        <span>DCL (Data Control Language)</span>
                    </a>
                    <br> Команды языка управления данными.</p>
                <p class="example">
                    С помощью этих SQL команд можно управлять доступом пользователей к базе данных и использовать
                    конкретные данные (таблицы, представления и т.д.).
                </p>
            </li>
            <li>
                <p class="term">
                    <a href="#tcl">
                        <span>TCL (Тгаnsасtiоn Соntrol Language)</span>
                    </a>
                    <br>Команды языка управления транзакциями.
                </p>
                <p class="example">Эти SQL команды позволяют определить исход транзакции.</p>
            </li>
            <li>
                <p class="term">
                    <a href="#dml">
                        <span>DML (Data Manipulation Language)</span>
                    </a>
                    <br> Команды языка манипулирования данными.
                </p>
                <p class="example">Эти SQL команды позволяют пользователю перемещать данные в базу данных и из нее.</p>
            </li>
        </ul>
    </div>

    <div id="ddl">
        <h3><a href="#sql_command">DLL команды</a></h3>
        <div>
            <ul>
                <li>
                    <p class="term">
                        <span>CREATE</span><br>
                        Создает объект БД (базу, таблицу, представление, пользователя
                        и&nbsp;т.д.).
                    </p>
                    <p class="example mb10">CREATE DATABASE Test</p>
                </li>
                <li>
                    <p class="term">
                        <span>ALTER</span><br>
                        Изменяет объект.
                    </p>
                    <p class="example mb10">ALTER TABLE ...</p>
                </li>
                <li>
                    <p class="term">
                        <span>DROP</span><br>
                        Удаляет объект.
                    </p>
                    <p class="example mb10">DROP TABLE ...</p>
                </li>
                <li>
                    <p class="term">
                        <span>TRUNCATE</span><br>
                        "Удаление" всех записей в таблице.
                    </p>
                    <p class="example">TRUNCATE TABLE ...</p>
                    <div>
                        <p class="spoiler-string">Особенности</p>
                        <div class="spoiler">
                            <ul>
                                <li>Не срабатывают триггеры, в частности, триггер удаления</li>
                                <li>Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных
                                    в журнал транзакций
                                </li>
                                <li>Сбрасывает счетчик идентификаторов до начального значения</li>
                                <li>Чтобы использовать, необходимы права на изменение таблицы</li>
                                <li>Не используется когда в таблице есть внешние ключи надо использовать DELETE</li>
                            </ul>
                        </div>
                    </div>
                </li>
            </ul>
            <div>
                <p class="spoiler-string">Команды, что бы проверить выполнение</p>
                <div class="spoiler">
                    <p class="term mb10">
                        <span>SHOW DATABASES</span><br>
                        Посмотеть созданые базы.
                    </p>
                    <p class="term mb10">
                        <span>SHOW TABLES</span><br>
                        Кроме пользовательских таблиц покажет также и служебные таблицы.
                    </p>
                    <p class="term mb10">
                        <span> DESCRIBE table_name</span><br>
                        Получение информации о столбцах
                    </p>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#sql_command"></a>
    </div>

    <hr>
    <div id="dcl">
        <h3><a href="#sql_command">DCL команды</a></h3>
        <div>
            <ul>
                <li>
                    <p class="term">
                        <span>GRANT</span><br>
                        Предоставляет пользователю (группе) разрешения на определенные операции с объектом.
                    </p>
                    <p class="example mb10">
                        Предоставление права чтения таблицы students пользователю.
                        <br>GRANT SELECT ON&nbsp;table_name TO&nbsp;user_name;
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>REVOKE</span><br>
                        Отзывает ранее выданные разрешения.
                    </p>
                    <p class="example mb10">
                        Отменить запрет.
                        <br>REVOKE SELECT ON&nbsp;table_name FROM&nbsp;user_name;
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>DENY</span><br>
                        Задает запрет, имеющий приоритет над разрешением
                    </p>
                    <p class="example mb10">
                        Запрет права выборки из таблицы пользователя.
                        <br>DENY SELECT ON&nbsp;table_name TO&nbsp;user_name;
                    </p>
                </li>
            </ul>
        </div>
        <a class="button button--to_content_menu" href="#sql_command"></a>
    </div>

    <hr>
    <div id="tcl">
        <h3><a href="#sql_command">TCL команды</a></h3>
        <div>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>COMMIT</span><br>
                        Применяется для завершения транзакции и сохранения изменений в базе данных.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>ROLLBACK</span><br>
                        Откатывает все изменения, сделанные в контексте текущей транзакции.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>SAVEPOINT</span><br>
                        Создаёт точку к которой группа транзакций может откатиться,
                        разбивает транзакцию на более мелкие.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>SET</span> TRANSACTION<br>
                        Применяется для установки параметров доступа к данным в текущей транзакции.
                    </p>
                    <p class="example">
                        Транзакция предназначена только для чтения:
                        <br>SET TRANSACTION READ ONLY
                    </p>
                </li>
            </ul>
            <p class="main-mind">
                Команды управление транзакциями используются только для DML команд: INSERT, UPDATE, DELETE
            </p>
        </div>
        <a class="button button--to_content_menu" href="#sql_command"></a>
    </div>

    <hr>
    <div id="dml">
        <h3><a href="#sql_command">DML команды</a></h3>
        <div>
            <ul class="margined">
                <li>
                    <p class="term">
                        <span>SELECT</span><br>
                        Выбирает данные, удовлетворяющие заданным условиям.
                    </p>
                    <div>
                        <p class="spoiler-string">Схема запроса</p>
                        <div class="spoiler">
                            <div class="code">
                                SELECT [DISTINCT | ALL] поля_таблиц
                                <br>FROM список_таблиц
                                <br>[WHERE условия_на_ограничения_строк]
                                <br>[GROUP BY условия_группировки]
                                <br>[HAVING условия_на_ограничения_строк_после_группировки по агрегатным функциям]
                                <br>[ORDER BY порядок_сортировки [ASC | DESC]]
                                <br>[LIMIT ограничение_количества_записей]
                            </div>
                        </div>
                    </div>
                </li>
                <li>
                    <p class="term">
                        <span>INSERT</span><br>
                        Добавляет новые данные.
                    </p>
                    <div>
                        <p class="spoiler-string">Схема запроса</p>
                        <div class="spoiler">
                            <div class="code">
                                INSERT INTO имя_таблицы [(поле_таблицы, ...)]
                                <br>VALUES (значение_поля_таблицы, ...)
                                <br>| SELECT поле_таблицы, ... FROM имя_таблицы ...
                            </div>
                        </div>
                    </div>
                </li>
                <li>
                    <p class="term mb10">
                        <span>UPDATE</span><br>
                        Изменяет существующие данные.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>DELETE</span><br>
                        Удаляет данные.
                    </p>
                </li>
            </ul>
        </div>
        <a class="button button--to_content_menu" href="#sql_command"></a>
    </div>

    <hr>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="datatype">
    <h1><a href="#">Типы данных</a></h1>
    <div class="after-h1 menu">
        <ul>
            <li><a href="#string_datatype">Строковые</a></li>
            <li><a href="#float_integer_datatype">С плавающей точкой и целые числа</a></li>
            <li><a href="#datetime_datatype">Дата и время</a></li>
        </ul>
    </div>
    <div id="string_datatype">
        <h3><a href="#datatype">Строковые</a></h3>
        <table class="list list--dictionary" aria-label="string_datatype">
            <thead>
            <tr>
                <th>Типы данных SQL</th>
                <th>Описание</th>
            <tr>
            </thead>
            <tr>
                <td>CHAR(size)</td>
                <td>Строки фиксированной длиной (могут содержать буквы, цифры и специальные символы).
                    <br>Фиксированный размер указан в скобках.
                    <br>Можно записать до 255&nbsp;символов
                </td>
            </tr>
            <tr>
                <td>VARCHAR(size)</td>
                <td>Может хранить не более 255&nbsp;символов.</td>
            </tr>
            <tr>
                <td>TINYTEXT</td>
                <td>Может хранить не более 255&nbsp;символов.</td>
            </tr>
            <tr>
                <td>TEXT</td>
                <td>Может хранить не более 65&nbsp;535&nbsp;символов.</td>
            </tr>
            <tr>
                <td>BLOB</td>
                <td>Может хранить не более 65&nbsp;535&nbsp;символов.</td>
            </tr>
            <tr>
                <td>MEDIUMTEXT</td>
                <td>Может хранить не более 16&nbsp;777&nbsp;215&nbsp;символов.</td>
            </tr>
            <tr>
                <td>MEDIUMBLOB</td>
                <td>Может хранить не более 16&nbsp;777&nbsp;215&nbsp;символов.</td>
            </tr>
            <tr>
                <td>LONGTEXT</td>
                <td>Может хранить не более 4&nbsp;294&nbsp;967&nbsp;295&nbsp;символов.</td>
            </tr>
            <tr>
                <td>LONGBLOB</td>
                <td>Может хранить не более 4&nbsp;294&nbsp;967&nbsp;295&nbsp;символов.</td>
            </tr>
            <tr>
                <td>ENUM(x,y,z,etc.)</td>
                <td>
                    Позволяет вводить список допустимых значений.
                    <br>Может содержать до 65&nbsp;535.
                    <br>Если при вставке значения не будет присутствовать в списке ENUM, то мы получим пустое
                    значение.
                    <br>Ввести возможные значения можно в таком формате: ENUM ( 'X', 'Y', 'Z')
                </td>
            </tr>
            <tr>
                <td>SET</td>
                <td>Как ENUM, но может содержать до 64&nbsp;значений.</td>
            </tr>
        </table>
        <a class="button button--to_content_menu" href="#datatype"></a>
    </div>

    <hr>
    <div id="float_integer_datatype">
        <h3><a href="#datatype">С плавающей точкой (дробные числа) и целые числа</a></h3>
        <table class="list" aria-label="float_integer_datatype">
            <thead>
            <tr>
                <th>Типы данных SQL</th>
                <th>Описание</th>
            <tr>
            </thead>
            <tr>
                <td>TINYINT(size)</td>
                <td>Может хранить числа от -128 до 127</td>
            </tr>
            <tr>
                <td>SMALLINT(size)</td>
                <td>Диапазон от -32&nbsp;768 до 32&nbsp;767</td>
            </tr>
            <tr>
                <td>MEDIUMINT(size)</td>
                <td>Диапазон от -8&nbsp;388&nbsp;608 до 8&nbsp;388&nbsp;607</td>
            </tr>
            <tr>
                <td>INT(size)</td>
                <td>Диапазон от -2&nbsp;147&nbsp;483&nbsp;648 до 2&nbsp;147&nbsp;483&nbsp;647</td>
            </tr>
            <tr>
                <td>BIGINT(size)</td>
                <td>
                    Диапазон от -9&nbsp;223&nbsp;372&nbsp;036&nbsp;854&nbsp;775&nbsp; 808
                    до 9&nbsp;223&nbsp;372&nbsp;036&nbsp;854&nbsp;775&nbsp;807
                </td>
            </tr>
            <tr>
                <td>FLOAT(size,d)</td>
                <td>Число с плавающей точкой небольшой точности.</td>
            </tr>
            <tr>
                <td>DOUBLE(size,d)</td>
                <td>Число с плавающей точкой двойной точности.</td>
            </tr>
            <tr>
                <td>DECIMAL(size,d)</td>
                <td>Дробное число, хранящееся в виде строки.</td>
            </tr>
        </table>
        <a class="button button--to_content_menu" href="#datatype"></a>
    </div>

    <hr>
    <div id="datetime_datatype">
        <h3><a href="#datatype">Дата и время</a></h3>
        <table class="list" aria-label="datetime_datatype">
            <thead>
            <tr>
                <th>Типы данных SQL</th>
                <th>Описание</th>
            <tr>
            </thead>
            <tr>
                <td>DATE()</td>
                <td>Дата в формате <span class="wrap-no">ГГГГ-ММ-ДД</span></td>
            </tr>
            <tr>
                <td>DATETIME()</td>
                <td>
                    Дата и время в формате
                    <span class="wrap-no">ГГГГ-ММ-ДД ЧЧ:ММ:СС</span>
                </td>
            </tr>
            <tr>
                <td>TIMESTAMP()</td>
                <td>
                    Дата и время в формате timestamp.
                    <br>Однако при получении значения поля оно отображается не в формате timestamp, а
                    в виде <span class="wrap-no">ГГГГ-ММ-ДД ЧЧ:ММ:СС</span>
                </td>
            </tr>
            <tr>
                <td>TIME()</td>
                <td>Время в формате <span class="wrap-no">ЧЧ:ММ:СС</span></td>
            </tr>
            <tr>
                <td>YEAR()</td>
                <td>Год в двух значной или в четырехзначном формате.</td>
            </tr>
        </table>
        <p class="main-mind">У каждой реализации могут быть свои типы данных!!!</p>
        <a class="button button--to_content_menu" href="#datatype"></a>
    </div>

    <hr>
    <div id="null">
        <h3><a href="#">Нюансы работы с NULL в&nbsp;SQL</a></h3>
        <div>
            <p class="term mb10">
                <span>NULL</span>
                -&nbsp;специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных.
                NULL соответствует понятию "пустое поле", то есть "поле, не содержащее никакого значения".
            </p>
            <p class="main-mind">
                NULL означает отсутствие, неизвестность информации.
            </p>
            <p class="main-mind">
                Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие
                значения и не принадлежит ни одному типу данных.
            </p>
            <p class="main-mind">
                Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни&nbsp;0.
            </p>
            <p class="main-mind">
                При сравнении NULL с любым значением будет получен результат NULL, а не&nbsp;FALSE и не&nbsp;0.
            </p>
            <p class="main-mind">
                Более того, NULL не равно NULL!
            </p>
            <p class="term">Команды для проверки: <span>IS&nbsp;NULL, IS&nbsp;NOT&nbsp;NULL</span></p>

        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="saved-triggers">
    <h1><a href="#">Хранимые процедуры и триггеры</a></h1>

    <div id="saved">
        <h3><a href="#saved-triggers">Хранимые процедуры</a></h3>
        <div>
            <p class="term mb10">
                <span>Хранимая процедура</span>
                -&nbsp;объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и
                хранится на сервере.
            </p>
            <p>
                Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого
                уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться
                числовые вычисления и операции над символьными данными, результаты которых могут присваиваться
                переменным и параметрам.
            </p>
            <p>
                В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и
                DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться
                инструкции управления процессом исполнения.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="triggers">
        <h3><a href="#saved-triggers">Триггеры</a></h3>
        <div>
            <p class="term">
                <span>Триггеры</span>
                представляют специальный тип хранимой процедуры, которая вызывается автоматически при выполнении
                определенного действия над таблицей или представлением, в частности, при добавлении, изменении или
                удалении данных, то есть при выполнении команд INSERT, UPDATE, DELETE.
            </p>
            <p class="example">
                Допустим, в таблице Products хранятся данные о товарах. Но цена товара нередко содержит различные
                надбавки
                типа налога на добавленную стоимость, налога на добавленную коррупцию и так далее. Человек, добавляющий
                данные, может не знать все эти тонкости с налоговой базой, и он определяет чистую цену. С помощью
                триггера мы можем поправить цену товара на некоторую величину.
            </p>
            <p>Схема запроса</p>
            <div class="code">
                CREATE TRIGGER имя_триггера
                <br>ON {имя_таблицы | имя_представления}
                <br>{AFTER | INSTEAD OF} [INSERT | UPDATE | DELETE]
                <br>AS выражения_sql
            </div>
        </div>
        <a class="button button--to_content_menu" href="#triggers"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="view-temptable">
    <h1><a href="#">VIEW и временные таблицы</a></h1>

    <div id="view">
        <h3><a href="#view-temptable">VIEW</a></h3>
        <div>
            <p class="term mb10">
                <span>View (Представление)</span>
                -&nbsp;виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.
            </p>
            <p>
                В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в
                структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и
                основные таблицы, но не содержат никаких собственных данных.
            </p>
            <p class="main-mind">
                Представления значительно расширяют возможности управления данными.
            </p>
            <p class="no_mb"> Пример дать публичный доступ к некоторой (но&nbsp;не&nbsp;всей) информации в таблице:</p>
            <div class="code"><pre>CREATE VIEW Londonstaff
        AS SELECT *
        FROM Salespeople
        WHERE city = 'London';</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#view-temptable"></a>
    </div>

    <hr>
    <div id="temptable">
        <h3><a href="#view-temptable">Временные таблицы</a></h3>
        <div>
            <p class="term mb10">
                <span>Временная таблица</span>
                -&nbsp;это объект базы данных, который хранится и управляется системой базы данных на временной основе.
            </p>
            <p>Они могут быть локальными (только я могу работать) или глобальными (все).</p>
            <p>
                Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при
                соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных
                представлений.
            </p>
            <p class="main-mind">Срок жизни временной таблицы – сеанс с БД</p>

        </div>

        <a class="button button--to_content_menu" href="#view-temptable"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="transactions">
    <h1><a href="#">Транзакции</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#transaction">Определение</a></li>
        <li><a href="#acid">ACID</a></li>
        <li><a href="#isolation_levels">Уровни изоляций в SQL</a></li>
        <li><a href="#anomalies">Аномалии</a></li>
        <li><a href="#propagation">Распространение транзакций</a></li>
        <li><a href="#problem">Грабли @Transactional</a></li>
    </ul>

    <div id="transaction">
        <h3><a href="#transactions">Транзакция</a></h3>
        <div>
            <p class="term mb10">
                <span>Транзакция</span>
                -&nbsp;это воздействие на базу данных, переводящее её из одного целостного (консистентного) состояния в
                другое и выражаемое в изменении данных, хранящихся в базе данных.
                <br>Это N (N≥1) запросов к БД, которые выполнятся успешно все вместе или не выполнятся вовсе.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="acid">
        <h3><a href="#transactions">ACID</a></h3>
        <div>
            <p>Основные свойства транзакции</p>
            <ul class="margined">
                <li>
                    <p class="term mb10">
                        <span>Атомарность (atomicity)</span><br>
                        Гарантирует, что никакая транзакция не будет зафиксирована в системе частично.
                        Будут либо выполнены все её подоперации, либо не выполнено ни одной.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>Согласованность (consistency)</span><br>
                        Транзакция, достигающая своего нормального завершения
                        (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты,
                        сохраняет согласованность базы данных.
                    </p>
                    <p class="example mb10">
                        Другими словами, каждая успешная транзакция по определению фиксирует только допустимые
                        результаты.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Изолированность (isolation)</span><br>
                        Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее
                        результат.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Долговечность (durability)</span><br>
                        Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в
                        оборудовании) изменения, сделанные успешно завершённой транзакцией, должны
                        остаться сохраненными после возвращения системы в работу. Если пользователь получил
                        подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им
                        изменения не будут отменены из-за какого-либо сбоя.
                    </p>
                </li>
            </ul>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="anomalies">
        <h3><a href="#transactions">Аномалии</a></h3>
        <div>
            <p>При параллельном выполнении транзакций возможны следующие проблемы (аномалии):</p>
            <ol>
                <li>
                    <p class="term mb10">
                        <span>Потерянное обновление (англ. lost&nbsp;update)</span><br>
                        При одновременном изменении одного блока данных разными транзакциями теряются все изменения,
                        кроме последнего.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Грязное чтение (англ. dirty&nbsp;read)</span><br>
                        Чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится
                        (откатится);
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Неповторяющееся чтение (англ. <span class="wrap-no">non-repeatable read</span>)</span><br>
                        При повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Фантомное чтение (англ. phantom&nbsp;reads)</span><br>
                        Одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем
                        же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет
                        столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно
                        заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные
                        множества строк.
                    </p>
                </li>
            </ol>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="isolation_levels">
        <h3><a href="#transactions">Уровни изоляции</a></h3>
        <div>
            <p>
                Выбирая используемый уровень изолированности транзакций, мы, в определённой мере,
                делаем выбор между скоростью работы и обеспечением гарантированной
                согласованности получаемых из системы данных.
            </p>
            <p> В порядке увеличения изолированности транзакций и, соответственно, надежности работы с данными:</p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read)</span>
                        -&nbsp;чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций.
                        <br>Нет гарантии, что данные, измененные другими транзакциями, не будут в любой момент изменены
                        в результате их отката, поэтому такое чтение является потенциальным источником ошибок.
                        <br>Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Чтение подтвержденных данных (read committed)</span>
                        -&nbsp;чтение всех изменений своей транзакции и зафиксированных изменений параллельных
                        транзакций.
                        <br>Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение (когда
                        мы видим обновленные и удаленные строки (UPDATE, DELETE)) и фантомы (когда мы видим добавленные
                        записи (INSERT)).
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Повторяемость чтения (repeatable read, snapshot)</span>
                        -&nbsp;чтение всех изменений своей транзакции, любые изменения, внесенные параллельными
                        транзакциями
                        после начала своей, недоступны.
                        <br>Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Упорядочиваемость (serializable)</span>
                        -&nbsp;результат параллельного выполнения сериализуемой транзакции с
                        другими транзакциями должен быть логически эквивалентен результату их какого-либо
                        последовательного выполнения.
                        <br>Проблемы синхронизации не возникают.
                    </p>
                </li>
            </ul>
            <div class="scroll">
                <table class="list list--dictionary" aria-label="isolation_level">
                    <thead>
                    <tr>
                        <th>Уровень изоляции</th>
                        <th>Не должно быть</th>
                        <th>Будут проблемы с</th>
                    <tr>
                    </thead>
                    <tr>
                        <td>
                            READ&nbsp;UNCOMMITTED, DIRTY&nbsp;READ
                            <p class="example">видят не закомиченные результаты +2проблемы</p>
                        </td>
                        <td>lost&nbsp;update</td>
                        <td>dirty&nbsp;read
                            <pre>non-repeatable read</pre>
                            phantom&nbsp;reads
                        </td>
                    </tr>
                    <tr>
                        <td>
                            READ&nbsp;COMMITTED
                            <p class="example">видят закомиченные результаты +2проблемы</p>
                        </td>
                        <td>lost&nbsp;update<br>dirty&nbsp;read</td>
                        <td>
                            <pre>non-repeatable read</pre>
                            phantom&nbsp;reads
                        </td>
                    </tr>
                    <tr>
                        <td>
                            REPEATABLE&nbsp;READ, SNAPSHOT
                            <p class="example">видят результаты Update и Delete +1проблема</p>
                        </td>
                        <td>lost update<br>dirty read
                            <pre>non-repeatable read</pre>
                        </td>
                        <td>phantom&nbsp;reads</td>
                    </tr>
                    <tr>
                        <td>SERIALIZABLE</td>
                        <td>
                            lost&nbsp;update<br>dirty&nbsp;read
                            <pre>non-repeatable read</pre>
                            phantom&nbsp;reads
                        </td>
                        <td>Нет проблем с синхронизацией</td>
                    </tr>
                </table>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#"></a>
    </div>

    <hr>
    <div id="propagation">
        <h3><a href="#transactions">Распространение транзакций</a></h3>
        <div>
            <p>Распространение транзакций (Propagation) в @Transactional</p>
            <ul class="margined">
                <li>
                    <p class="term">
                        <span>REQUIRED(0)</span><br>
                        Если активная транзакция уже существует, метод будет выполняться в её контексте.
                        Если транзакции нет, она будет создана. Режим по-умолчанию.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>SUPPORTS(1)</span><br>
                        Если существует активная транзакция, метод будет выполнен в её контексте.
                        Если транзакции нет, метод будет выполнен вне контекста транзакции.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>MANDATORY(2)</span><br>
                        Метод требует наличия активной транзакции. Если ее нет, будет выброшено
                        <span class="bad">исключение</span>.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>REQUIRES_NEW(3)</span><br>
                        Метод всегда будет выполняться в новой транзакции.
                        Если уже есть активная транзакция, она будет приостановлена до завершения новой транзакции.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>NOT_SUPPORTED(4)</span><br>
                        Метод будет выполняться вне контекста транзакции.
                        Если имеется активная транзакция, она будет приостановлена на время его выполнения.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>NEVER(5)</span><br>
                        Метод никогда не должен быть выполнен в контексте транзакции.
                        Если транзакция активна, будет выброшено <span class="bad">исключение</span>.
                    </p>
                </li>
                <li>
                    <p class="term">
                        <span>NESTED(6)</span><br>
                        Метод будет выполнен в рамках вложенной транзакции, если уже существует активная транзакция.
                        В противном случае, будет создана новая транзакция.
                    </p>
                    <p class="example">
                        Вложенные транзакции позволяют откатывать только часть операции без влияния на внешнюю
                        транзакцию.
                        Однако поддержка этой модели зависимости от конкретных систем управления транзакциями может
                        отличаться.
                    </p>
                </li>
            </ul>
            <p>
                <a class="link-to-source" href="https://youtu.be/ZVYzVqqVrms" target="_blank">
                    интересный видосик про транзакции </a>
            </p>
        </div>
        <a class="button button--to_content_menu" href="#transactions"></a>
    </div>

    <hr>
    <div id="problem">
        <h3><a href="#transactions">Грабли в&nbsp;JAVA</a></h3>
        <div>
            <p>
                Грабли при использовании аннотации @Transactional:
            </p>
            <ul class="margined">
                <li>Не вызывать метод, помеченный @Transactional из одного класса.</li>
                <li>
                    <p>
                        @Transactional не откатит транзакцию если выброшено Exception, работает с RuntimeException.
                    </p>
                    <div class="example">
                        <p>Но можно настроить</p>
                        <div class="code" style="padding: 5px">@Transactional(rollbackFor=Exception.class)</div>
                    </div>
                </li>
                <li>@Transactional работает только с public методами.</li>
                <li>@Transactional занимает соединение с БД.</li>
            </ul>
            <p>
                <a class="link-to-source" href="https://youtu.be/2E8FKi4oC0o" target="_blank">
                    очень кратенько, но полезненько</a>
            </p>
        </div>
        <a class="button button--to_content_menu" href="#transactions"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="joins">
    <h1><a href="#">Виды JOIN</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#join_about">Определение</a></li>
        <li><a href="#join_inner">INNER JOIN</a></li>
        <li><a href="#join_outer">OUTER JOIN</a></li>
        <li><a href="#join_cross">CROSS JOIN</a></li>
        <li><a href="#join_self">SELF JOIN</a></li>
    </ul>

    <div id="join_about">
        <h3><a href="#joins">Определение</a></h3>
        <div>
            <p class="term mb10">
                <span>JOIN</span>
                -&nbsp;оператор языка SQL, который является реализацией операции соединения реляционной алгебры.
                Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один
                результирующий набор.</p>
            <p>Особенностями операции соединения являются следующее:
                <br>- В схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть
                схема результата является "сцеплением" схем операндов;
                <br>- Каждая строка таблицы-результата является "сцеплением" строки из одной таблицы-операнда со
                строкой второй таблицы-операнда;
                <br>- При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется
                несколько раз (последовательно).</p>
            <div class="code">
                <pre>SELECT &lt;поля_для_выбора&gt;
FROM table_1
[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN table_2
    ON &lt;условие_соединения&gt;
[[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN table_n
    ON &lt;условие_соединения&gt;]</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <hr>
    <div id="join_inner">
        <h3><a href="#joins">INNER JOIN</a></h3>
        <div>
            <p class="bold">Внутреннее объединение</p>
            <p>Оператору передаются две таблицы, и он возвращает их внутреннее пересечение по какому-либо критерию.
                Результатом будут записи, которые соответствуют обеим таблицам.</p>
            <div class="image-box">
                <img src="./img/inner.png" alt="inner_join">
            </div>
            <div class="code">
                <pre>SELECT *
FROM table_left
INNER JOIN table_right
    ON table_left.key = table_right.key;
</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <hr>
    <div id="join_outer">
        <h3><a href="#joins">OUTER JOIN</a></h3>
        <div>
            <p class="bold">Внешнее соединение</p>
            <p class="no_mb">Возвращает не только строгое пересечение между двумя таблицами, но и отдельные элементы,
                которые принадлежат только одному из множеств. Какому — зависит от типа.</p>
            <p class="example">Если внутреннее объединение имеет сходство с бинарным "и", то внешнее — несколько
                вариаций бинарного "или".</p>
            <a class="bold" href="#outer_joins">ПОДРОБНЕЕ ДАЛЕЕ...</a>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <hr>
    <div id="join_cross">
        <h3><a href="#joins">CROSS JOIN</a></h3>
        <div>
            <p class="bold">Перекрестное соединение</p>
            <p class="no_mb">Он возвращает декартово произведение — собираются все возможные пары из обеих таблиц.
                <br>В отличие от остальных режимов, CROSS&nbsp;JOIN не требует указания дополнительной информации.</p>
            <p class="example">В разработке Cross Join может использоваться при создании тех же фильтров в
                интернет-магазине. Например, человек ищет обувь по характеристикам "тип" и "размер" — должны быть
                выведены все возможные комбинации типа с размером.</p>
            <div class="image-box">
                <img src="./img/cross.png" alt="cross_join">
            </div>
            <div class="code">
                <pre>SELECT *
FROM table_left
CROSS JOIN table_right;
</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <hr>
    <div id="join_self">
        <h3><a href="#joins">SELF JOIN</a></h3>
        <div>
            <p class="bold">Самосоединение</p>
            <p>Используется тогда, когда у разных полей одной таблицы могут быть одинаковые значения.</p>
            <p class="example">Чтобы Self Join работал правильно, могут потребоваться псевдонимы таблиц:
                они помогают называть одну и ту же таблицу разными именами. В результате оператор "воспринимает"
                переданные сущности как разные.</p>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <hr>
    <div id="join_mode">
        <h3><a href="#joins">Какие бывают виды join'ов?</a></h3>
        <div>
            <p>Чаще всего выделяют четыре режима SQL JOIN: INNER, OUTER, SELF и&nbsp;CROSS.</p>
        </div>
        <a class="button button--to_content_menu" href="#joins"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="outer_joins">
    <h1><a href="#">OUTER JOIN's</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#outer_left">LEFT JOIN</a></li>
        <li><a href="#outer_right">RIGHT JOIN</a></li>
        <li><a href="#outer_full">FULL JOIN</a></li>
        <li><a href="#outer_left_null">LEFT JOIN c NULL</a></li>
        <li><a href="#outer_right_null">RIGHT JOIN c NULL</a></li>
        <li><a href="#outer_full_null">FULL JOIN c NULL</a></li>
    </ul>

    <div id="outer_left">
        <h3><a href="#outer_joins">LEFT JOIN</a></h3>
        <div>
            <p>Возвращает пересечение множеств и все элементы из левой таблицы.</p>
            <div class="image-box">
                <img src="./img/left.png" alt="left_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
LEFT JOIN table_right
    ON table_left.key = table_right.key;
</pre>
            </div>
            <p class="example">Если в table_right нет соответствующей строки,
                то возвращаются NULL для столбцов из table_right.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <hr>
    <div id="outer_right">
        <h3><a href="#outer_joins">RIGHT JOIN</a></h3>
        <div>
            <p>Возвращает пересечение множеств и все элементы из правой таблицы.</p>
            <div class="image-box">
                <img src="./img/right.png" alt="right_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
RIGHT JOIN table_right
    ON table_left.key = table_right.key;</pre>
            </div>
            <p class="example">Если в table_left нет соответствующей строки,
                то возвращаются NULL для столбцов из table_left.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <hr>
    <div id="outer_full">
        <h3><a href="#outer_joins">FULL JOIN</a></h3>
        <div>
            <p>Возвращает обе таблицы, объединенные в одну.</p>
            <div class="image-box">
                <img src="./img/full.png" alt="full_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
FULL JOIN table_right ON table_left.key = table_right.key;
</pre>
            </div>
            <p class="example">Если в table_left нет соответствующей строки,
                то возвращаются NULL для столбцов из table_left, и наоборот,
                если в table_right нет соответствующей строки.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <hr>
    <div id="outer_left_null">
        <h3><a href="#outer_joins">LEFT JOIN c NULL</a></h3>
        <div>
            <p>Возвращает данные из левой таблицы, но без пересечений с правой.</p>
            <div class="image-box">
                <img src="./img/left_null.png" alt="left_null_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
LEFT JOIN table_right
    ON table_left.key = table_right.key
WHERE table_right.key IS NULL;
</pre>
            </div>
            <p class="example">Этот прием полезен для поиска "несвязанных" строк в левой таблице.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <hr>
    <div id="outer_right_null">
        <h3><a href="#outer_joins">FIGHT JOIN с NULL</a></h3>
        <div>
            <p>Возвращает данные из правой таблицы, но без пересечений с левой.</p>
            <div class="image-box">
                <img src="./img/right_null.png" alt="right_null_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
RIGHT JOIN table_right
    ON table_left.key = table_right.key
WHERE table_left.key IS NULL;
</pre>
            </div>
            <p class="example">Это полезно для поиска "несвязанных" строк в правой таблице.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <hr>
    <div id="outer_full_null">
        <h3><a href="#outer_joins">FULL JOIN с NULL</a></h3>
        <div>
            <p class="no_mb">Возвращает результат из обеих таблиц, кроме пересечений.</p>
            <p class="example">Работает как исключающее "или".</p>
            <div class="image-box">
                <img src="./img/full_null.png" alt="full_null_join">
            </div>
            <div class="code no_mb">
                <pre>SELECT *
FROM table_left
FULL JOIN table_right
    ON table_left.key = table_right.key
WHERE table_left.key IS NULL
    OR table_right.key IS NULL;
</pre>
            </div>
            <p class="example">Запрос выбирает все "несвязанные" строки из обеих таблиц.</p>
        </div>
        <a class="button button--to_content_menu" href="#outer_joins"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="add">
    <h1><a href="#">Дополнительные вопросы</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#join_or_subquery">Что лучше использовать JOIN или подзапросы?</a></li>
        <li><a href="#union">Что делает UNION?</a></li>
        <li><a href="#having">Чем WHERE отличается от HAVING?</a></li>
        <li><a href="#order_by">Что такое ORDER BY?</a></li>
        <li><a href="#group_by">Что такое GROUP BY?</a></li>
        <li><a href="#distinct">Что такое DISTINCT?</a></li>
        <li><a href="#limit">Что такое LIMIT?</a></li>
        <li><a href="#exist">Что такое EXISTS?</a></li>
    </ul>

    <div id="join_or_subquery">
        <h3><a href="#add">Что лучше использовать JOIN или подзапросы?</a></h3>
        <div>
            <p>
                Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется
                СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в
                случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.
            </p>
            <p>
                Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для
                сравнений во внешних запросах.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="union">
        <h3><a href="#add">Что делает UNION?</a></h3>
        <div>
            <p>Объединяет запросы в одну таблицу.</p>
            <div class="code">
                <pre>SELECT поля_таблиц FROM список_таблиц ...
UNION [ALL]
SELECT поля_таблиц FROM список_таблиц ... ;</pre>
            </div>
            <p>
                UNION по умолчанию убирает повторения в результирующей таблице. Для отображения с повторением есть
                необязательный параметр ALL.
            </p>
            <p class="main-mind no_mb">Не путайте операции объединения запросов с операциями объединения таблиц.</p>
            <p class="example">Для этого служит оператор JOIN.</p>
            <p class="main-mind no_mb">Не путайте операции объединения запросов с подзапросами.</p>
            <p class="example">Подзапросы выполняются для связанных таблиц.</p>

            <p class="main-mind">
                Для того, чтобы UNION корректно сработал нужно: чтобы результирующие таблицы каждого из SQL запросов
                имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой последовательности.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="having">
        <h3><a href="#add">Чем WHERE отличается от HAVING?</a></h3>
        <div>
            <p>Отличие HAVING от WHERE:</p>
            <p class="term mb10">
                <span>WHERE</span><br>
                Сначала выбираются записи по условию, а затем могут быть сгруппированы, отсортированы и т.д. Это
                ограничивающее выражение.
                <br>Оно выполняется до того, как будет получен результат операции.
            </p>
            <p class="term mb10">
                <span>HAVING</span><br>
                Сначала группируются записи, а затем выбираются по условию, при этом, в отличие от
                WHERE, в нём можно использовать значения агрегатных функций
            </p>
            <p>
                Выражения WHERE используются вместе с операциями SELECT, UPDATE, DELETE, в то время как HAVING только с
                SELECT и предложением GROUP BY, т.е. использовать WHERE в запросах с агрегатными функциями нельзя,
                для этого и был введен HAVING.

            </p>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="order_by">
        <h3><a href="#add">Что такое ORDER BY?</a></h3>
        <div>
            <div class="code">
                <pre>SELECT поля_таблиц FROM список_таблиц
ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]];</pre>
            </div>
            <p>
                Правило сортировки применяется только к указанным столбцам.
                <br>Можно указать направление сортировки.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="group_by">
        <h3><a href="#add">Что такое GROUP BY?</a></h3>
        <div>
            <p>
                Иногда требуется узнать информацию не о самих объектах, а об определенных группах, которые они образуют.
                Для этого используется оператор GROUP BY и <a href="#aggregation">агрегатные функции</a>.
            </p>
            <div class="code">
                <pre>SELECT family_member, SUM(unit_price * amount) FROM Payments
GROUP BY family_member;</pre>
            </div>
            <p>
                При использовании GROUP BY все значения NULL считаются равными.
                <br>Агрегатные функции применяются для значений, не равных NULL.
                <br>Исключением является функция COUNT().
            </p>
            <p class="example">
                SUM(поле_таблицы) Возвращает сумму значений
                <br>AVG(поле_таблицы) Возвращает среднее значение
                <br>COUNT(поле_таблицы) Возвращает количество записей
                <br>MIN(поле_таблицы) Возвращает минимальное значение
                <br>MAX(поле_таблицы) Возвращает максимальное значение
            </p>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="distinct">
        <h3><a href="#add">Что такое DISTINCT?</a></h3>
        <div>
            <p>
                Оператор SQL DISTINCT используется для указания на то, что следует работать только с уникальными
                значениями столбца.
                <br>Может использоваться с агрегатными функциями.
            </p>
            <div class="code">
                <pre>SELECT COUNT(DISTINCT Singer)
AS CountOfSingers
FROM Artists</pre>
            </div>

        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="limit">
        <h3><a href="#add">Что такое LIMIT?</a></h3>
        <div>
            <div class="code">
                <pre>SELECT поля_выборки
FROM список_таблиц
LIMIT [количество_пропущенных_записей,] количество_записей_для_вывода;</pre>
            </div>
            <p>
                Когда необходимо сделать отступ от начала таблицы, предназначена конструкция OFFSET FETCH.
            </p>
            <p class="example no_mb">Для того, чтобы вывести строки с 3 по 5, нужно использовать такой запрос:</p>
            <div class="code">
                <pre>SELECT * FROM Company LIMIT 2, 3;</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <hr>
    <div id="exist">
        <h3><a href="#add">Что такое EXISTS?</a></h3>
        <div>
            <p>
                EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо
                записи и FALSE, если нет.
            </p>
            <div class="code">
                <pre>CREATE DATABASE IF NOT EXIST имя_базы_данных;
DROP DATABASE IF EXIST имя_базы_данных;</pre>
            </div>
            <p>
                Обычно предикат EXISTS используется в зависимых (коррелирующих) подзапросах. Этот вид подзапроса имеет
                внешнюю ссылку, связанную со значением в основном запросе. Результат подзапроса может зависеть от этого
                значения и должен оцениваться отдельно для каждой строки запроса, в котором содержится данный подзапрос.
                Поэтому предикат EXISTS может иметь разные значения для разных строк основного запроса.
            </p>
            <p class="example no_mb">
                Найти тех производителей портативных компьютеров, которые также производят принтеры:
            </p>
            <div class="code">
                <pre>SELECT DISTINCT maker
FROM Product AS l
WHERE l.type = 'laptop' AND
    NOT EXISTS (SELECT р.maker
                FROM Product r
                WHERE r.type = 'printer' AND r.maker = l.maker);</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#add"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="aggregation">
    <h1><a href="#">Aгрегатные функции</a></h1>
    <div>
        <p class="term mb10">
            <span>Агрегатных функции</span>
            -&nbsp;функции, которые берут группы значений и сводят их к одиночному значению.
        </p>
        <p>SQL предоставляет несколько агрегатных функций:</p>
        <table class="list list--dictionary" aria-label="aggregation">
            <thead>
            <tr>
                <th>Назавание</th>
                <th>Описание</th>
            <tr>
            </thead>
            <tr>
                <td>COUNT</td>
                <td>Производит подсчет записей, удовлетворяющих условию запроса.</td>
            </tr>
            <tr>
                <td>SUM</td>
                <td>Вычисляет арифметическую сумму всех значений колонки.</td>
            </tr>
            <tr>
                <td>AVG</td>
                <td>вычисляет среднее арифметическое всех значений.</td>
            </tr>
            <tr>
                <td>MAX</td>
                <td>Определяет наибольшее из всех выбранных значений.</td>
            </tr>
            <tr>
                <td>MIN</td>
                <td>Определяет наименьшее из всех выбранных значений.</td>
            </tr>
            <tr>
                <td>SUBSTRING</td>
                <td>Позволяет извлечь из выражения его часть заданной длины, начиная от заданной начальной позиции.</td>
            </tr>
            <tr>
                <td>STRING_AGG</td>
                <td>Конкатенирует строки.</td>
            </tr>
            <tr>
                <td>STRING_SPLIT</td>
                <td>
                    Выполняет операцию, обратную STRING_AGG. Она принимает на входе символьную строку и разбивает её на
                    подстроки по
                    заданному вторым параметром разделителю.
                </td>
            </tr>
            <tr>
                <td>LOWER</td>
                <td>Преобразуют все символы аргумента к нижнему.</td>
            </tr>
            <tr>
                <td>UPPER</td>
                <td>Преобразуют все символы аргумента верхнему регистру.</td>
            </tr>
        </table>
    </div>

    <hr>
    <div>
        <h3>В чем разница между COUNT(*) и COUNT(column)?</h3>
        <div>
            <p class="term mb10">
                <span>COUNT(*)</span><br>
                подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует
                записями, а не столбцами.
            </p>
            <p class="term mb10">
                <span> COUNT (column)</span><br>
                подсчитывает количество значений в column.
                При подсчете количества значений столбца эта форма функции
                COUNT не принимает во внимание значение NULL.
            </p>
        </div>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="constraints_keys">
    <h1><a href="#">Ограничения и Ключи</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#constraints">Ограничения (constraints)</a></li>
        <li><a href="#keys">Ключи</a></li>
        <li><a href="#primary_unique_diff">Какие отличия между ограничениями PRIMARY и UNIQUE?</a></li>
        <li><a href="#fk_null">Может FOREIGN KEY = NULL?</a></li>
        <li><a href="#surrogate">Что такое суррогатные ключи?</a></li>
    </ul>

    <div id="constraints">
        <h3><a href="#constraints_keys">Ограничения (constraints)</a></h3>
        <div>
            <p>
                При создании таблицы можно установить ограничение на значения которые могут быть в нее внесены.
            </p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>PRIMARY KEY</span><br>
                        набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для
                        однозначной идентификации записи в таблице.
                        <br>
                        Для таблицы может быть создано только одно такое ограничение.
                        <br>
                        Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.
                    </p>
                    <p class="main-mind">Первичные ключи не могут позволить значений NULL.</p>

                </li>
                <li>
                    <p class="term mb10">
                        <span>CHECK</span><br>
                        Позволяет установить свое условие, которому должно удовлетворять значение вводимое в таблицу,
                        прежде чем оно будет принято.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>UNIQUE</span><br>
                        Обеспечивает отсутствие дубликатов в столбце или наборе столбцов.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>FOREIGN KEY</span><br>
                        Защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице
                        указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было
                        записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY.
                    </p>
                </li>
            </ul>
            <div class="code">
                <pre>CREATE TABLE < table name >
        (< column name > < column constraint >,
        < column name > < data type > < column constraint > ...
        < table constraint > ( < column name >
        [, < column name > ])... );</pre>
            </div>
            <div class="code">
                <pre>[CONSTRAINT имя_ограничения]
FOREIGN KEY (столбец1, столбец2, ... столбецN)
REFERENCES главная_таблица (столбец_главной_таблицы1, столбец_главной_таблицы2, ... столбец_главной_таблицыN)
[ON DELETE действие]
[ON UPDATE действие]</pre>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#constraints_keys"></a>
    </div>

    <hr>
    <div id="keys">
        <h3><a href="#constraints_keys">Ключи</a></h3>
        <div>
            <p class="term mb10">
                <span>Простой ключ</span>
                состоит из одного атрибута (поля).
            </p>
            <p class="term mb10">
                <span>Составной ключ (composite)</span>
                -&nbsp;из двух и более.
            </p>
            <div class="mb10">
                <p class="term no_mb spoiler-string">
                    <span>Потенциальный ключ (candidate)</span>
                    -&nbsp;простой или составной ключ, который уникально идентифицирует каждую запись набора данных.
                    <br>
                    При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей
                    набор полей перестает уникально идентифицировать запись.</p>
                <div class="mb10 spoiler">
                    Термин "candidate" подразумевает, что все такие ключи
                    конкурируют за почётную роль "первичного ключа" (primary key), а оставшиеся назначаются
                    "альтернативными ключами" (alternate keys).
                    <br>
                    Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи
                    называют альтернативными.
                </div>
            </div>
            <div class="mb10">
                <p class="term no_mb spoiler-string">
                    <span>Первичный ключ (primary key)</span>
                    в реляционной модели данных один из потенциальных ключей отношения, выбранный в качестве основного
                    ключа (ключа по умолчанию).</p>
                <div class="spoiler">
                    <p class="mb10">
                        Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если
                        потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют
                        "альтернативными".
                        <br>
                        В качестве первичного обычно выбирается тот из потенциальных ключей, который наиболее удобен.
                        Поэтому в качестве первичного ключа, как правило, выбирают тот, который имеет наименьший размер
                        (физического хранения) и/или включает наименьшее количество атрибутов.
                        <br>
                        Другой критерий выбора первичного ключа - сохранение его уникальности со временем. Поэтому в
                        качестве первичного ключа стараются выбирать такой потенциальный ключ, который с наибольшей
                        вероятностью никогда не утратит уникальность.
                    </p>
                </div>
            </div>
            <div>
                <p class="term spoiler-string">
                    <span>Внешний ключ (foreign key)</span>
                    -&nbsp;это столбец (или несколько столбцов) в таблице базы данных, который используется для
                    установления
                    и обеспечения связи между данными в двух таблицах. Он ссылается на первичный ключ другой таблицы,
                    обеспечивая целостность и согласованность данных.</p>
                <div class="spoiler">
                    <p>
                        <span class="example">если по простому ни как, то определение по-умному</span><br>
                        -&nbsp;это подмножество атрибутов некоторого отношения A, значения которых должны совпадать со
                        значениями некоторого потенциального ключа некоторого отношения B.
                    </p>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#constraints_keys"></a>
    </div>

    <hr>
    <div id="primary_unique_diff">
        <h3><a href="#constraints_keys">Какие отличия между ограничениями PRIMARY и UNIQUE?</a></h3>
        <div>
            <p class="no_mb">
                По умолчанию ограничение PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный*.
                <br>
                Другим отличием является то, что PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну
                (а в некоторых СУБД несколько) NULL запись.
            </p>
            <p class="example term mb10">
                <span>* Кластерный индекс</span>
                -&nbsp;это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им
                соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в
                таблицу, она дописывается не в конец файла, не в конец плоского списка, а в нужную ветку древовидной
                структуры, соответствующую ей по сортировке.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#constraints_keys"></a>
    </div>

    <hr>
    <div id="fk_null">
        <h3>
            <a href="#constraints_keys">
                Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?
            </a>
        </h3>
        <div>
            <p>Может, если на данный столбец не наложено ограничение NOT NULL.</p>
        </div>
        <a class="button button--to_content_menu" href="#constraints_keys"></a>
    </div>

    <hr>
    <div id="surrogate">
        <h3><a href="#constraints_keys">Что такое суррогатные ключи?</a></h3>
        <div>
            <p class="term mb10">
                <span>Суррогатный ключ</span>
                -&nbsp;понятие теории реляционных баз данных. Это дополнительное служебное поле, добавленное к
                уже имеющимся информационным полям таблицы, единственное предназначение которого — служить первичным
                ключом.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#constraints_keys"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="indexes">

    <h1><a href="#">Индексы</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#index">Определение</a></li>
        <li>
            <p class="mb10">
                <a href="#index_type">Типы индексов</a>
                <span class="submenu-button"></span>
            </p>
            <ul class="menu no-display">
                <li><a href="#by_order">По порядку сортировки</a></li>
                <li><a href="#by_sourse">По источнику данных</a></li>
                <li><a href="#by_impact">По воздействию на источник данных</a></li>
                <li><a href="#by_structure">По структуре</a></li>
                <li><a href="#by_volume">По количественному составу</a></li>
                <li><a href="#by_content">По характеристике содержимого</a></li>
                <li><a href="#by_update">По механизму обновления</a></li>
                <li><a href="#by_coverage">По покрытию индексируемого содержимого</a></li>
                <li><a href="#index_cluster_system">Индексы в кластерных системах</a></li>
            </ul>
        </li>
        <li><a href=""></a></li>
        <li><a href="#index_cluster_diff">В чем отличие между кластерными и некластерными индексами?</a></li>
        <li><a href="#index_not_selective">
            Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?
        </a></li>
        <li><a href="#index_full_scan">Когда полное сканирование набора данных выгоднее доступа по индексу?</a></li>
        <li><a href="#index_create">Как создать индекс?</a></li>
    </ul>

    <div id="index">
        <h3><a href="#indexes">Определение</a></h3>
        <div>
            <p class="term mb10"><span>Индекс (index)</span>
                -&nbsp;объект базы данных, создаваемый с целью повышения производительности выборки данных.</p>
            <p>Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их
                поиск по заданному критерию путем последовательного просмотра набора данных запись за записью может
                занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на
                соответствующие записи набора данных, т.о. достигается значительный прирост скорости выборки этих
                данных. </p>

            <p class="bold no_mb">Преимущества</p>
            <ul>
                <li>ускорение поиска и сортировки по определенному полю или набору полей.</li>
                <li>обеспечение уникальности данных.</li>
            </ul>

            <p class="bold no_mb">Недостатки</p>
            <ul>
                <li>
                    требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем
                    больше размер индекса.
                </li>
                <li>
                    замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять
                    сами
                    индексы.
                </li>
            </ul>

            <p class="bold no_mb">Индексы предпочтительней для:</p>
            <ul>
                <li>Поля-счетчика, чтобы, в том числе, избежать и повторения значений в этом поле.</li>
                <li>Поля, по которому проводится сортировка данных.</li>
                <li>
                    Полей, по которым часто проводится соединение наборов данных.
                    <p class="example">
                        Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение
                        происходит значительно быстрее.</p>
                </li>
                <li>Поля, которое объявлено первичным ключом (primary key).</li>
                <li>
                    Поля, в котором данные выбираются из некоторого диапазона.
                    <p class="example">
                        В этом случае как только будет найдена первая запись с нужным значением, все последующие
                        значения будут расположены рядом.</p>
                </li>
            </ul>

            <p class="bold no_mb">Использование индексов нецелесообразно для:</p>
            <ul>
                <li>Полей, которые редко используются в запросах;</li>
                <li>
                    Полей, которые содержат всего два или три значения, например: мужской, женский пол или значения
                    "да", "нет".
                    <p class="example">Так называемые низкоселективные поля.</p>
                </li>
            </ul>

        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>

    <hr>
    <div id="index_type">
        <h3><a href="#indexes">Типы индексов</a></h3>
        <div>
            <ul>
                <li id="by_order">
                    <h4 class="spoiler-string">По порядку сортировки:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>упорядоченные</span> -&nbsp;индексы, в которых элементы упорядочены
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_sourse">
                    <h4 class="spoiler-string">По источнику данных:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>индексы по представлению (view)</li>
                            <li>индексы по выражениям</li>
                        </ul>
                    </div>
                </li>
                <li id="by_impact">
                    <h4 class="spoiler-string">По воздействию на источник данных:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term">
                                    <span>кластерный индекс</span>
                                    -&nbsp;при определении в наборе данных физическое расположение данных
                                    перестраивается в соответствии со структурой индекса.
                                </p>
                                <p class="example mb10">
                                    Логическая структура набора данных в этом случае представляет собой скорее словарь,
                                    чем индекс. Данные в словаре физически упорядочены, например по алфавиту.
                                    <br>
                                    Кластерные индексы могут дать существенное увеличение производительности поиска
                                    данных даже по сравнению с обычными индексами. Увеличение производительности
                                    особенно заметно при работе с последовательными данными.</p>
                            </li>
                            <li>
                                <p class="term">
                                    <span>некластерный индекс</span>
                                    -&nbsp;наиболее типичные представители семейства индексов. В отличие от кластерных,
                                    они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на
                                    соответствующие записи.
                                </p>
                                <p class="example mb10">
                                    Для идентификации нужной записи в наборе данных некластерный индекс организует
                                    специальные указатели, включающие в себя:
                                    <br>-&nbsp;информацию об идентификационном номере файла, в котором хранится запись;
                                    <br>-&nbsp;идентификационный номер страницы соответствующих данных;
                                    <br>-&nbsp;номер искомой записи на соответствующей странице;
                                    <br>-&nbsp;содержимое столбца.</p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_structure">
                    <h4 class="spoiler-string">По структуре:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="bold">B-деревья</p>
                                <p class="example mb10">
                                    -&nbsp;Стандартная структура данных для индексов, которая поддерживает
                                    отсортированное хранение данных и обеспечивает быструю вставку, удаление и поиск.
                                    <br>
                                    -&nbsp;B-дерево сбалансировано, что означает, что все листья находятся на одном
                                    уровне, и операции поддерживаются за логарифмическое время.</p>
                            </li>
                            <li>
                                <p class="bold">B+-деревья</p>
                                <p class="example mb10">
                                    -&nbsp;Усовершенствованная версия B-дерева.
                                    <br>
                                    -&nbsp;Все значения данных хранятся только в листьях, тогда как внутренние узлы
                                    содержат только индексы и используются для навигации.
                                    <br>
                                    -&nbsp;Это позволяет быстрее выполнять последовательное считывание данных.</p>
                            </li>
                            <li>
                                <p class="bold">B*-деревья</p>
                                <p class="example mb10">
                                    -&nbsp;Дальнейшее развитие концепции B+-деревьев, которые используют более плотное
                                    заполнение узлов.
                                    <br>
                                    -&nbsp;Более высокая плотность заполнения узлов снижает высоту дерева, что может
                                    привести к увеличению эффективности операций поиска за счет уменьшения количества
                                    операций доступа к диску.</p>
                            </li>
                            <li>
                                <p class="bold">Хэш-индексы</p>
                                <p class="example mb10">
                                    -&nbsp;Используют хеш-функции для организации данных. Хеширование позволяет быстрее
                                    находить записи по точному совпадению ключа.
                                    <br>
                                    -&nbsp;Подходят для операций точного поиска, но неэффективны для последовательного
                                    доступа или поиска диапазонов, поскольку данные в хеш-таблице не упорядочены.</p>

                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_volume">
                    <h4 class="spoiler-string">По количественному составу:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>простой индекс (индекс с одним ключом)</span>
                                    -&nbsp;строится по одному полю.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>составной (многоключевой, композитный) индекс</span>
                                    -&nbsp;строится по нескольким полям при этом важен порядок их следования.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>индекс с включенными столбцами</span>
                                    -&nbsp;некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов
                                    еще и неключевые.
                                </p>
                            </li>
                            <li>
                                <p class="term">
                                    <span>главный индекс (индекс по первичному ключу)</span>
                                    -&nbsp;это тот индексный ключ, под управлением которого в данный момент находится
                                    набор данных.
                                </p>
                                <p class="main-mind no_mb">
                                    Набор данных не может быть отсортирован по нескольким индексным ключам
                                    одновременно.</p>
                                <p class="example mb10">
                                    Хотя, если один и тот же набор данных открыт одновременно в нескольких рабочих
                                    областях, то у каждой копии набора данных может быть назначен свой главный
                                    индекс.</p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_content">
                    <h4 class="spoiler-string">По характеристике содержимого:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>уникальный индекс</span> состоит из множества уникальных значений поля.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>плотный индекс (NoSQL)</span>
                                    -&nbsp;индекс, при котором, каждом документе в индексируемой коллекции соответствует
                                    запись в индексе, даже если в документе нет индексируемого поля.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>разреженный индекс (NoSQL)</span>
                                    -&nbsp;тот, в котором представлены только те документы, для которых индексируемый
                                    ключ имеет какое-то определённое значение (существует).
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>пространственный индекс</span>
                                    -&nbsp;оптимизирован для описания географического местоположения. Представляет из
                                    себя многоключевой индекс состоящий из широты и долготы.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>составной пространственный индекс</span>
                                    -&nbsp;индекс, включающий в себя кроме широты и долготы ещё какие-либо
                                    мета-данные (например теги). Но географические координаты должны стоять на первом
                                    месте.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>полнотекстовый (инвертированный) индекс</span>
                                    -&nbsp;словарь, в котором перечислены все слова и указано, в каких
                                    местах они встречаются. При наличии такого индекса достаточно осуществить поиск
                                    нужных слов в нём и тогда сразу же будет получен список документов, в которых они
                                    встречаются.
                                </p>
                            </li>
                            <li>
                                <p class="term">
                                    <span>хэш-индекс</span>
                                    -&nbsp;предполагает хранение не самих значений, а их хэшей, благодаря чему
                                    уменьшается размер (а, соответственно, и увеличивается скорость их обработки)
                                    индексов из больших полей.
                                </p>
                                <p class="example mb10">
                                    Т.о., при запросах с использованием хэш-индексов, сравниваться будут не искомое со
                                    значения поля, а хэш от искомого значения с хэшами полей. Из-за нелинейности
                                    хэш-функций данный индекс нельзя сортировать по значению, что приводит к
                                    невозможности использования в сравнениях больше/меньше и "is null".
                                    <br>Кроме того, так как хэши не уникальны, то для
                                    совпадающих хэшей применяются методы разрешения коллизий.</p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>битовый индекс (bitmap index)</span>
                                    -&nbsp;метод битовых индексов заключается в создании отдельных битовых карт
                                    (последовательностей 0 и 1) для каждого возможного значения столбца, где каждому
                                    биту соответствует запись с индексируемым значением, а его значение равное 1
                                    означает, что запись, соответствующая позиции бита содержит
                                    индексируемое значение для данного столбца или свойства.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>обратный индекс (reverse index)</span>
                                    -&nbsp;B-tree индекс, но с реверсированным ключом, используемый в основном для
                                    монотонно возрастающих значений (например, автоинкрементный идентификатор) в OLTP
                                    системах с целью снятия конкуренции за последний листовой блок индекса, т.к.
                                    благодаря переворачиванию значения две соседние записи индекса попадают в разные
                                    блоки индекса.
                                    <br>Он не может использоваться для диапазонного поиска.
                                </p>
                            </li>
                            <li>
                                <p class="term">
                                    <span>функциональный индекс, индекс по вычисляемому полю (function-based index)</span>
                                    -&nbsp;индекс, ключи которого хранят результат пользовательских функций.
                                    Функциональные индексы часто строятся для полей, значения которых проходят
                                    предварительную обработку перед сравнением в команде SQL.
                                </p>
                                <p class="example mb10">
                                    Например, при сравнении строковых данных без учета регистра символов часто
                                    используется функция UPPER.
                                    <br>
                                    Кроме того, функциональный индекс может помочь реализовать любой другой
                                    отсутствующий тип индексов данной СУБД.</p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>первичный индекс</span> -&nbsp;уникальный индекс по полю первичного ключа.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>вторичный индекс</span>
                                    -&nbsp;индекс по другим полям (кроме поля первичного ключа).
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>XML-индекс</span>
                                    -&nbsp;вырезанное материализованное представление больших двоичных XML-объектов
                                    (BLOB) в столбце с типом данных xml.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_update">
                    <h4 class="spoiler-string">По механизму обновления:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>полностью перестраиваемый</span>
                                    -&nbsp;при добавлении элемента заново перестраивается весь индекс.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>пополняемый (балансируемый)</span>
                                    -&nbsp;при добавлении элементов индекс перестраивается частично
                                    (например, одна из ветви) и периодически балансируется.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="by_coverage">
                    <h4 class="spoiler-string">По покрытию индексируемого содержимого:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>полностью покрывающий (полный) индекс</span>
                                    -&nbsp;покрывает всё содержимое индексируемого объекта.</p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>частичный индекс (partial index)</span>
                                    -&nbsp;это индекс, построенный на части набора данных, удовлетворяющей
                                    определенному условию самого индекса.
                                    <br>Данный индекс создан для уменьшения размера индекса.</p>
                            </li>
                            <li>
                                <p class="term">
                                    <span>инкрементный (delta) индекс</span>
                                    -&nbsp;индексируется малая часть данных(дельта), как правило, по истечении
                                    определенного времени.
                                    <br>Используется при интенсивной записи. </p>
                                <p class="example">
                                    Например, полный индекс перестраивается раз в сутки, а дельта-индекс строится каждый
                                    час. По сути это частичный индекс по временной метке.</p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>индекс реального времени (real-time index)</span>
                                    -&nbsp;особый вид инкрементного индекса, характеризующийся высокой
                                    скоростью построения.
                                    <br>Предназначен для часто меняющихся данных.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li id="index_cluster_system">
                    <h4 class="spoiler-string">Индексы в кластерных системах:</h4>
                    <div class="spoiler">
                        <ul>
                            <li>
                                <p class="term mb10">
                                    <span>глобальный индекс</span>
                                    -&nbsp;индекс по всему содержимому всех сегментов БД (shard).
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>сегментный индекс</span>
                                    глобальный индекс по полю-сегментируемому ключу (shard key).
                                    <br>
                                    Используется для быстрого определения сегмента, на котором хранятся данные в
                                    процессе маршрутизации запроса в кластере БД.
                                </p>
                            </li>
                            <li>
                                <p class="term mb10">
                                    <span>локальный индекс</span>
                                    -&nbsp;индекс по содержимому только одного сегмента БД.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
            </ul>
        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>

    <hr>
    <div id="index_cluster_diff">
        <h3><a href="#indexes">В чем отличие между кластерными и некластерными индексами?</a></h3>
        <div>
            <p class="term mb10">
                <span>Некластерные индексы</span>
                -&nbsp;данные физически расположены в произвольном порядке, но логически упорядочены
                согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.
            </p>
            <p class="term mb10">
                При <span>кластерном индексировании</span>
                данные физически упорядочены, что серьезно повышает скорость выборок данных
                (но только в случае последовательного доступа к данным).
            </p>
            <p class="main-mind">Для одного набора данных может быть создан только один кластерный индекс.</p>
        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>

    <hr>
    <div id="index_not_selective">
        <h3><a href="#indexes">Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?</a>
        </h3>
        <div>
            <p>Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в
                байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию
                выборки, то в общем случае оптимизация приведет к замедлению выборки.</p>
        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>

    <hr>
    <div id="index_full_scan">
        <h3><a href="#indexes">Когда полное сканирование набора данных выгоднее доступа по индексу?</a></h3>
        <div>
            <p>
                Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным.
                Также (и очень важно), при доступе по индексу сначала идет сканирование самого индекса, а затем чтение
                блоков из набора данных.
                <br>
                Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная
                стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным
                чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.
                <br>
                Т.о., полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой
                кластеризации данных, либо в случае очень маленьких наборов данных.</p>
        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>

    <hr>
    <div id="index_create">
        <h3><a href="#indexes">Как создать индекс?</a></h3>
        <div>
            <p class="term">Индекс можно создать либо с помощью выражения <span>CREATE INDEX</span>:</p>
            <div class="code">CREATE INDEX index_name ON table_name (column_name)</div>
            <p class="term">
                Либо указав ограничение целостности в виде уникального
                <span>UNIQUE</span>
                или первичного
                <span>PRIMARY</span>
                ключа в операторе создания таблицы CREATE TABLE.</p>
        </div>
        <a class="button button--to_content_menu" href="#indexes"></a>
    </div>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="replication-sharding">
    <h1><a href="#">Репликация и шардирование</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#replication">Репликация</a></li>
        <li><a href="#sharding">Шардирование</a></li>
    </ul>

    <div id="replication">
        <h3><a href="#replication-sharding">Репликация</a></h3>
        <div>
            <p class="term mb10">
                <span>Реплицирование</span>
                -&nbsp;это процесс создания и поддержания копий данных на нескольких серверах или узлах в
                системе.
            </p>
            <p class="term mb10">
                <span>Основная цель репликации</span>
                -&nbsp;обеспечить отказоустойчивость, повысить доступность данных и
                улучшить производительность системы.
            </p>
            <p class="mb10">
                При репликации одни и те же данные хранятся в нескольких местах, что позволяет системе
                оставаться функциональной даже при выходе из строя одного или нескольких узлов.
            </p>

            <p class="mb10">Существует несколько моделей репликации:</p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>Синхронная репликация:</span><br>
                        при внесении изменений в данные на одном узле эти изменения сразу же
                        применяются ко всем копиям данных на других узлах.
                        <br>Это гарантирует, что все копии данных остаются консистентными, но может увеличить
                        задержки при операциях записи из-за необходимости дожидаться подтверждения от всех
                        узлов.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Асинхронная репликация:</span><br>
                        изменения на основном узле передаются на реплики с задержкой.
                        <br>Это может улучшить производительность, так как узел не должен ждать подтверждения от
                        реплик при записи, но есть риск того, что данные на репликах временно могут быть
                        неактуальными.
                    </p>
                </li>
            </ul>

            <p class="mb10">Репликация помогает обеспечить:</p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>Отказоустойчивость:</span><br>
                        если один сервер выходит из строя, данные могут быть доступны с другой реплики.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Доступность:</span><br>
                        при высокой нагрузке запросы могут распределяться между разными репликами, что
                        снижает нагрузку на каждый отдельный узел.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Географическое распределение данных:</span><br>
                        хранение реплик данных в разных географических локациях
                        позволяет пользователям получать доступ к данным с меньшими задержками.
                    </p>
                </li>
            </ul>

            <p class="main-mind">
                Добавление механизма репликации делает систему более сложной с точки
                зрения управления консистентностью данных, особенно в случае асинхронной репликации.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#replication-sharding"></a>
    </div>

    <hr>
    <div id="sharding">
        <h3><a href="#replication-sharding">Шардирование</a></h3>
        <p class="term mb10">
            <span>Шардирование</span> (от англ. "sharding")
            -&nbsp;это метод разделения базы данных или другой системы на более мелкие, управляемые части,
            которые называются "шардами" (shards).
            Каждая шарда — это подмножество данных, которое может быть размещено и обработано отдельно,
            обычно на разных серверах или узлах.
        </p>
        <p class="term mb10">
            <span>Цель шардирования</span>
            -&nbsp;улучшить производительность и масштабируемость системы.
            Оно позволяет распределить нагрузку на несколько серверов, что в свою очередь может сделать
            систему
            более устойчивой к отказам. Если компактно выражаться, шардирование помогает обрабатывать
            большие
            объемы данных более эффективно, обеспечивая параллельную обработку запросов.
            Часто шардирование применяют в распределённых системах и масштабируемых веб-приложениях, где
            требуется обработка больших объёмов данных с высокой скоростью.
        </p>
        <p class="mb10">Основные принципы шардирования:</p>
        <ol class="tab-2">
            <li>
                <p class="term mb10">
                    <span>Чёткое определение логики разделения данных:</span><br>
                    нужно четко решить по какому критерию данные будут
                    распределены между шардамию
                    (например, по какому-то идентификатору, временному интервалу и т.д.).
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Изоляция:</span><br>
                    каждая шарда автономна и может работать независимо от других, хотя данные в шардах
                    часто всё равно нуждаются в согласованности.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Горизонтальное масштабирование:</span><br>
                    добавление нового шарда позволяет увеличить ёмкость системы без
                    значительных изменений в архитектуре.
                </p>
            </li>
        </ol>
        <a class="button button--to_content_menu" href="#replication-sharding"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>

</section>

<section class="container" id="normal_form">
    <h1><a href="#">Нормализация и нормальные формы</a></h1>
    <ul class="after-h1 menu">
        <li><a href="#normalization">Нормализация</a></li>
        <li><a href="#nf_about">Нормальные формы</a></li>
        <li><a href="#1nf">Первая нормальная форма (1NF)</a></li>
        <li><a href="#2nf">Вторая нормальная форма (2NF)</a></li>
        <li><a href="#3nf">Третья нормальная форма (3NF)</a></li>
        <li><a href="#bcnf">Нормальная форма Бойса-Кодда (BCNF)</a></li>
        <li><a href="#4nf">Четвёртая нормальная форма (4NF)</a></li>
        <li><a href="#5nf">Пятая нормальная форма (5NF)</a></li>
        <li><a href="#dknf">Доменно-ключевая нормальная форма (DKNF)</a></li>
        <li><a href="#6nf">Шестая нормальная форма (6NF)</a></li>
    </ul>

    <div id="normalization">
        <h3><a href="#normal_form">Нормализация</a></h3>
        <div>
            <p class="term mb10">
                <span>Нормализация</span>
                -&nbsp;это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам
                (пошаговый,
                обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и
                логичную структуру).
            </p>
            <p class="main-mind">Нормализация – это и есть здравый смысл в проектировании БД.</p>
            <p class="term mb10">
                <span>Цель нормализации:</span>
                исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении,
                редактировании и удалении кортежей (строк таблицы).
            </p>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="nf_about">
        <h3><a href="#normal_form">Нормальные формы</a></h3>
        <ul>
            <li>
                <p class="term mb10">
                    <span>Первая нормальная форма (1NF)</span><br>
                    Отношение находится в 1NF, если значения всех его атрибутов атомарны (неделимы).
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Вторая нормальная форма (2NF)</span><br>
                    Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят
                    только от ключа целиком, а не от какой-то его части.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Третья нормальная форма (3NF)</span><br>
                    Отношение находится в 3NF, если оно находится в 2NF
                    и все неключевые атрибуты не зависят друг от друга.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Четвёртая нормальная форма (4NF)</span><br>
                    Отношение находится в 4NF, если оно находится в 3NF и если в нем не
                    содержатся независимые группы атрибутов, между которыми существует отношение "многие-ко-многим".
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Пятая нормальная форма (5NF)</span><br>
                    Отношение находится в 5NF, когда каждая нетривиальная зависимость
                    соединения в ней определяется потенциальным ключом (ключами) этого отношения.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Шестая нормальная форма (6NF)</span><br>
                    Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным
                    зависимостям соединения, т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей
                    декомпозиции без потерь. Каждая переменная отношения, которая находится в 6NF, также находится и в
                    5NF. Введена как обобщение пятой нормальной формы для хронологической базы данных.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)</span><br>
                    Отношение находится в BCNF, когда каждая её нетривиальная и неприводимая слева функциональная
                    зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
                </p>
            </li>
            <li>
                <p class="term mb10">
                    <span>Доменно-ключевая нормальная форма (DKNF)</span><br>
                    Отношение находится в DKNF, когда каждое наложенное на нее
                    ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на
                    данное отношение.
                </p>
            </li>
        </ul>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="1nf">
        <h3><a href="#normal_form">Первая нормальная форма</a></h3>
        <div>
            <p>
                Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны
                содержать только скалярные значения (может быть выражено одним, как правило, действительным числом). Не
                должно быть повторений строк в таблице.
            </p>
            <div>
                <p class="spoiler-string">Пример:</p>
                <div class="spoiler">
                    <p>Например, есть таблица "Автомобили":</p>
                    <table class="list list--compact" aria-label="no_1nf">
                        <thead>
                        <tr>
                            <th>Производитель</th>
                            <th>Модель</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>BMW</td>
                            <td>M5, X5M, M1</td>
                        </tr>
                        <tr>
                            <td>NISSAN</td>
                            <td>GT-R</td>
                        </tr>
                    </table>
                    <p>
                        Нарушение нормализации 1НФ происходит в моделях BMW,
                        т.к. в одной ячейке содержится список из 3 элементов: M5, X5M, M1, т.е. он не является
                        атомарным.
                    </p>
                    <p>Преобразуем таблицу к 1НФ (в одной ячейке – одно значение):</p>
                    <table class="list list--compact" aria-label="no_1nf">
                        <thead>
                        <tr>
                            <th>Производитель</th>
                            <th>Модель</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>BMW</td>
                            <td>M5</td>
                        </tr>
                        <tr>
                            <td>BMW</td>
                            <td>X5M</td>
                        </tr>
                        <tr>
                            <td>BMW</td>
                            <td>M1</td>
                        </tr>
                        <tr>
                            <td>NISSAN</td>
                            <td>GT-R</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="2nf">
        <h3><a href="#normal_form">Вторая нормальная форма</a></h3>
        <div>
            <p class="no_mb">
                Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от
                Первичного Ключа(ПК).
                <br>
                Неприводимость означает, что в составе потенциального ключа отсутствует меньшее
                подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.
            </p>
            <p class="example">Короче, прослеживается 2 зависимости из которых можно выделить 2-ю таблицу.</p>
            <div>
                <p class="spoiler-string">Пример:</p>
                <div class="spoiler">
                    <p>Дана таблица</p>
                    <table class="list list--compact" aria-label="2nf_data">
                        <thead>
                        <tr>
                            <th>Модель</th>
                            <th>Производитель</th>
                            <th>Цена</th>
                            <th>Скидка</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>M5</td>
                            <td>BMW</td>
                            <td>5500000</td>
                            <td>5%</td>
                        </tr>
                        <tr>
                            <td>X5M</td>
                            <td>BMW</td>
                            <td>6000000</td>
                            <td>5%</td>
                        </tr>
                        <tr>
                            <td>M1</td>
                            <td>BMW</td>
                            <td>2500000</td>
                            <td>5%</td>
                        </tr>
                        <tr>
                            <td>GT-R</td>
                            <td>NISSAN</td>
                            <td>5000000</td>
                            <td>10%</td>
                        </tr>
                    </table>
                    <p>
                        Таблица находится в первой нормальной форме, но не во второй.
                        <br>-&nbsp;Цена машины зависит от модели и производителя.
                        <br>-&nbsp;Скидка зависят от производителя
                        <br>То есть зависимость от первичного ключа неполная.
                    </p>
                    <p>
                        Исправляется это путем декомпозиции на два отношения, в которых не ключевые атрибуты зависят
                        от первичного ключа.
                    </p>
                    <table class="list list--compact" aria-label="2nf_data">
                        <thead>
                        <tr>
                            <th>Модель</th>
                            <th>Производитель</th>
                            <th>Цена</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>M5</td>
                            <td>BMW</td>
                            <td>5500000</td>
                        </tr>
                        <tr>
                            <td>X5M</td>
                            <td>BMW</td>
                            <td>6000000</td>
                        </tr>
                        <tr>
                            <td>M1</td>
                            <td>BMW</td>
                            <td>2500000</td>
                        </tr>
                        <tr>
                            <td>GT-R</td>
                            <td>NISSAN</td>
                            <td>5000000</td>
                        </tr>
                    </table>
                    <table class="list list--compact" aria-label="">
                        <thead>
                        <tr>
                            <th>Производитель</th>
                            <th>Скидка</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>BMW</td>
                            <td>5%</td>
                        </tr>
                        <tr>
                            <td>NISSAN</td>
                            <td>10%</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="3nf">
        <h3><a href="#normal_form">Третья нормальная форма</a></h3>
        <div>
            <p>
                Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от
                первичного ключа.
            </p>
            <p>
                Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых
                может относиться к нескольким записям таблицы в отдельные таблицы.
            </p>
            <div>
                <p class="spoiler-string">Пример:</p>
                <div class="spoiler">
                    <p>Есть таблица</p>
                    <table class="list list--compact" aria-label="3nf_data">
                        <thead>
                        <tr>
                            <th>Модель</th>
                            <th>Салон</th>
                            <th>Телефон</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>BMW</td>
                            <td>Риал-Авто</td>
                            <td>12-34-56</td>
                        </tr>
                        <tr>
                            <td>AUDI</td>
                            <td>Риал-Авто</td>
                            <td>12-34-56</td>
                        </tr>
                        <tr>
                            <td>NISSAN</td>
                            <td>Некст-Авто</td>
                            <td>98-76-54</td>
                        </tr>
                    </table>
                    <p>
                        Таблица находится во 2НФ, но не в 3НФ.
                    </p>
                    <p>
                        В отношении атрибут "Модель" является первичным ключом.
                    </p>
                    <p>
                        Личных телефонов у автомобилей нет, и телефон зависит исключительно от магазина.
                    </p>
                    <p>
                        Т.o., в отношении существуют следующие функциональные зависимости:
                        <br>Модель->Салон, Салон->Телефон, Модель->Телефон.
                        <br>Зависимость Модель->Телефон является
                        транзитивной, следовательно,
                        отношение не находится в 3НФ.
                    </p>
                    <p>
                        В результате разделения исходного отношения получаются два отношения, находящиеся в 3НФ:
                    </p>
                    <table class="list list--compact" aria-label="">
                        <thead>
                        <tr>
                            <th>Салон</th>
                            <th>Телефон</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>Риал-Авто</td>
                            <td>12-34-56</td>
                        </tr>
                        <tr>
                            <td>Некст-Авто</td>
                            <td>98-76-54</td>
                        </tr>
                    </table>
                    <table class="list list--compact" aria-label="">
                        <thead>
                        <tr>
                            <th>Модель</th>
                            <th>Салон</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>BMW</td>
                            <td>Риал-Авто</td>
                        </tr>
                        <tr>
                            <td>AUDI</td>
                            <td>Риал-Авто</td>
                        </tr>
                        <tr>
                            <td>NISSAN</td>
                            <td>Некст-Авто</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="bcnf">
        <h3><a href="#normal_form">Нормальная форма Бойса-Кодда</a></h3>
        <div>
            <p class="main-mind">Частная форма третьей нормальной формы</p>
            <p>Определение 3НФ не совсем подходит для следующих отношений:</p>
            <ol>
                <li>Отношение имеет два или более потенциальных ключа;</li>
                <li>Два и более потенциальных ключа являются составными;</li>
                <li>Они пересекаются, т.е. имеют хотя бы один общий атрибут.</li>
            </ol>
            <p>
                Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ. Отношение находится в
                НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным
                ключом в качестве детерминанта.
            </p>
            <p>Предположим, рассматривается отношение, представляющее данные о бронировании стоянки на день:</p>
            <table class="list list--compact" aria-label="bcnf_data">
                <thead>
                <tr>
                    <th>Номер стоянки</th>
                    <th>Время начала</th>
                    <th>Время окончания</th>
                    <th>Тариф</th>
                <tr>
                </thead>
                <tr>
                    <td>1</td>
                    <td>09:30</td>
                    <td>10:30</td>
                    <td>Бережливый</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>11:00</td>
                    <td>12:00</td>
                    <td>Бережливый</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>14:00</td>
                    <td>15:30</td>
                    <td>Стандарт</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>10:00</td>
                    <td>12:00</td>
                    <td>Премиум-В</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>12:00</td>
                    <td>14:00</td>
                    <td>Премиум-В</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>15:00</td>
                    <td>15:80</td>
                    <td>Премиум-А</td>
                </tr>
            </table>
            <p>
                Тариф имеет уникальное название и зависит от выбранной стоянки и наличии льгот, в частности:
            </p>
            <ul>
                <li>
                    <p class="term mb10">
                        <span>Бережливый</span>
                        -&nbsp;стоянка 1 для льготников.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Стандарт</span>
                        -&nbsp;стоянка 1 для не льготников.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Премиум-А</span>
                        стоянка 2 для льготников.
                    </p>
                </li>
                <li>
                    <p class="term mb10">
                        <span>Премиум-B</span>
                        стоянка 2 для не льготников.
                    </p>
                </li>
            </ul>
            <p class="no_mb">Таким образом, возможны следующие составные первичные ключи:</p>
            <p class="bold">
                [Номер стоянки, Время начала],
                <br>[Номер стоянки, Время окончания],
                <br>[Тариф, Время начала],
                <br>[Тариф, Время окончания].
            </p>
            <p>
                Отношение находится в 3НФ.
                <br>Требования второй нормальной формы выполняются, так как все атрибуты входят в
                какой-то из потенциальных ключей, а неключевых атрибутов в отношении нет.
                <br>Также нет и транзитивных зависимостей, что соответствует требованиям третьей нормальной формы.
                <br>Тем не менее, существует функциональная зависимость Тариф->Номер стоянки, в которой левая часть
                (детерминант) не является
                потенциальным ключом отношения, то есть отношение не находится в нормальной форме Бойса — Кодда.
            </p>
            <p>
                Недостатком данной структуры является то, что, например, по ошибке можно приписать тариф "Бережливый" к
                бронированию второй стоянки, хотя он может относиться только к первой стоянки.
            </p>
            <p>
                Можно улучшить структуру с помощью декомпозиции отношения на два и добавления атрибута "Имеет льготы",
                получив отношения, удовлетворяющие НФБК:
            </p>
            <p class="bold no_mb">Тарифы</p>
            <table class="list list--compact" aria-label="">
                <thead>
                <tr>
                    <th>Тариф</th>
                    <th>Номер стоянки</th>
                    <th>Имеет льготы</th>
                <tr>
                </thead>
                <tr>
                    <td>Бережливый</td>
                    <td>1</td>
                    <td>Да</td>
                </tr>
                <tr>
                    <td>Стандарт</td>
                    <td>1</td>
                    <td>Нет</td>
                </tr>
                <tr>
                    <td>Премиум-А</td>
                    <td>2</td>
                    <td>Да</td>
                </tr>
                <tr>
                    <td>Премиум-В</td>
                    <td>2</td>
                    <td>Нет</td>
                </tr>
            </table>
            <p class="bold no_mb">Бронирование</p>
            <table class="list list--compact" aria-label="">
                <thead>
                <tr>
                    <th>Тариф</th>
                    <th>Время начала</th>
                    <th>Время окончания</th>
                <tr>
                </thead>
                <tr>
                    <td>Бережливый</td>
                    <td>09:30</td>
                    <td>10:30</td>
                </tr>
                <tr>
                    <td>Бережливый</td>
                    <td>11:00</td>
                    <td>12:00</td>
                </tr>
                <tr>
                    <td>Стандарт</td>
                    <td>14:00</td>
                    <td>15:00</td>
                </tr>
                <tr>
                    <td>Премиум-В</td>
                    <td>10:00</td>
                    <td>12:00</td>
                </tr>
                <tr>
                    <td>Премиум-В</td>
                    <td>12:00</td>
                    <td>14:00</td>
                </tr>
                <tr>
                    <td>Премиум-А</td>
                    <td>15:00</td>
                    <td>18:00</td>
                </tr>
            </table>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="4nf">
        <h3><a href="#normal_form">Четвертая нормальная форма</a></h3>
        <div>
            <p>
                Отношение находится в 4НФ, если оно находится в НФБК и все нетривиальные многозначные зависимости
                фактически являются функциональными зависимостями от ее потенциальных ключей.
            </p>
            <p>
                В отношении R (A, B, C) существует многозначная зависимость R.A -> -> R.B в том и только в том случае,
                если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С.
            </p>
            <p class="term">
                Предположим, что рестораны производят разные виды пиццы, а службы доставки ресторанов работают только в
                определенных районах города. Составной первичный ключ соответствующей переменной отношения включает три
                атрибута: <span>[Ресторан, Вид&nbsp;пиццы, Район&nbsp;доставки]</span>.
            </p>
            <p class="term">
                Такая переменная отношения не соответствует 4НФ, так как существует следующая многозначная зависимость:
                <span>
                <br>Ресторан->Вид&nbsp;пиццы
                <br>Ресторан->Район&nbsp;доставки
                </span>
            </p>
            <p>
                То есть, например, при добавлении нового вида пиццы придется внести по одному новому кортежу для каждого
                района доставки. Возможна логическая аномалия, при которой определенному виду пиццы будут
                соответствовать лишь некоторые районы доставки из обслуживаемых рестораном районов.
            </p>
            <p class="term">
                Для предотвращения аномалии нужно декомпозировать отношение, разместив независимые факты в разных
                отношениях.
                <br>В данном примере следует выполнить декомпозицию на
                <span>[Ресторан, Вид&nbsp;пиццы]</span>
                и
                <span>[Ресторан, Район&nbsp;доставки]</span>.
            </p>
            <p>
                Однако, если к исходной переменной отношения добавить атрибут, функционально зависящий от потенциального
                ключа, например цену с учётом стоимости доставки ([Ресторан, Вид&nbsp;пиццы, Район&nbsp;доставки]->Цена),
                то полученное отношение будет находиться в 4НФ и его уже нельзя подвергнуть декомпозиции без потерь.
            </p>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="5nf">
        <h3><a href="#normal_form">Пятая нормальная форма</a></h3>
        <div>
            <p>
                Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между
                атрибутами.
                <br>
                Если "Атрибут_1" зависит от "Атрибута_2", а "Атрибут_2" в свою очередь зависит от "Атрибута_3",
                а "Атрибут_3" зависит от "Атрибута_1", то все три атрибута обязательно входят в один кортеж.
            </p>
            <p>Это очень жесткое требование, которое можно выполнить лишь при дополнительных условиях.</p>
            <div>
                <p class="spoiler-string">На практике трудно найти пример реализации этого требования в чистом виде.</p>
                <div class="spoiler">
                    <p>Например, некоторая таблица содержит три атрибута "Поставщик", "Товар" и "Покупатель".</p>
                    <p>Покупатель_1 приобретает несколько Товаров у Поставщика_1.</p>
                    <p>Покупатель_1 приобрел "новый&nbsp;Товар" у Поставщика_2.</p>
                    <p>Тогда в силу изложенного выше требования Поставщик_1 обязан поставлять Покупателю_1 тот же
                        самый "новый&nbsp;Товар", а Поставщик_2 должен поставлять Покупателю_1, кроме
                        "нового&nbsp;Товара", всю номенклатуру Товаров Поставщика_1.</p>
                    <p>Этого на практике не бывает. Покупатель свободен в своем
                        выборе товаров.</p>
                    <p>Поэтому для устранения отмеченного затруднения все три атрибута разносят по
                        разным отношениям (таблицам).</p>
                    <p>После выделения трех новых отношений (Поставщик, Товар и Покупатель) необходимо помнить,
                        что при извлечении информации (например, о покупателях и товарах)
                        необходимо в запросе соединить все три отношения.
                        <br>
                        Любая комбинация соединения двух отношений из трех неминуемо приведет к извлечению неверной
                        (некорректной) информации.
                    </p>
                    <p>Некоторые СУБД снабжены специальными механизмами, устраняющими извлечение
                        недостоверной информации.</p>
                    <p class="main-mind">
                        Тем не менее, следует придерживаться общей рекомендации:
                        структуру базы данных строить таким образом, чтобы избежать применения 4НФ и 5НФ.
                    </p>
                    <p>
                        Пятая нормальная форма ориентирована на работу с зависимыми
                        соединениями. Указанные зависимые соединения между тремя атрибутами встречаются очень редко.
                        Зависимые соединения между четырьмя, пятью и более атрибутами указать практически невозможно.
                    </p>
                </div>
            </div>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="dknf">
        <h3><a href="#normal_form">Доменно-ключевая нормальная форма</a></h3>
        <div>
            <p> Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение
                является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную
                отношения.</p>
            <p class="term mb10"><span>Ограничение домена</span>
                -&nbsp;ограничение, предписывающее использовать для определённого атрибута значения
                только из некоторого заданного домена.
                <br>
                Ограничение по своей сути является заданием перечня (или логического эквивалента перечня)
                допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип.</p>
            <p class="term mb10"><span>Ограничение ключа</span>
                -&nbsp;ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является
                потенциальным ключом.</p>
            <p> Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ.
                Однако не любую переменную отношения можно привести к ДКНФ.</p>
        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <hr>
    <div id="6nf">
        <h3><a href="#normal_form">Шестая нормальная форма</a></h3>
        <div>
            <p>Переменная отношения находится в 6НФ тогда и только тогда, когда она удовлетворяет
                всем нетривиальным зависимостям соединения.</p>
            <p> Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима,
                то есть не может быть подвергнута дальнейшей декомпозиции без потерь.</p>
            <p>Каждая переменная отношения, которая находится в 6НФ, также находится и в 5НФ.</p>
            <p>
                Идея "декомпозиции до конца" выдвигалась до начала исследований в области хронологических данных, но не
                нашла поддержки. Однако для хронологических баз данных максимально возможная декомпозиция позволяет
                бороться с избыточностью и упрощает поддержание целостности базы данных.</p>
            <div>
                <p class="spoiler-string">Для хронологических баз данных определены U_операторы, которые распаковывают
                    отношения по указанным атрибутам, выполняют соответствующую операцию
                    и упаковывают полученный результат.</p>
                <div class="spoiler">
                    <p>В данном примере соединение проекций отношения должно производится
                        при помощи оператора U_JOIN.</p>
                    <p class="bold no_mb">Работники</p>
                    <table class="list list--compact" aria-label="6nf_data">
                        <thead>
                        <tr>
                            <th>Табельный номер</th>
                            <th>Время</th>
                            <th>Должность</th>
                            <th>Домашний адрес</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>6575</td>
                            <td>01-01-2000:10-02-2003</td>
                            <td>Слесарь</td>
                            <td>ул. Ленина, д. 10</td>
                        </tr>
                        <tr>
                            <td>6575</td>
                            <td>11-02-2003:15-06-2006</td>
                            <td>Слесарь</td>
                            <td>ул. Советская, д. 22</td>
                        </tr>
                        <tr>
                            <td>6575</td>
                            <td>16-06-2006:05-03-2009</td>
                            <td>Бригадир</td>
                            <td>ул. Советская, д. 22</td>
                        </tr>
                    </table>
                    <p>Переменная отношения "Работники" не находится в 6НФ и может быть подвергнута декомпозиции на
                        переменные отношения "Должности работников" и "Домашние адреса работников".</p>
                    <p class="bold no_mb">Должности работников</p>
                    <table class="list list--compact" aria-label="6nf_level">
                        <thead>
                        <tr>
                            <th>Табельный номер</th>
                            <th>Время</th>
                            <th>Должность</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>6575</td>
                            <td>01-01-2000:10-02-2003</td>
                            <td>Слесарь</td>
                        </tr>
                        <tr>
                            <td>6575</td>
                            <td>16-06-2006:05-03-2009</td>
                            <td>Бригадир</td>
                        </tr>
                    </table>
                    <p class="bold no_mb">Домашние адреса работников</p>
                    <table class="list list--compact" aria-label="6nf_address">
                        <thead>
                        <tr>
                            <th>Табельный номер</th>
                            <th>Время</th>
                            <th>Домашний адрес</th>
                        <tr>
                        </thead>
                        <tr>
                            <td>6575</td>
                            <td>01-01-2000:10-02-2003</td>
                            <td>ул. Ленина, д. 10</td>
                        </tr>
                        <tr>
                            <td>6575</td>
                            <td>11-02-2003:15-06-2006</td>
                            <td>ул. Советская, д. 22</td>
                        </tr>
                    </table>
                </div>
            </div>


        </div>
        <a class="button button--to_content_menu" href="#normal_form"></a>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

<a href="#" class="button button--top"></a>

</body>

<script src="../../../js/submenu.js"></script>
<script src="../../../js/spoiler.js"></script>

</html>