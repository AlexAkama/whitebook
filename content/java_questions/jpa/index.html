<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JPA & HIBERNATE</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">JPA & HIBERNATE</h1>
    <div class="after-h1">Вопросы для собеседования</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="..">Questions</a></p>
        <p>JPA</p>
    </div>
    <h3 class="no_mt">Воросы:</h3>
    <ul class="menu">
        <li><a href="#q1">Что такое: ORM, JPA, Hibernate?</a></li>
        <li><a href="#q2">Что такое EntityManager? Его функции?</a></li>
        <li><a href="#q3">Каким условиям должен удовлетворять класс, чтобы являться Entity?</a></li>
        <li><a href="#q4">Может ли абстрактный класс быть Entity?</a></li>
        <li><a href="#q5">Наследование Entity классов.</a></li>
        <li><a href="#q6">Что такое встраиваемый (Embeddable) класс?
            Какие требования JPA предъявляет к встраиваемым (Embeddable) классам?</a></li>
    </ul>
</section>

<section class="container" id="q1">
    <h1><a href="#">Что такое: ORM, JPA, Hibernate?</a></h1>
    <div class="tab-1">
        <p><a href="#q1_orm">ORM</a></p>
        <p><a href="#q1_jpa">JPA</a></p>
        <p><a href="#q1_hibernate">Hibernate</a></p>
    </div>
    <hr class="mb10">

    <div id="q1_orm">
        <h3><a href="#q1">ORM</a></h3>
        <p class="no_mb main-mind">
            Object Relational Mapping (ORM)
            — это концепция/процесс преобразования данных из объектно-ориентированного языка в
            реляционные БД и наоборот.
        </p>
        <p class="example">Например, в Java это делается с помощью рефлексии и JDBC.</p>
        <p class="no_mb">
            <span class="accent-mono">JDBC (Java DataBase Connectivity)</span>
            — API для работы с реляционными (зависимыми) БД.
        </p>
        <p>
            Платформенно независимый промышленный стандарт взаимодействия Java-приложений с различными СУБД,
            реализованный в виде пакета java.sql, входящего в состав Java SE.
        </p>
        <p>

            Предоставляет методы для получения и
            обновления данных. Не зависит от конкретного типа базы. Библиотека, которая входит в стандартную библиотеу,
            содержит: набор классов и интерфейсов для работы с БД (для нас разработчиков api) + интерфейсы баз данных.
        </p>
        <p>
            JDBC реализует механизмы работы подключений к базе данных, создания запросов и обработки результатов.
        </p>

        <div>
            <h4>JDBC Архитектура</h4>
            <div class="image-box">
                <img class="image" src="./img/arch.png" alt="JDBC Архитектура">
            </div>
        </div>

        <div>
            <h4>JDBC Сущности</h4>
            <ol class="marker-mono">
                <li>
                    <p class="mb10">
                        <span class="accent-mono">Connection</span>
                        (класс) объект которого отвечает за соединение с базой и режим работы с ней.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="accent-mono">Statement</span>
                        (объект для оператора JDBC) используется для отправки SQL-оператора на сервер баз данных.
                    </p>
                    <p class="mb10">
                        Объект для оператора связан с объектом Connection и является объектом, обрабатывающим
                        взаимодействие между приложением и сервером баз данных.
                    </p>
                    <div class="tab-1">
                        <p>Можно:</p>
                        <ul>
                            <li>что-то поменять Update statement (create, delete, insert) в базе;</li>
                            <li>что-то запросить Query statement (select) из базы;</li>
                        </ul>
                    </div>
                    <div class="tab-1">
                        <p>Виды Statement-ов:</p>
                        <ul>
                            <li>
                                <span class="accent-mono">Statement (обычный)</span>
                                передаем в него либо Update, либо Query;
                            </li>
                            <li>
                                <span class="accent-mono">PreparedStatement</span>
                                - возможность сделать некий шаблон запроса, подставлять в него к-то значения и
                                использовать его;
                            </li>
                            <li>
                                <span class="accent-mono">CallableStatement</span>
                                - предоставляет возможность вызова хранимой процедуры,
                                расположенной на сервере, из Java™-приложения.
                            </li>
                        </ul>
                    </div>
                </li>
                <li>
                    <span class="accent-mono">ResultSet</span>
                    - объект с результатом запроса, который вернула база. Внутри него таблица.
                </li>
            </ol>
        </div>

        <div>
            <h4>Рефлексия</h4>
            <div class="tab-1">
                <p class="no_mb">это API, который позволяет:</p>
                <ul>
                    <li>
                        получать информацию о переменных, методах внутри класса, о самом классе, его конструкторах,
                        реализованных интерфейсах и т.д.;
                    </li>
                    <li>получать новый экземпляр класса;</li>
                    <li>получать доступ ко всем переменным и методам, в том числе <span>приватным</span>;</li>
                    <li>преобразовывать классы одного типа в другой (cast);</li>
                    <li>делать все это <span>во время исполнения программы</span> (динамически, в <span>Runtime</span>).
                    </li>
                </ul>
            </div>
            <p>
                В Java есть специальный класс по имени Class. Поэтому его и называют классом класса.
                С помощью него осуществляется работа с рефлексией.
            </p>
        </div>

    </div>

    <hr>
    <div id="q1_jpa">
        <h3><a href="#q1">JPA</a></h3>
        <p class="main-mind">
            Java Persistence API (JPA)
            - это спецификация (стандарт, технология), обеспечивающая объектно-реляционное отображение простых
            JAVA-объектов (Plain Old Java Object - POJO) и предоставляющая универсальный API для сохранения, получения и
            управления такими объектами.
        </p>
        <p>
            Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как должен
            действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.), реализующий стандарт JPA. Для
            этого JPA определяет интерфейсы, которые должны быть реализованы провайдерами. Также JPA определяет правила,
            как должны описываться метаданные отображения и как должны работать провайдеры. Каждый провайдер обязан
            реализовывать всё из JPA, определяя стандартное получение, сохранение и управление объектами. Помимо этого,
            провайдеры могут добавлять свои личные классы и интерфейсы, расширяя функционал JPA.
        </p>
        <p class="bold no_mb">JPA </p>
        <div class="tab-1">
            <ul>
                <li>API в пакете javax.persistance (набор интерфейсов EntityManager, Query, EntityTransaction);</li>
                <li>JPQL - объектный язык запросов (запросы выполняются к объектам);</li>
                <li>Metadata (аннотации или xml)</li>
            </ul>
        </div>
    </div>

    <hr>
    <div id="q1_hibernate">
        <h3><a href="#q1">HIBERNATE</a></h3>
        <p>
            <span class="accent-mono">Hibernate</span>
            - это провайдер, реализующий спецификацию JPA. Hibernate полностью реализует JPA плюс добавляет функционал в
            виде своих классов и интерфейсов, расширяя свои возможности по работе с сущностями и БД.
        </p>
    </div>

    <a class="button button--top" href="#"></a>

</section>

<section class="container" id="q2">
    <h1><a href="#">Что такое EntityManager?<br>Какие функции он выполняет?</a></h1>

    <div id="q2_entity_manager">
        <h3>EntityManager</h3>
        <p class="main-mind">
            Это интерфейс JPA, используемый для взаимодействия с персистентным контекстом.
        </p>
        <p class="no_mb">
            EntityManager описывает API для всех основных операций над Entity, а также для получения данных и других
            сущностей JPA.
        </p>
        <p>По сути - главный API для работы с JPA.</p>
        <p>
            <span class="accent-mono">Персистентный контекст</span>
            - это набор экземпляров сущностей, загруженных из БД или только что созданных.
        </p>
        <p>
            Персистентный контекст является своего рода кэшем данных в рамках транзакции
            - это и есть кэш первого уровня.
        </p>
        <p>
            Внутри контекста персистентности происходит управление экземплярами сущностей и их жизненным циклом.
        </p>
        <p>
            EntityManager автоматически сохраняет в БД все изменения, сделанные в его персистентном контексте,
            в момент коммита транзакции, либо при явном вызове метода <span class="code-word">flush()</span>.
        </p>
        <p>
            Один или несколько EntityManager образуют или могут образовать
            <span class="accent-mono">persistence context</span>.
        </p>
        <p>
            Если проводить аналогию с обычным JDBC, то EntityManagerFactory будет аналогом DataSource,
            а EntityManager аналогом Connection.
        </p>
        <p>
            Создание EntityManagerFactory довольно дорогая операция, поэтому обычно её создают один раз
            и на всё приложение.
            А чаще всего не создают сами, а делегируют это фреймворку, такому как Spring, например.
        </p>
        <p>
            Интерфейс Session из Hibernate представлен в JPA как раз интерфейсом EntityManager.
        </p>

        <table class="list" aria-label="">
            <thead>
            <tr>
                <th>JPA</th>
                <th>JDBC (по аналогии)</th>
                <th>Hibernate</th>
            <tr>
            </thead>
            <tr>
                <td>EntityManagerFactory</td>
                <td>DataSource</td>
                <td>SessionFactory</td>
            </tr>
            <tr>
                <td>EntityManager</td>
                <td>Connection</td>
                <td>Session</td>
            </tr>
            <tr>
                <td>JPQL</td>
                <td></td>
                <td>HQL</td>
            </tr>
        </table>

    </div>

    <div id="q2_entity_manager_function">
        <h3>Основные функции EntityManager</h3>
        <ol>
            <li>
                <p>Операции над Entity:</p>
                <ul>
                    <li><span class="accent-mono">persist</span> (добавление Entity под управление JPA)</li>
                    <li><span class="accent-mono">merge</span> (изменение)</li>
                    <li><span class="accent-mono">remove</span> (удаление)</li>
                    <li><span class="accent-mono">refresh</span> (обновление данных)</li>
                    <li><span class="accent-mono">detach</span> (удаление из-под управления контекста персистентности)
                    </li>
                    <li><span class="accent-mono">lock</span> (блокирование Entity от изменений в других thread)</li>
                </ul>
            </li>
            <li>
                <p>Получение данных:</p>
                <ul>
                    <li><span class="accent-mono">find</span> (поиск и получение Entity)</li>
                    <li><span class="accent-mono">createQuery</span></li>
                    <li><span class="accent-mono">createNamedQuery</span></li>
                    <li><span class="accent-mono">createNativeQuery</span></li>
                    <li><span class="accent-mono">contains</span></li>
                    <li><span class="accent-mono">createNamedStoredProcedureQuery</span></li>
                    <li><span class="accent-mono">createStoredProcedureQuery</span></li>
                </ul>
            </li>
            <li>
                <p>Получение других сущностей JPA</p>
                <ul>
                    <li><span class="accent-mono">getTransaction</span></li>
                    <li><span class="accent-mono">getEntityManagerFactory,</span></li>
                    <li><span class="accent-mono">getCriteriaBuilder</span></li>
                    <li><span class="accent-mono">getMetamodel</span></li>
                    <li><span class="accent-mono">getDelegate</span></li>
                </ul>
            </li>
            <li>
                <p>Работа с EntityGraph</p>
                <ul>
                    <li><span class="accent-mono">createEntityGraph</span></li>
                    <li><span class="accent-mono">getEntityGraph</span></li>
                </ul>
            </li>
            <li>
                <p>Общие операции</p>
                <ul>
                    <li><span class="accent-mono">close</span></li>
                    <li><span class="accent-mono">isOpen</span></li>
                    <li><span class="accent-mono">getProperties</span></li>
                    <li><span class="accent-mono">setProperty</span></li>
                    <li><span class="accent-mono">clear</span></li>
                </ul>
            </li>
        </ol>
        <p class="main-mind">
            Объекты EntityManager не являются потокобезопасными.
        </p>
        <p>
            Это означает, что каждый поток должен получить свой экземпляр EntityManager,
            поработать с ним и закрыть его в конце.
        </p>

    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1><a href="#">Каким условиям должен удовлетворять класс, чтобы являться Entity?</a></h1>
    <div class="tab-1">
        <p><a href="#q3_entity">Entity</a></p>
        <p><a href="#q3_entity_jpa">Требования к Entity классу в JPA</a></p>
        <p><a href="#q3_entity_hibernate">Требования к Entity классу в Hibernate</a></p>
    </div>

    <hr>
    <div id="q3_entity">
        <h3><a href="#q3">Entity</a></h3>
        <p class="main-mind">Сущность (entity) - это объект персистентной области.</p>
        <p>
            Как правило, сущность представляет таблицу в реляционной базе данных, и каждый экземпляр сущности
            соответствует строке в этой таблице.
        </p>
        <p>
            Основным программным представлением сущности является класс сущности.
        </p>
        <p>
            Класс сущности может использовать другие классы, которые служат
            вспомогательными классами или используются для представления состояния сущности (например embedded).
        </p>
        <p>
            <span class="accent-mono">Персистентное состояние</span>
            сущности представлено персистентными полями или персистентными свойствами.
        </p>
        <p>
            <span class="accent-mono">Персистентное поле</span>
            - поле сущности, которое отражается в БД в виде столбца таблицы.
        </p>
        <p>
            <span class="accent-mono">Персистентное свойство</span>
            - это методы, которые аннотированы вместо полей для доступа провайдера к ним (полям).
        </p>
        <p>
            Эти поля или свойства используют аннотации объектно-реляционного сопоставления (маппинга) для сопоставления
            сущностей и отношений между ними с реляционными данными в хранилище данных.
        </p>
        <p>
            Примеры аннотаций:
            <span class="annotation">@OneToOne</span>,
            <span class="annotation">@OneToMany</span>,
            <span class="annotation">@ManyToOne</span>,
            <span class="annotation">@ManyToMany</span>.
        </p>
        <p>Есть два вида доступа к состоянию сущности:</p>
        <ul>
            <li class="mb10">
                <p><span class="accent-mono">Доступ по полю</span>, когда аннотации стоят над полями.</p>
                <p>В этом случае провайдер, например, Hibernate, обращается к полям класса напрямую, используя
                    Reflection.</p>
            </li>
            <li>
                <p>
                    <span class="accent-mono">Доступ по свойству</span>,
                    когда аннотации стоят над методами-геттерами.
                </p>
                <p>В этом случае провайдер, например, Hibernate, обращается к полям класса через методы.</p>
            </li>
        </ul>
        <p>В JPA принято называть эти персистентные поля и свойства атрибутами класса-сущности.</p>
    </div>

    <hr>
    <div id="q3_entity_jpa">
        <h3><a href="#q3">Требования к Entity классу в JPA</a></h3>
        <ul>
            <li class="mb10">
                Entity класс должен быть помечен аннотацией @Entity или описан в XML файле конфигурации JPA.
            </li>
            <li class="mb10">
                Entity класс должен содержать public или protected конструктор без аргументов
                (он также может иметь конструкторы с аргументами).
            </li>
            <li class="mb10">
                Entity класс должен быть классом верхнего уровня
                (<a href="../core/classes/#q1" target="_blank" title="для тех кто забыл">top-level class</a>).
            </li>
            <li class="mb10">
                Перечисление (enum) или интерфейс (interface) не могут быть определены как сущность.
            </li>
            <li class="mb10">
                <p>Entity класс не может быть финальным классом (final class).</p>
                <p>
                    Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге
                    (persistent final methods or persistent final instance variables).
                </p>
            </li>
            <li class="mb10">
                Если объект Entity класса будет передаваться по значению как отделённый от контекста персистентности
                объект (detached object), например через удаленный интерфейс (through a remote interface), то он также
                должен реализовывать интерфейс Serializable (чтобы объекты, которые достаются из базы, могли сохраняться
                в кэше).
            </li>
            <li class="mb10">
                <p>Как обычный так и абстрактный класс может быть Entity.</p>
                <p>Entities могут наследоваться как от не Entity классов, так и от Entity классов. </p>
                <p>А не Entity классы могут наследоваться от Entity классов.</p>
            </li>
            <li class="mb10">
                <p>
                    Поля Entity класса должны быть объявлены private, protected или package-private, быть напрямую
                    доступными только методам самого Entity класса и не должны быть напрямую доступны другим классам,
                    использующим этот Entity.
                </p>
                <p>
                    Другие классы должны обращаться только к специальным методам Entity класса, предоставляющим доступ
                    к этим полям (getter/setter-методам или другим методам бизнес-логики в Entity классе).
                </p>
            </li>
            <li class="mb10">
                Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов,
                которые уникально определяют запись этого Entity класса в базе данных.
            </li>
        </ul>
    </div>

    <hr>
    <div id="q3_entity_hibernate">
        <h3><a href="#q3">Требования к Entity классу в Hibernate</a></h3>
        <p>Hibernate не так строг в своих требованиях. Вот отличия от требований JPA:</p>
        <ol>
            <li class="mb10">
                Класс сущности должен иметь конструктор без аргументов, который может быть не только public
                или protected, но и package visibility (default).
            </li>
            <li class="mb10">Класс сущности необязательно должен быть классом верхнего уровня.</li>
            <li class="mb10">
                <p>Технически Hibernate может сохранять финальные классы или классы
                    с финальными методами (getter / setter).</p>
                <p class="example">Однако, как правило, это не очень хорошая идея, так как это лишит Hibernate
                    возможности генерировать прокси для отложенной загрузки сущности.</p>
            </li>
            <li class="mb10">
                <p>Hibernate не запрещает разработчику приложения открывать прямой доступ к переменным экземпляра и
                    ссылаться на них извне класса сущности.</p>
                <p class="example">Однако обоснованность такого подхода спорна.</p>
            </li>
        </ol>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1><a href="#">Может ли абстрактный класс быть Entity?</a></h1>
    <p class="main-mind"> Абстрактный класс может быть Entity классом.</p>
    <p>
        Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого
        класса. Имена абстрактных классов могут использоваться в запросах.
    </p>

    <p>
        Абстрактные Entity классы используются в наследовании, когда их потомки наследуют поля абстрактного класса:
    </p>

    <div class="code">
        <p class="annotation">@Entity</p>
        <p class="annotation">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</p>
        <p>public abstract class <span class="name">Employee</span> {</p>
        <p class="tab-1 annotation">@Id</p>
        <p class="tab-1 annotation">@GeneratedValue</p>
        <p class="tab-1">private long id;</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-2">...</p>
        <p>}</p>
    </div>

    <div class="code">
        <p class="annotation">@Entity</p>
        <p class="annotation">@Table(name = "FULL_TIME_EMP")</p>
        <p>public class <span class="name">FullTimeEmployee</span> extends <span class="name">Employee</span></p>
        <p class="tab-1">private int salary;</p>
        <p class="tab-2">...</p>
        <p>}</p>
    </div>

    <div class="code">
        <p class="annotation">@Entity</p>
        <p class="annotation">@Table(name = "PART_TIME_EMP")</p>
        <p>public class <span class="name">PartTimeEmployee</span> extends <span class="name">Employee</span> {</p>
        <p class="tab-1">private int hourlyRate;</p>
        <p class="tab-2">...</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1><a href="#">Наследование Entity классов.</a></h1>

    <p>Таблица вариантов наследования Entity классов:</p>
    <table class="list list--content-center" aria-label="entity_inheritance">
        <thead>
        <tr>
            <th>Родитель/Наследник</th>
            <th>Entity класс</th>
            <th>не Entity класс</th>
        <tr>
        </thead>
        <tr>
            <td>Entity класс</td>
            <td>+</td>
            <td>+</td>
        </tr>
        <tr>
            <td>Entity класс</td>
            <td>+</td>
            <td>обычное наследование в&nbsp;Java</td>
        </tr>
    </table>

    <hr>
    <div>
        <h3>Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?</h3>
        <p>
            <span class="accent-mono">Да</span>,
            сущности могут наследоваться от не Entity классов, которые, в свою очередь, могут быть как абстрактными, так
            и обычными.
        </p>
        <p>
            Состояние (поля) не Entity суперкласса не является персистентным, то есть не хранится в БД и не
            обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом,
            также не будет отображаться в БД.
        </p>
        <p>
            Не Entity суперклассы не могут участвовать в операциях EntityManager или Query. Любые маппинги или аннотации
            отношений в не Entity суперклассах игнорируются.
        </p>
    </div>

    <hr>
    <div>
        <h3>Может ли Entity класс наследоваться от Entity классов?</h3>
        <p><span class="accent-mono">Да</span>, может.</p>
    </div>

    <hr>
    <div>
        <h3>Может ли не Entity класс наследоваться от Entity класса?</h3>
        <p><span class="accent-mono">Да</span>, может.</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1><a href="#">Что такое встраиваемый (Embeddable) класс?
        <br>Какие требования JPA предъявляет к встраиваемым (Embeddable) классам?</a></h1>

    <hr>
    <div class="q6_embeddable">
        <h3>Встраиваемый (Embeddable) класс</h3>
        <p>
            Это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов.
        </p>
        <p class="no_mb">Hibernate называет эти классы <span class="accent-mono">компонентами</span>. </p>
        <p>JPA называет их <span class="accent-mono">встраиваемыми</span>.</p>
        <p>В любом случае, концепция одна и та же: композиция значений.</p>
        <p>Встраиваемый класс помечается аннотацией <span class="annotation">@Embeddable</span>.</p>
        <p class="no_mb">
            Встраиваемый класс может быть встроен в несколько классов-сущностей, но встроенный объект с конкретным
            состоянием принадлежит исключительно владеющей им сущности и не может использоваться одновременно другими
            сущностями, он не является общим для нескольких сущностей.
        </p>
        <p class="example">
            То есть, если класс <span class="code-word">Person</span> с полями
            <span class="code-word">name</span> и <span class="code-word">age</span>
            встроен и в класс <span class="code-word">Driver</span>, и в класс <span class="code-word">Baker</span>,
            то у обоих последних классов появятся оба поля из класса Person. Но если у объекта Driver эти поля будут
            иметь значения "Иван" и "35", то эти же поля у объекта Baker могут иметь совершенно иные значения, никак не
            связанные с объектом Driver.
        </p>
        <p>
            В целом, встраиваемый класс служит для того, чтобы выносить определение общих атрибутов для нескольких
            сущностей, можно считать что JPA просто встраивает в сущность вместо объекта такого класса те атрибуты,
            которые он содержит.
        </p>
    </div>

    <hr>
    <div class="q6_embeddable_feature">
        <h3>Особенности встраиваемых классов</h3>
        <ul>
            <li class="mb10">
                все поля встраиваемого класса, даже коллекции, станут полями класса, в который происходит встраивание;
            </li>
            <li class="mb10">
                встраиваемые классы могут быть встроены в одну и ту же сущность несколько раз, нужно только поменять
                имена полей;
            </li>
            <li class="mb10">
                экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного
                персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они
                принадлежат;
            </li>
            <li class="mb10">
                экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного
                персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они
                принадлежат;
            </li>
            <li class="mb10">
                <p>встраиваемые классы могут использовать в качестве полей:</p>
                <ul class="dash-style">
                    <li>базовые типы;</li>
                    <li>коллекции базовых типов (с аннотацией @ElementCollection);</li>
                    <li>другие встраиваемые классы;</li>
                    <li>коллекции других встраиваемых классов (с аннотацией @ElementCollection);</li>
                    <li>сущности;</li>
                    <li>коллекции сущностей;</li>
                </ul>
            </li>
            <li class="mb10">
                сущность может использовать в качестве полей одиночные встраиваемые классы и коллекции встраиваемых
                классов;
            </li>
            <li>
                встраиваемые классы могут использоваться в качестве ключей и значений Map.
            </li>
        </ul>
    </div>

    <hr>
    <div class="q6_embeddable_requirement">
        <h3>Требования к встраиваемым классам</h3>
        <ul>
            <li>
                Должны соответствовать <a href="#q3_entity_jpa">требованиям для сущностей</a>, за исключением того,
                что у встраиваемых классов не ставится аннотация @Entity и может отсутствовать первичный ключ @Id.
            </li>
            <li>Должны быть аннотированы @Embeddable.</li>
        </ul>
    </div>

    <a href="#" class="button button--top"></a>
</section>


<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

</body>

</html>