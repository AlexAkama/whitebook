<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Classes</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Классы JAVA</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>Classes</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Из чего состоит класс. Какие виды классов есть в java?</a></li>
        <li><a href="#q2">Что такое вложенный класс</a></li>
        <li><a href="#q3">Что такое локальный класс?</a></li>
        <li><a href="#q4">Что такое анонимные классы?</a></li>
        <li><a href="#q5">Что такое перечисления (enum)?</a></li>
        <li><a href="#q6">Что такое конструктор?</a></li>
        <li><a href="#q7">Модификаторы доступа</a></li>
        <li><a href="#q8">Использование модификаторов</a></li>
        <li><a href="#q9">Абстрактные классы</a></li>
        <li><a href="#q10">Интерфейсы</a></li>
        <li><a href="#q11">Порядок вызова конструкторов</a></li>
        <li><a href="#q12">Object, equals и hashCode</a></li>
        <li><a href="#q13">this и super</a></li>
        <li><a href="#q14">Методы. Переопределение и перегрузка</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1><a href="#">Из чего состоит класс.<br>Какие виды классов есть в JAVA?</a></h1>
    <div>
        <h3>КЛАСС</h3>
        <h4>Класс в Java состоит из следующих элементов:</h4>
        <ol class="margined">
            <li class="definition">
                <span>Имя класса (Class Name):</span>
                <br>Имя, по которому класс можно идентифицировать. Имя класса должно быть уникальным.
            </li>
            <li class="definition">
                <span>Поля (Fields):</span>
                <br>Это переменные, которые представляют данные или состояние объекта. Они могут быть разных типов,
                таких как int, String, custom types и так далее.
            </li>
            <li class="definition">
                <span>Конструкторы (Constructors):</span>
                <br>Это специальные методы, которые вызываются при создании объекта класса. Имя
                конструктора должно совпадать с именем класса. Они используются для инициализации полей класса.
            </li>
            <li class="definition">
                <span>Методы (Methods):</span>
                <br>Методы представляют действия, которые может выполнять объект. Методы определяют поведение
                класса. Они могут принимать параметры и могут возвращать значения.
            </li>
            <li class="definition">
                <span>Вложенные классы и интерфейсы (Nested classes & interfaces):</span>
                <br>Класс может содержать другие классы и интерфейсы.
            </li>
            <li class="definition">
                <span>Блоки инициализации (Initialization blocks):</span>
                <br>Это блоки кода, которые выполняются при создании объекта класса. Они
                могут быть статическими (выполняются при загрузке класса) или нестатическими (выполняются перед каждым
                вызовом конструктора).
            </li>
            <li class="definition">
                <span>Модификаторы класса (Class Modifiers):</span>
                <br>Это <a href="#q7">ключевые слова</a>, которые определяют свойства класса, такие как public,
            </li>
        </ol>
    </div>

    <hr>
    <div>
        <h3>Виды классов</h3>
        <ul>
            <li>
                <p><span class="accent-mono">Top level class</span> (Обычный класс):</p>
                <ul class="dash-style">
                    <li>Abstract class (Абстрактный класс);</li>
                    <li>Final class (Финализированный класс).</li>
                </ul>
            </li>
            <li class="mb10"><span class="accent-mono">Interfaces</span> (Интерфейс).</li>
            <li class="mb10"><span class="accent-mono">Enum</span> (Перечисление).</li>
            <li>
                <p><span class="accent-mono">Nested class</span> (Вложенный класс):</p>
                <ul class="dash-style">
                    <li>Static nested class (Статический вложенный класс);</li>
                    <li>Member inner class (Простой внутренний класс);</li>
                    <li>Local inner class (Локальный класс);</li>
                    <li>Anonymous inner class (Анонимный вложенный класс).</li>
                </ul>
            </li>
        </ul>
        <p>К классам верхнего уровня модификатор static неприменим.</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1><a href="#">Расскажите про вложенные классы.<br>В каких случаях они применяются?</a></h1>
    <p class="main-mind">
        Класс называется вложенным (Nested class), если он определен внутри другого класса.
    </p>
    <p class="no_mb">
        Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его
        класс.
    </p>
    <p>
        Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен
        стать классом верхнего уровня.
    </p>
    <p>
        Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот.
        Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.
    </p>
    <p>Существуют четыре категории вложенных классов:</p>
    <ul class="tab-3 margined">
        <li>Static nested class (Статический вложенный класс);</li>
        <li>Member inner class (Простой внутренний класс);</li>
        <li><a href="#q3">Local inner class (Локальный класс)</a>;</li>
        <li><a href="#q4">Anonymous inner class (Анонимный класс)</a>.</li>
    </ul>
    <p>
        Такие категории классов, за исключением первого, также называют
        <span class="bold">внутренними (Inner class)</span>.
    </p>
    <p class="mb20">Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>
    <p>Каждая из категорий имеет рекомендации по своему применению:</p>
    <ul class="margined">
        <li>
            <span class="bold">Cтатический</span>:
            если вложенный класс должен быть виден за пределами одного метода или
            он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода
            и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр.
        </li>
        <li>
            <span class="bold">Нестатический</span>:
            если ссылка на обрамляющий класс не требуется. Доступ к полям стат. и нестат. класса.
        </li>
        <li>
            <span class="bold">Локальный</span>:
            если класс необходим только внутри какого-то метода и требуется создавать
            экземпляры этого класса только в этом методе.
        </li>
        <li>
            <span class="bold">Анонимный</span>:
            если к тому же применение класса сводится к использованию лишь в одном
            месте и уже существует тип, характеризующий этот класс.
        </li>
    </ul>

    <hr>
    <div>
        <h3>Каким образом из вложенного класса получить доступ к полю внешнего класса?</h3>
        <p class="no_mb">Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего
            класса.</p>
        <p class="no_mb">
            Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В
            случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к
            такому полю следует через ссылку на его экземпляр.
        </p>
        <p class="example">Например: Outer.this.field.</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1><a href="#">Что такое локальный класс?<br>Каковы его особенности?</a></h1>
    <p class="main-mind">
        Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован
        в любом блоке, в котором разрешается декларировать переменные.
    </p>
    <p>
        Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться
        многократно.
    </p>
    <p>
        Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в
        нестатическом контексте.
    </p>
    <h4 class="no_mb">Локальные классы имеют следующие особенности:</h4>
    <ul>
        <li>Видны только в пределах блока, в котором объявлены;</li>
        <li>Не могут быть объявлены как private/public/protected или static;</li>
        <li>Не могут иметь внутри себя статических объявлений (полей, методов, классов);</li>
        <li>Имеют доступ к полям и методам обрамляющего класса;</li>
        <li>Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1><a href="#">Что такое анонимные классы?<br>Где они применяются?</a></h1>
    <p class="main-mind">
        Это вложенный локальный класс без имени, который разрешено декларировать в любом месте
        обрамляющего класса, разрешающем размещение выражений.
    </p>
    <p>
        Создание экземпляра анонимного класса происходит одновременно с его объявлением.
    </p>
    <p>
        В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный
        класс - в нестатическом контексте появляется окружающий его экземпляр.
    </p>
    <h4 class="no_mb">Анонимные классы имеют несколько ограничений:</h4>
    <ul>
        <li>Их использование разрешено только в одном месте программы - месте его создания;</li>
        <li>
            Применение возможно только в том случае, если после порождения экземпляра нет
            необходимости на него ссылаться;
        </li>
        <li>
            Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов,
            так как для доступа к ним нет поименованного типа.
        </li>
    </ul>

    <h4 class="no_mb">Анонимные классы обычно применяются для:</h4>
    <ul>
        <li>создания объекта функции (function object), например реализация интерфейса Comparator;</li>
        <li>создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;</li>
        <li>в статическом методе генерации;</li>
        <li>
            инициализации открытого статического поля final, которое соответствует сложному
            перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный.
        </li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1><a href="#">Что такое перечисления (enum)?</a></h1>
    <p class="main-mind">
        Перечисления представляют набор логически связанных констант.
    </p>
    <p>
        Объявление перечисления происходит с помощью оператора <span class="code-word">enum</span>,
        после которого идет название перечисления. Затем идет список элементов перечисления через запятую.
    </p>
    <p>Каждый из них явно объявлен как открытый статический финальный член класса.</p>

    <h4 class="no_mb">Особенности Enum классов:</h4>
    <ul class="tab-2">
        <li>Конструктор всегда private или default</li>
        <li>Могут имплементировать интерфейсы</li>
        <li>Не могут наследовать класс</li>
        <li>Можем переопределить toString()</li>
        <li>Нет public конструктора, поэтому нельзя создать экземпляр вне Enum</li>
        <li>При equals() выполняется ==</li>
        <li>values() возвращает все элементы</li>
        <li>ordinal() возвращает порядок элементов</li>
        <li>Может использоваться в TreeSet и TreeMap т.к. Enum имплементирует Comparable</li>
        <li>compareTo() имитирует порядок элементов предоставляемый ordinal()</li>
        <li>Можно использовать в Switch Case</li>
        <li>Легко создать потокобезопасный синглтон без double check volatile переменных.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1><a href="#">Конструкторы</a></h1>
    <h3>Что такое конструктор по умолчанию?</h3>
    <p>
        Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так
        называемый «конструктор по умолчанию».
    </p>
    <p>
        Если вы создали конструктор с аргументами, то конструктор по умолчанию использоваться не будет (если он не
        создан).
    </p>
    <h3>Могут ли быть приватные конструкторы? Для&nbsp;чего&nbsp;они&nbsp;нужны?</h3>
    <p>
        Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим
        методом генерации объектов данного класса.
    </p>
    <p> Также доступ к нему разрешен вложенным классам и может использоваться для их нужд.</p>
    <p>
        Запрещает создание экземпляра класса вне методов самого класса, например, чтобы гарантировать существование
        только одного объекта определённого класса, предположим какого-то ресурса, например БД.
    </p>
    <h3>Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами? </h3>
    <p class="no_mb">У конструктора по умолчанию отсутствуют какие-либо аргументы.</p>
    <p class="no_mb">
        Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания
        его клона.
    </p>
    <p>
        Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для
        инициализации полей класса).
    </p>
    <h3>Можно ли наследовать конструктор?</h3>
    <p>
        В Java конструкторы не наследуются, и поэтому они не могут быть переопределены в подклассах. Однако, подкласс
        может вызывать конструктор суперкласса с помощью ключевого слова super.
    </p>
    <h3>Что такое перегрузка конструктора?</h3>
    <div>
        <p>
            Перегрузка конструктора в Java это механизм, который позволяет классу иметь более одного конструктора, но с
            различными параметрами.
        </p>
        <p>
            Перегруженные конструкторы отличаются друг от друга по числу параметров или по типу параметров. Компилятор
            Java использует эти различия для определения, какой из конструкторов следует вызывать при создании объекта.
        </p>
        <p>
            Основной целью перегрузки конструктора является увеличение гибкости при создании объектов класса.
        </p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1><a href="#">Какие модификаторы доступа есть в Java?</a></h1>
    <h3>Модификаторы доступа</h3>
    <p><span class="bold">private</span>(приватный): члены класса доступны только внутри класса.</p>
    <p>
        <span class="bold">default, package-private, package level</span>
        (доступ на уровне пакета): видимость класса/членов класса только внутри пакета.
        Является модификатором доступа по умолчанию.
    </p>
    <p><span class="bold">protected</span>(защищённый): члены класса доступны внутри пакета и в наследниках.</p>
    <p><span class="bold">public</span> (публичный): класс/члены класса доступны всем.</p>

    <p>
        Во время наследования возможно изменения модификаторов доступа в сторону большей
        видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
    </p>

    <table class="list list--dictionary list--content-center" aria-label="Access modifiers">
        <col style="width: 20%">
        <col style="width: 20%">
        <col style="width: 20%">
        <col style="width: 20%">
        <col style="width: 20%">
        <thead>
        <tr>
            <th>Ключевое слово</th>
            <th>Класс</th>
            <th>Пакет</th>
            <th>Наследник</th>
            <th>Все</th>
        </tr>
        </thead>
        <tr>
            <td>private</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>-</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>protected</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>public</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
        </tr>
    </table>

    <h3>Модификатор static</h3>
    <p class="no_mb"> Модификатор, применяемый к полю, блоку, методу, внутреннему классу. </p>
    <p>Данный модификатор указывает на привязку субъекта к текущему классу.</p>

    <h3>Модификатор final</h3>
    <p class="no_mb">
        Модификатор final может применяться к переменным, параметрам методов, полям и методам
        класса или самим классам.
    </p>
    <ul class="tab-2">
        <li>Класс не может иметь наследников;</li>
        <li>Метод не может быть переопределен в классах наследниках;</li>
        <li>Поле не может изменить свое значение после инициализации;</li>
        <li>Параметры методов не могут изменять своё значение внутри метода;</li>
        <li>Локальные переменные не могут быть изменены после присвоения им значения.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1><a href="#">Использование модификаторов</a></h1>

    <hr>
    <h3>Могут ли классы быть статическими?</h3>
    <p><strong>Да</strong></p>
    <p>Объект статического класса не хранит ссылку на конкретный экземпляр внешнего класса.</p>
    <p>Объект статического вложенного класса вполне может существовать сам по себе.</p>
    <p>Статический вложенный класс может обращаться только к статическим полям и методам внешнего класса.</p>
    <p>
        Объекты статического класса не содержат ссылок на объекты внешнего класса.
        А самих объектов мы можем создать сколько угодно.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1><a href="#">Абстрактные классы</a></h1>
    <hr>
    <h3>Что такое абстрактные классы?<br>Чем они отличаются от обычных?</h3>
    <p>
        Класс помеченный модификатором <span class="code-word">abstract</span> называется
        абстрактным классом.
    </p>
    <p class="main-mind">
        Создавать экземпляры самого абстрактного класса не разрешается.
    </p>
    <p class="no_mb">
        Такие классы могут выступать <strong>только предками</strong> для других классов.
    </p>
    <p>
        При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие
        создание объектов.
    </p>
    <p>
        Метод помеченный ключевым словом <span class="code-word">abstract</span> - абстрактный метод,
        т.е. метод, который не имеет реализации.
    </p>
    <p class="main-mind">
        Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.
    </p>
    <p>
        Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть
        реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
    </p>

    <h4 class="no_mb">Особенности абстрактных классов:</h4>
    <ul class="tab-2">
        <li>Может быть конструктор (для вызовов по цепочке из наследников)</li>
        <li>Имплементят интерфейсы, но не обязаны реализовывать их методы</li>
        <li>Не могут быть final</li>
        <li>Могут содержать static методы</li>
        <li>Нельзя создать объект</li>
        <li>Абстрактные методы могут отсутствовать</li>
        <li>Может содержать метод main()</li>
        <li>Классы-наследники не обязаны реализовывать все абстрактные методы</li>
    </ul>
    <hr>
    <h3>Может ли быть абстрактный класс без абстрактных методов?</h3>
    <p>Да</p>
    <hr>
    <h3>Могут ли быть конструкторы у абстрактных классов? Для&nbsp;чего&nbsp;они&nbsp;нужны?</h3>
    <p>Да, может быть конструктор (для вызовов по цепочке из наследников).</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1><a href="#">Интерфейсы</a></h1>
    <h3>Что такое интерфейсы?</h3>
    <p>
        Ключевое слово <span class="code-word">interface</span> используется для создания полностью абстрактных классов.
    </p>
    <p class="main-mind">
        Основное предназначение интерфейса - определять каким образом мы можем использовать класс,
        который его реализует.
    </p>
    <p>Интерфейс в Java может содержать следующие элементы:</p>
    <ol class="margined">
        <li>
            <p><span class="term">Методы:</span> Интерфейс может объявлять любое количество методов.</p>
            <p>Все методы в интерфейсе по умолчанию являются публичными и абстрактными.</p>
            <p class="example">
                Т.е. определяются имена методов, списки аргументов и типы возвращаемых значений, но не реализуется их
                поведение. Все методы неявно объявляются как public.
            </p>
        </li>
        <li>
            <p>
                <span class="term">Константы:</span>
                Интерфейс может содержать переменные, которые по умолчанию являются
                <strong>public</strong>, <strong>static</strong> и <strong>final</strong>.
            </p>
            <p class="example">Т.е. по факту это константы.</p>
        </li>
        <li>
            <p>
                <span class="term">Вложенные типы:</span>
                Интерфейс может содержать вложенные интерфейсы, классы и перечисления.
            </p>
        </li>
        <li>
            <p>
                <span class="term">Методы по умолчанию:</span>
                Начиная с Java 8, интерфейсы могут содержать методы по умолчанию (default), которые предоставляют их
                реализацию. Методы по умолчанию помогают в расширении интерфейсов без опасения нарушения существующих
                классов, которые уже реализуют эти интерфейсы.
            </p>
        </li>
        <li>
            <p>
                <span class="term">Статические методы:</span>
                Также, начиная с Java 8, интерфейс может содержать статические методы.
            </p>
        </li>
        <li>
            <p><span class="term">Частные (приватные) методы:</span>
                Начиная с Java 9, интерфейсы могут содержать частные (приватные) методы, которые могут быть использованы
                для повторного использования общего кода между методами.
            </p>
        </li>
    </ol>

    <hr>
    <h3>Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h3>
    <p>
        Интерфейс также может содержать и <strong>поля</strong>.
        В этом случае они <strong>автоматически</strong> являются публичными <strong>public</strong>,
        статическими <strong>static</strong> и неизменяемыми <strong>final</strong>.
    </p>

    <hr>
    <h3>Что такое static метод интерфейса?</h3>
    <p class="no_mb">
        Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что
        для них <strong>отсутствует возможность переопределения в классах</strong>, реализующих интерфейс.
    </p>
    <p class="no_mb">
        Статические методы в интерфейсе являются частью интерфейса без возможности
        использовать их для объектов класса реализации;
    </p>
    <p class="example no_mb"> Методы класса java.lang.Object нельзя переопределить как статические; </p>
    <p class="example">
        Статические методы в интерфейсе используются для обеспечения вспомогательных методов,
        например, проверки на null, сортировки коллекций и т.д.
    </p>

    <hr>
    <h3> Что такое дефолтные методы интерфейсов?</h3>
    <p>
        Если <strong>класс</strong> реализует интерфейс, он может, но <strong>не обязан, реализовать</strong>
        методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
    </p>
    <p> Дефолтные методы <strong>можно переопределить</strong>.</p>
    <p class="main-mind">
        Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по
        умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно.
    </p>
    <p class="main-mind">
        Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод
        является абстрактным - никакой реализации по умолчанию классом не наследуется.
    </p>
    <p>Метод по умолчанию не может переопределить метод класса java.lang.Object.</p>

    <h3>Для чего они нужны?</h3>
    <p class="no_mb">Помогают реализовывать интерфейсы без страха нарушить работу других классов.</p>
    <p class="no_mb">
        Позволяют избежать создания служебных классов, так как все необходимые методы могут
        быть представлены в самих интерфейсах.
    </p>
    <p> Дают свободу классам выбрать метод, который нужно переопределить. </p>

    <p>
        Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать
        лямбда-выражения.
    </p>

    <hr>
    <div>
        <h3>Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?</h3>
        <p class="no_mb">Методы по умолчанию, Статические методы и Частные (приватные) методы.</p>
        <p class="example">см. <a href="#q10">содержимое интерфейса</a></p>
    </div>


    <hr>
    <div>
        <h3> Чем интерфейсы отличаются от абстрактных классов?</h3>
        <ul>
            <li>
                Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса
                состояние есть: он описывает и то, и другое.
            </li>
            <li>
                <p>
                    Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую
                    связь (птицы: голуби, воробьи).
                </p>
                <p>
                    В то же время, один и тот же интерфейс могут реализовать классы,
                    у которых вообще нет ничего общего
                    <span class="example">(Flyable: птицы, наркоман, самолет)</span>.
                </p>
            </li>
            <li>
                Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только
                от одного класса
            </li>
        </ul>
    </div>

    <hr>
    <div>
        <h3>Может ли один интерфейс наследоваться от другого?</h3>
        <p>Да.</p>
        <h4>От двух других?</h4>
        <p>И снова да.</p>
    </div>

    <hr>
    <div>
        <h3>
            Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
        </h3>
        <p>Через переопределение.</p>
    </div>


    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1><a href="#">Порядок вызова конструкторов и блоков инициализации</a></h1>
    <p>
        Сначала вызываются <strong>все статические блоки</strong> в очередности от первого статического блока
        корневого предка и выше <strong>по цепочке иерархии</strong> до статических блоков самого класса.
    </p>
    <p>
        Затем вызываются <strong>нестатические блоки</strong> инициализации корневого предка,
        <strong>конструктор корневого предка</strong> и так далее вплоть
        <strong>до</strong> нестатических блоков и конструктора <strong>самого класса</strong>.
    </p>
    <p class="main-mind">
        Parent&nbsp;static&nbsp;block(s)&nbsp;→ Child&nbsp;static&nbsp;block(s)&nbsp;→
        Grandchild&nbsp;static&nbsp;block(s)&nbsp;→<br>Parent&nbsp;nonstatic&nbsp;block(s)&nbsp;→
        Parent&nbsp;constructor&nbsp;→<br>Child&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Child&nbsp;constructor&nbsp;→<br>
        Grandchild&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Grandchild&nbsp;constructor
    </p>
    <hr>
    <h3>Зачем нужны и какие бывают блоки инициализации?</h3>
    <p>
        Блоки инициализации представляют собой код, заключенный в фигурные скобки и
        размещаемый внутри класса вне объявления методов или конструкторов.
    </p>
    <p>Существуют статические и нестатические блоки инициализации.</p>
    <p class="main-mind">
        Блок инициализации выполняется перед инициализацией класса загрузчиком классов или
        созданием объекта класса с помощью конструктора.
    </p>
    <p> Несколько блоков инициализации выполняются в порядке следования в коде класса. </p>
    <p>
        Блок инициализации способен генерировать исключения, если их объявления перечислены в
        throws всех конструкторов класса.
    </p>
    <p>Блок инициализации возможно создать и в анонимном классе.</p>
    <div class="code">
        <p>class Dog {</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-1">private String poroda;</p>
        <p class="tab-1">private int age;</p>
        <p class="tab-1">{</p>
        <p class="tab-2">name = "Шарик";</p>
        <p class="tab-2">poroda = "овчарка";</p>
        <p class="tab-2">age = 2;</p>
        <p class="tab-1">}</p>
        <p class="tab-1">public Dog(String x, String y, int z){</p>
        <p class="tab-2">name = x;</p>
        <p class="tab-2">poroda = y;</p>
        <p class="tab-2">age = z;</p>
        <p class="tab-2">}</p>
        <p>}</p>
    </div>
    <hr>
    <h3>Для чего в Java используются статические блоки инициализации?</h3>
    <p>
        Статические блоки инициализация используются для выполнения кода, который должен
        выполняться <strong>один раз</strong> при инициализации класса загрузчиком классов,
        <strong>в момент предшествующий созданию</strong> объектов этого класса
        <strong>при помощи конструктора</strong>.
    </p>
    <p>
        Такой блок (в отличие от нестатических, принадлежащих конкретному
        объекту класса) принадлежит только самому классу (объекту метакласса Class).
    </p>
    <hr>
    <h3>Что произойдет, если в блоке инициализации возникнет исключительная ситуация?</h3>
    <p class="main-mind">
        Если блок статический – ExceptionInInitializerError,<br>
        Если нестатический – вылетит само исключение.
    </p>
    <p>
        Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
        образом требуется, чтобы объявления этих исключений были перечислены в throws всех
        конструкторов класса. Иначе будет ошибка компиляции.
    </p>
    <p>
        Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
    </p>
    <p>
        В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом
        другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и
        объект класса не будет создан, если ошибка возникает в нестатическом блоке.
    </p>
    <hr>
    <h3>Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</h3>
    <p class="no_mb">Если возникшее исключение - наследник RuntimeException:</p>
    <ul class="tab-2">
        <li>для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;</li>
        <li> для нестатических будет проброшено исключение-источник.</li>
    </ul>
    <p>
        Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено
        java.lang.Error. Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое
        исключение выброшено не будет.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q12">
    <h1><a href="#">OBJECT</a></h1>
    <p class="no_mb">Object это базовый класс для всех остальных объектов в Java.</p>
    <p class="main-mind">Любой класс наследуется от Object и, соответственно, наследуют его методы.</p>
    <h3>Методы класса Object</h3>
    <table class="list list--dictionary" aria-label="Методы класса Object">
        <thead>
        <tr>
            <th>Метод</th>
            <th>Описание</th>
        </tr>
        </thead>
        <tr>
            <td>equals()</td>
            <td>
                <p>Служит для сравнения объектов по значению; == по ссылке</p>
                <p class="code-word">public boolean equals(Object obj)</p>
            </td>
        </tr>
        <tr>
            <td>hashCode()</td>
            <td>
                <p>Возвращает hash код для объекта</p>
                <p class="code-word">int hashCode()</p>
            </td>
        </tr>
        <tr>
            <td>toString()</td>
            <td>
                <p>Возвращает строковое представление объекта</p>
                <p class="code-word">String toString()</p>
            </td>
        </tr>
        <tr>
            <td>getClass()</td>
            <td>
                <p>Возвращает класс объекта во время выполнения</p>
                <p class="code-word">Class getClass()</p>
            </td>
        </tr>
        <tr>
            <td>clone()</td>
            <td>
                <p>Создает и возвращает копию объекта</p>
                <p class="code-word">protected Object clone()</p>
            </td>
        </tr>
        <tr>
            <td>notify()</td>
            <td>
                <p>Возобновляет поток, ожидающий монитор</p>
                <p class="code-word">void notify()</p>
            </td>
        </tr>
        <tr>
            <td>notifyAll()</td>
            <td>
                <p>Возобновляет все потоки, ожидающие монитор</p>
                <p class="code-word">void notifyAll()</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или
                    notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait()</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод
                    notify() или notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait(long timeout)</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод
                    notify() или notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait(long timeout, int nanos)</p>
            </td>
        </tr>
        <tr>
            <td>finalize()</td>
            <td>
                <p>Может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
                <p class="code-word">protected void finalize()</p>
            </td>
        </tr>
    </table>
    <p>
        <a class="link-to-source"
           href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html"
           target="_blank">Документация по OBJECT (Java17)</a>
    </p>
    <hr>
    <h3>Equals и HashCode</h3>
    <h4>Какой контракт между hashCode() и equals()?</h4>
    <p class="no_mb"><strong>HashCode</strong> - Общий контракт:</p>
    <ul>
        <li>одно и то же число каждый раз когда объект не меняется;</li>
        <li>
            если два объекта равны через вызов equals(),
            то вызов у них hashCode() должен приводить к одному результату;
        </li>
        <li>если hashCode() у объектов разные, то объекты разные;</li>
    </ul>
    <p class="no_mb"><strong> Equals</strong> - Основные принципы:</p>
    <ol>
        <li>
            <p class="no_mb">Рефлексивность</p>
            <div class="code no_mb">
                <p>x.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Симметричность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Транзитивность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(z) = true</p>
                <p>x.equals(z) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Постоянство или Непротиворечивость</p>
            <div class="code no_mb">
                <p>Результат одно и то же число пока объект не изменится</p>
            </div>
            <p class="example">
                Для любых ссылок на значения х и у, если несколько раз вызвать
                х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться
                значение false при условии, что никакая информация, используемая при сравнении объектов, не
                поменялась.
            </p>
        </li>
        <li>
            <p class="no_mb">Если объекта нет - ложь</p>
            <div class="code no_mb">
                <p>x.equals(null) = false</p>
            </div>
            <p class="example">
                Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.
            </p>
        </li>
    </ol>

    <p class="no_mb">Метод equals() - определяет отношение эквивалентности объектов.</p>
    <p>
        При сравнение объектов с помощью <strong>== сравнение</strong> происходит лишь <strong>между ссылками</strong>.
        При сравнении по переопределённому разработчиком <strong>equals() - по внутреннему состоянию объектов</strong>.
    </p>
    <p class="example no_mb">Для чего нужен метод hashCode()?</p>
    <p>
        Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта.
    </p>
    <p>
        В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива
        произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта,
        хэш код всегда будет одинаковым.
    </p>
    <p class="example no_mb">
        Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
    </p>
    <p>
        Следует понимать, что в Java <strong>множество возможных хэш кодов ограничено типом int</strong>,
        а множество объектов ничем не ограничено.
    </p>
    <p class="no_mb">Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>
    <ul class="tab-2">
        <li>если хэш коды разные, то и объекты гарантированно разные;</li>
        <li>если хэш коды равны, то объекты могут необязательно равны.</li>
        <li>для одного и того-же объекта, хеш-код всегда будет одинаковым;</li>
        <li>если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот).</li>
    </ul>
    <p class="example no_mb">
        Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
    </p>
    <p>
        <strong>Общий совет:</strong> выбирать поля, которые с большой долью вероятности будут различаться. Для
        этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как
        id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(),
        то они должны быть задействованы и при выполнении equals().
    </p>
    <hr>
    <h3>Каким образом реализованы методы hashCode() и equals() в классе Object?</h3>
    <div class="code no_mb">
        <p>public boolean equals(Object obj) { return (this == obj);}</p>
        <p>public native int hashCode();</p>
    </div>
    <p class="example">
        native означает, что реализация данного метода выполнена на другом языке (здесь на C++) и
        обычно возвращает адрес объекта в памяти.
    </p>
    <hr>
    <h3>Зачем нужен equals(). Чем он отличается от операции ==?</h3>
    <p class="no_mb">Метод equals() - определяет отношение эквивалентности объектов.</p>
    <p>
        При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При
        сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов
    </p>
    <hr>
    <h3>Правила переопределения equals()</h3>
    <ul class="tab-2">
        <li>
            Использование оператора == для проверки, является ли аргумент ссылкой на указанный
            объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться
            false.
        </li>
        <li>
            Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли
            аргумент правильный тип. Если не имеет, возвращается false.
        </li>
        <li>
            Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой
            instanceof она гарантированно будет выполнена.
        </li>
        <li>
            <p>
                Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте
                и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу.
            </p>
            <p>
                Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.
            </p>
        </li>
        <li>
            По окончанию переопределения метода equals() следует проверить: является ли
            порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и
            непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.
        </li>
    </ul>
    <div class="code">
        <p>@Override</p>
        <p>public boolean equals(Object obj) {</p>
        <p class="tab-1">if (this == obj) // равен сам себе</p>
        <p class="tab-1">return true;</p>
        <p class="tab-1">if (obj == null) // не равен нулю</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">if (getClass() != obj.getClass()) // объекты одинакового класса</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">BlackBox other = (BlackBox) obj; // приведение</p>
        <p class="tab-1">if (varA != other.varA) // для конкретных переменных класса</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">if (varB != other.varB)</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">return true;</p>
        <p>}</p>
    </div>
    <hr>
    <h4>
        Что будет, если переопределить equals() не переопределяя hashCode()?
        Какие могут возникнуть проблемы?
    </h4>
    <p class="no_mb">Классы и методы, которые используют правила этого контракта могут работать некорректно.</p>
    <p class="no_mb">
        Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в нее
        помещена при использовании нового экземпляра ключа не будет в ней найдена.
    </p>
    <p>
        В HashSet при добавлении объект сначала сравнивается хэш добавляемого и существующие
        (быстрая проверка очень экономит время), если хэш разный – то дальше сравнивается по equals.
    </p>
    <hr>
    <h4>Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее
        чем x + y</h4>
    <p>
        Множитель создает зависимость значения хэш кода от очередности обработки полей, что в
        итоге порождает лучшую хэш функцию
    </p>
    <hr>
    <h4>Чем a.getClass().equals(A.class) отличается от a instanceOf A.class</h4>
    <p class="no_mb">Для equals всегда нужно сравнивать типы объектов через <span class="code-word">getClass</span>.</p>
    <p><span class="code-word">instanceof</span> не соблюдает правило симметрии в наследниках.</p>
    <div class="code">
        <p>my.equals(child) == true</p>
        <p>child.equals(my) == false // должно быть тру</p>
    </div>
    <p class="main-mind">
        Оператор <span class="code-word">instanceof</span> нужен, чтобы проверить, был ли объект, на который ссылается
        переменная X, создан на основе какого-либо класса Y. Оператор instanceof проверяет именно
        происхождение объекта, а не переменной.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q13">
    <h1><a href="#">this и super</a></h1>

    <hr>
    <div>
        <h3>Для чего используется ключевое слово this?</h3>
        <p>
            В Java, ключевое слово <span class="code-word">this</span> используется в качестве ссылки на текущий объект,
            внутри которого оно используется.
        </p>
        <p>
            Это слово может использоваться для ссылки на текущий класс экземпляр переменной, методы и конструкторы.
        </p>
    </div>

    <hr>
    <div>
        <h3>Как вызвать метод из родительского класса?</h3>
        <p>
            В Java вы можете вызвать метод родительского класса с помощью ключевого слова
            <span class="code-word">super</span>.
        </p>
        <p>
            Это ключевое слова используется для вызова конструктора родительского класса, а также для вызова метода
            родительского класса.
        </p>

        <p class="example">
            Вы можете использовать super для вызова любого метода, определенного в родительском классе.
            Если же метод не определен в родительском классе, вы получите ошибку компиляции.
        </p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q14">
    <h1><a href="#">Методы. Переопределение и перегрузка</a></h1>

    <hr>
    <div>
        <h3>Что такое статический метод?</h3>
        <p>
            Статический метод в Java — это метод, который <strong>принадлежит классу</strong>,
            а не экземпляру класса (объекту).
            Он может быть вызван без создания объекта класса.
        </p>
        <p>Статические методы объявляются с помощью ключевого слова static. </p>
        <p>Основные характеристики статических методов:</p>
        <ol>
            <li>Статический метод может быть вызван прямо из класса и не требует создания экземпляра класса.</li>
            <li>Статический метод может прямо обращаться только к статическим переменным и статическим методам.
                Он не может прямо обращаться к нестатическим членам (переменным и методам).
            </li>
            <li>Не могут быть переопределены (
                <a href="#q8">в прямом смысле это слова</a>
                ), но могут быть перегружены.
            </li>
        </ol>
    </div>

    <hr>
    <div>
        <h3>Что такое не статический метод?</h3>
        <p>
            Нестатический метод в Java, также известный как <strong>метод экземпляра</strong>,
            принадлежит конкретному объекту (экземпляру класса), а не классу в целом.
        </p>
        <p>Основные характеристики нестатических методов:</p>
        <ol>
            <li>Нестатический метод требует создания экземпляра класса для его вызова.</li>
            <li>Нестатический метод может прямо обращаться к любому другому члену класса (как статическому, так и
                нестатическому).
            </li>
            <li>Нестатические методы могут быть переопределены, если они не объявлены как final.</li>
        </ol>
    </div>

    <hr>
    <div>
        <h3>Что такое переопределение метода?</h3>
        <p>
            Переопределение метода (Method Overriding) в Java - это механизм, который позволяет дочернему классу
            предоставить свою собственную реализацию метода, уже определенного в родительском классе.
        </p>
        <p>
            Это важный аспект объектно-ориентированного программирования, так как он поддерживает принцип
            <a href="../oop/index.html#q7" target="_blank">полиморфизма</a>.
        </p>
        <p>
            Переопределенный метод в подклассе должен иметь ту же сигнатуру, что и метод в родительском классе.
            Это означает, что переопределенный метод должен иметь ту же имя, возвращаемый тип и параметры.
        </p>
        <p class="example">
            Аннотация @Override не является обязательной, но это хорошая практика использовать её при переопределении
            методов, так как это помогает быстрее выявить ошибки во время компиляции, если метод родительского класса не
            существует или имеет другую сигнатуру.
        </p>
    </div>

    <hr>
    <div>
        <h3>Что такое перегрузка метода?</h3>
        <p>
            Перегрузка метода (Method Overloading) - это возможность в языке программирования Java, которая позволяет
            классу иметь два или более метода с одинаковым именем, но разными параметрами.
        </p>

        <p>Важно помнить:</p>
        <ol>
            <li>Методы должны иметь одинаковое имя, но разные параметры (как по типу, так и по количеству).</li>
            <li>Перегруженные методы могут иметь разные модификаторы доступа (private, public, protected).</li>
            <li>
                Перегруженный метод может выбросить любое количество исключений, независимо от того, выбрасывают ли
                исключения оригинальные методы.
            </li>
            <li>Перегруженный метод может иметь разные возвращаемые типы.*</li>
        </ol>
        <h4 class="tab-1">*Можно ли изменить тип возвращаемых данных при перегрузке метода?</h4>
        <div class="tab-1">
            <p class="no_mb">
                Изменение <strong>только</strong> типа возвращаемых данных не достаточно для перегрузки метода в Java.
            </p>
            <p class="no_mb">
                Перегрузить метод путем изменения возвращаемого типа не допускается, если такое произойдет, будет
                выброшена
                ошибка при компиляции.
            </p>
            <p>Однако, если вы измените список параметров, то сможете успешно перегрузить метод.</p>
        </div>

    </div>

    <hr>
    <div>
        <h3>Можно ли переопределить статический метод?</h3>
        <p><strong>Нет, однако...</strong></p>
        <p>
            В Java статические методы не могут быть переопределены. Это связано с тем, что статические методы являются
            частью класса, а не экземпляра класса. Они принадлежат классу, в котором определены, и не могут быть
            переопределены в подклассе.
        </p>
        <p>
            Однако, статический метод может сокрыт в подклассе.
        </p>
    </div>

    <hr>
    <div>
        <h3>Что такое сокрытие метода?</h3>
        <p>
            Сокрытие метода в Java (Method Hiding) - это механизм, позволяющий подклассу предоставить
            свою собственную реализацию статического метода, уже определенного в родительском классе.
        </p>
        <p>
            Сокрытие метода в Java применяется только к статическим методам. Нестатические методы поддерживают
            переопределение, но не сокрытие.
        </p>
    </div>

    <hr>
    <div>
        <h3>Затенение и сокрытие метода. Чем отличаются?</h3>
        <p>
            Затенение метода (method overriding) и сокрытие метода (method hiding) - это разные понятия в Java.
        </p>
        <p class="no_mb">
            Затенение метода (Method Overriding): Это механизм, который позволяет подклассу предоставить реализацию
            метода, уже предоставленного в его суперклассе.
        </p>
        <p class="no_mb">Этот механизм используется для достижения полиморфизма времени выполнения.</p>
        <p>При затенении метода используется ключевое слово <span class="code-word">super</span>.</p>


        <p class="no_mb">
            Сокрытие метода (Method Hiding): Если суперкласс и подкласс имеют статические методы с одинаковым именем и
            параметрами, то метод в подклассе скрывает метод в суперклассе.
        </p>
        <p class="no_mb">Это известно как сокрытие метода.</p>
        <p>Важно помнить, что статические методы связаны с классом, а не с экземпляром.</p>


        <p>
            Так что, хотя оба термина относятся к тому, что метод в подклассе заменяет или скрывает метод в суперклассе,
            они используются в разных контекстах и имеют разные последствия.
        </p>
    </div>

    <hr>
    <h3>Может ли статический метод быть переопределён или перегружен?</h3>
    <p>
        Статические методы <strong>не могут быть переопределены</strong> в точном смысле слова, <strong>но они
        могут</strong>
        скрыть родительские статические методы (<strong>затирать</strong>).
    </p>
    <p>
        <strong>Да, могут быть перегружены.</strong> Мы можем иметь два или более статических метода с одинаковым
        именем, но с различиями во входных параметрах.
    </p>

    <hr>
    <h3>Могут ли нестатические методы перегрузить статические?</h3>
    <p><strong>Да</strong>, могут.</p>

    <hr>
    <h3>Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</h3>
    <p>
        При переопределении метода сужать модификатор доступа <strong>нельзя</strong>, т.к. это приведет
        к нарушению принципа подстановки Барбары Лисков.
        <strong>Расширение</strong> уровня доступа <strong>возможно</strong>.
    </p>
    <p>
        Изменять <strong>тип</strong> возвращаемого значения при переопределении метода разрешено
        <strong>только в сторону сужения</strong> типа (вместо родительского класса - наследника).
    </p>
    <p>
        При <strong>изменении типа, количества, порядка</strong> следования аргументов
        <strong>вместо переопределения</strong>
        будет происходить <strong>overloading (перегрузка)</strong> метода.
    </p>
    <p class="no_mb">
        Секцию <strong>throws</strong> метода можно не указывать, но стоит помнить, что она остаётся
        действительной, если уже определена у метода родительского класса.
    </p>
    <p class="no_mb">
        Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения
        RuntimeException.
    </p>
    <p>Порядок следования таких элементов при переопределении значения не имеет.</p>

    <hr>
    <div>
        <h3>Что такое виртуальная функция и используются ли они в Java?</h3>
        <p class="term no_mb">
            <span>Виртуальная функция</span> - это термин, который используется в некоторых языках программирования,
            для обозначения метода, который может быть переопределен в производном классе.
        </p>
        <p class="example">
            В C++, например, виртуальные функции позволяют достичь "позднего связывания" или "динамического связывания",
            что является ключевой составляющей полиморфизма.
        </p>
        <p class="no_mb">
            Однако в Java все не-статические и не-финальные методы по умолчанию являются "виртуальными" в том смысле,
            что они могут быть переопределены в подклассах.
        </p>
        <p>
            Таким образом, в Java нет необходимости (и даже возможности) явно
            обозначать методы как "виртуальные" - это поведение является стандартным.
        </p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../datatypes/">Типы данных</a>
    <a class="navi-button navi--next" href="../exceptions/">Исключения</a>
</div>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

</body>

</html>