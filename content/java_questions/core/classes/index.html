<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Classes</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Классы JAVA</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>Classes</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Из чего состоит класс. Какие виды классов есть в java?</a></li>
        <li><a href="#q2">Что такое вложенный класс</a></li>
        <li><a href="#q3">Что такое локальный класс?</a></li>
        <li><a href="#q4">Что такое анонимные классы?</a></li>
        <li><a href="#q5">Что такое перечисления (enum)?</a></li>
        <li><a href="#q6">Что такое конструктор?</a></li>
        <li><a href="#q7">Модификаторы доступа</a></li>
        <li><a href="#q8">Использование модификаторов</a></li>
        <li><a href="#q9">Абстрактные классы</a></li>
        <li><a href="#q10">Интерфейсы</a></li>
        <li><a href="#q11">Порядок вызова конструкторов</a></li>
        <li><a href="#object">Object и его методы</a></li>
        <li><a href="#equals_hashcode">equals и hashCode</a></li>
        <li><a href="#q13">this и super</a></li>
        <li><a href="#q14">Методы. Переопределение и перегрузка</a></li>
        <li><a href="#q15">Effectively final</a></li>
        <li><a href="#q16">Record</a></li>
        <li><a href="#q17">VARARGS</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1><a href="#">Из чего состоит класс.<br>Какие виды классов есть в JAVA?</a></h1>
    <div>
        <h3>КЛАСС</h3>
        <h4>Класс в Java состоит из следующих элементов:</h4>
        <ol class="margined">
            <li class="definition">
                <span>Имя класса (Class Name):</span>
                <br>Имя, по которому класс можно идентифицировать.<br>Имя класса должно быть уникальным.
            </li>
            <li class="definition">
                <span>Поля (Fields):</span>
                <br>Это переменные, которые представляют данные или состояние объекта.
                <p class="example">
                    Они могут быть разных типов, таких как int, String, custom types и так далее.
                </p>
            </li>
            <li class="definition">
                <span><a href="#q6">Конструкторы (Constructors)</a>:</span>
                <br>Это специальные методы, которые вызываются при создании объекта класса.
                <br>Имя конструктора должно совпадать с именем класса.
                <br>Они используются для инициализации полей класса.
            </li>
            <li class="definition">
                <span><a href="#q14">Методы (Methods):</a></span>
                <br>Методы представляют действия, которые может выполнять объект.
                <br>Методы определяют поведение класса.
                <br>Они могут принимать параметры и могут возвращать значения.
            </li>
            <li class="definition">
                <span>Вложенные классы и интерфейсы (Nested classes & interfaces):</span>
                <br>Класс может содержать другие классы и интерфейсы.
            </li>
            <li class="definition">
                <span>Блоки инициализации (Initialization blocks):</span>
                <br>Это блоки кода, которые выполняются при создании объекта класса.
                <br>Они могут быть статическими (выполняются при загрузке класса) или нестатическими (выполняются перед
                каждым
                вызовом конструктора).
            </li>
            <li class="definition">
                <span>Модификаторы класса (Class Modifiers):</span>
                <br>Это <a href="#q7">ключевые слова</a>, которые определяют свойства класса, такие как public,
            </li>
        </ol>
    </div>

    <hr>
    <div>
        <h3>Виды классов</h3>
        <ul>
            <li>
                <p><span class="accent-mono">Top level class</span> (Обычный класс):</p>
                <ul class="dash-style">
                    <li>Abstract class (Абстрактный класс);</li>
                    <li>Final class (Финализированный класс).</li>
                </ul>
            </li>
            <li class="mb10"><span class="accent-mono">Interfaces</span> (Интерфейс).</li>
            <li class="mb10"><span class="accent-mono">Enum</span> (Перечисление).</li>
            <li>
                <p><span class="accent-mono">Nested class</span> (Вложенный класс):</p>
                <ul class="dash-style">
                    <li>Static nested class (Статический вложенный класс);</li>
                    <li>Member inner class (Простой внутренний класс);</li>
                    <li>Local inner class (Локальный класс);</li>
                    <li>Anonymous inner class (Анонимный вложенный класс).</li>
                </ul>
            </li>
        </ul>
        <p>К классам верхнего уровня модификатор static неприменим.</p>
    </div>

</section>

<section class="container" id="q2">
    <div>
        <h1><a href="#">Расскажите про вложенные классы.<br>В каких случаях они применяются?</a></h1>
        <p class="main-mind">
            Класс называется вложенным (Nested class), если он определен внутри другого класса.
        </p>
        <p class="no_mb">
            Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его
            класс.
        </p>
        <p>
            Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен
            стать классом верхнего уровня.
        </p>
        <p>
            Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не
            наоборот.
            Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.
        </p>
        <p>Существуют четыре категории вложенных классов:</p>
        <ul class="tab-3 margined">
            <li>
                <p class="term">
                    <span><a href="#static_nested_class">Static nested class</a></span>
                    (Статический вложенный класс)
                    <br>Это статические члены внешнего класса,
                    поэтому они могут существовать без экземпляра внешнего класса.
                </p>
            </li>
            <li>
                <p class="term">
                    <span>Member inner class</span>
                    (Простой внутренний класс)
                    <br>Это нестатические классы, объявленные внутри другого класса.
                    <br>Они имеют доступ до всех членов внешнего класса, включая приватные.
                </p>
            </li>
            <li>
                <p class="term">
                    <span><a href="#q3">Local inner class</a></span>
                    (Локальный класс)
                    <br>Это классы, объявленные внутри блока кода, обычно в методе.
                </p>
            </li>
            <li>
                <p class="term">
                    <span> <a href="#q4">Anonymous inner class</a></span>
                    (Анонимный класс)
                    <br>Это специальный тип локальных классов, которые не имеют имени.
                </p>
            </li>
        </ul>
        <p>
            Категории классов, за исключением первого, также называют
            <span class="bold">внутренними (Inner class)</span>.
        </p>
        <p class="mb20">Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>
        <div style="overflow: auto">
            <table class="list list--content-text-small" style="overflow: auto" aria-label="Inner Classes">
                <colgroup>
                    <col style="width: 20%">
                    <col style="width: 20%">
                    <col style="width: 20%">
                    <col style="width: 20%">
                    <col style="width: 20%">
                </colgroup>
                <thead>
                <tr>
                    <th></th>
                    <th>Static nested class</th>
                    <th>Member inner class</th>
                    <th>Local inner class</th>
                    <th>Anonymous inner class</th>
                <tr>
                </thead>
                <tr>
                    <td>Из него видны:</td>
                    <td>
                        <p class="bold">Из него (самого класса) видны:</p>
                        <p>- статические свойства и методы OuterClassа (даже private).</p>
                        <p>- статические свойства и методы родителя OuterClassа public и protected.
                            <br>То есть те, которые видны в OuterClassе.</p>
                        <p class="bold">Из его экземпляра видны:</p>
                        <p>- все (даже private) свойства и методы OuterClassа обычные и статические.</p>
                        <p>- public и protected свойства и методы родителя OuterClassа обычные и статические.
                            <br>То есть те, которые видны в OuterClassе.</p>
                    </td>
                    <td>
                        <p>- все (даже private) свойства и методы OuterClassа обычные и статические.</p>
                        <p>- public и protected свойства и методы родителя OuterClassа обычные и статические.
                            <br>То есть те, которые видны в OuterClassе.</p>
                    </td>
                    <td>
                        <p>- все (даже private) свойства и методы OuterClassа обычные и статические.</p>
                        <p>- public и protected свойства и методы родителя OuterClassа обычные и статические.
                            То есть те, которые видны в OuterClassе.</p>
                    </td>
                    <td>
                        <p>- все (даже private) свойства и методы OuterClassа обычные и статические.</p>
                        <p>- public и protected свойства и методы родителя OuterClassа обычные и статические.
                            <br>То есть те, которые видны в OuterClassе.</p>
                    </td>
                </tr>
                <tr>
                    <td>Его видно:</td>
                    <td>- согласно модификатору доступа.</td>
                    <td>- согласно модификатору доступа.</td>
                    <td>- только в том методе где он определён.</td>
                    <td>- только в том методе где он определён.</td>
                </tr>
                <tr>
                    <td>Может наследовать:</td>
                    <td>
                        <p>- обычные классы.</p>
                        <p>- такие же статические внутренние классы в OuterClassе и его предках.</p>
                    </td>
                    <td>
                        <p>- обычные классы.</p>
                        <p>- такие же внутренние классы в OuterClassе и его предках.</p>
                    </td>
                    <td>
                        <p>- обычные классы.</p>
                        <p>- внутренние классы в OuterClassе и его предках.</p>
                        <p>- такие же локальные классы определённые в том же методе.</p>
                    </td>
                    <td class="bold">Не может наследовать</td>
                </tr>
                <tr>
                    <td>Может быть наследован:</td>
                    <td>
                        <p>- любым классом:</p>
                        <p>- вложенным</p>
                        <p>- не вложенным</p>
                        <p>- статическим</p>
                        <p>- не статическим!</p>
                    </td>
                    <td>- таким же внутренним классом в OuterClassе и его наследниках.</td>
                    <td>- таким же локальным классом определённом в том же методе.</td>
                    <td class="bold">Не может быть наследован</td>
                </tr>
                <tr>
                    <td>Может имплементировать интерфейс</td>
                    <td>ДА</td>
                    <td>ДА</td>
                    <td>ДА</td>
                    <td class="bold">НЕТ</td>
                </tr>
                <tr>
                    <td>Может содержать:</td>
                    <td>
                        <p>- статические свойства и методы.</p>
                        <p>- не статические свойства и методы.</p>
                    </td>
                    <td>- только обычные свойства и методы (не статические).</td>
                    <td>- только обычные свойства и методы (не статические).</td>
                    <td>- только обычные свойства и методы (не статические).</td>
                </tr>
            </table>
        </div>
        <div>
            <h4>Рекомендации к применению:</h4>
            <ul class="margined">
                <li>
                    <span class="bold">Cтатический</span>:
                    если вложенный класс должен быть виден за пределами одного метода или
                    он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода
                    и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр.
                </li>
                <li>
                    <span class="bold">Нестатический</span>:
                    если ссылка на обрамляющий класс не требуется. Доступ к полям стат. и нестат. класса.
                </li>
                <li>
                    <span class="bold">Локальный</span>:
                    если класс необходим только внутри какого-то метода и требуется создавать
                    экземпляры этого класса только в этом методе.
                </li>
                <li>
                    <span class="bold">Анонимный</span>:
                    если к тому же применение класса сводится к использованию лишь в одном
                    месте и уже существует тип, характеризующий этот класс.
                </li>
            </ul>
        </div>
        <div>
            <h4>Лапша на тему использования:</h4>
            <p>Вложенные классы используются для различных целей:</p>
            <ul class="dash-style margined">
                <li class="term">
                    <span>Логическая группировка классов</span>:
                    Если класс полезен только для одного другого класса, то имеет смысл держать его в этом классе в
                    качестве вложенного. Это помогает в упаковке классов, которые логически связаны вместе, и
                    повышает инкапсуляцию.
                </li>
                <li class="term">
                    <span>Повышение инкапсуляции</span>:
                    Вложенные классы могут получить доступ ко всем членам, включая приватные члены, внешних классов.
                    Это помогает внешнему классу скрыть его внутренние детали от внешнего мира.
                </li>
                <li class="term">
                    <span>Повышение читаемости и поддерживаемости кода</span>:
                    Вложенные классы держат код более организованным и читаемым.
                </li>
            </ul>
        </div>

    </div>

    <hr>
    <div id="static_nested_class">
        <h3>Статический вложенный класc</h3>
        <div>
            <p>
                Статический вложенный класс в Java - это статический член внешнего класса, который может существовать
                независимо от экземпляра внешнего класса.
                <br>Они объявляются внутри другого класса и используют модификатор
                <span class="code-word">static</span>.
            </p>
            <div>
                <p>Статические вложенные классы применяются, когда:</p>
                <ol class="margined">
                    <li>
                        Вы хотите связать два класса вместе, но вложенный класс должен быть независим от внешнего
                        класса: в этом случае он не имеет доступа к нестатическим членам внешнего класса, если не создан
                        экземпляр внешнего класса.
                    </li>
                    <li>
                        Вам нужен класс, который будет использоваться только в одном месте. В этом случае его логично
                        объявить внутри другого класса, чтобы не засорять пространство имен.
                    </li>
                    <li>
                        Вам нужен утилитарный класс, который не должен иметь своих экземпляров.
                    </li>
                </ol>
            </div>
        </div>
    </div>

    <hr>
    <div>
        <h3>Сколько объектов статического вложенного класса можно создать в программе?</h3>
        <div>
            <p>
                Так как статический вложенный класс не требует экземпляра внешнего класса для его создания, вы можете
                создать столько экземпляров статического вложенного класса,
                <strong>сколько вам нужно</strong> или сколько позволяет память вашей системы.
            </p>
        </div>
    </div>


    <hr>
    <div>
        <h3>Каким образом из вложенного класса получить доступ к полю внешнего класса?</h3>
        <p class="no_mb">Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего
            класса.</p>
        <p class="no_mb">
            Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В
            случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к
            такому полю следует через ссылку на его экземпляр.
        </p>
        <p class="example">Например: Outer.this.field.</p>
    </div>

    <p>
        Можно почитать:
        <a href="https://habr.com/ru/articles/342090/" target="_blank">Вложенные классы в Java</a>
    </p>

</section>

<section class="container" id="q3">
    <h1><a href="#">Что такое локальный класс?<br>Каковы его особенности?</a></h1>
    <div>
        <p class="main-mind">
            Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован
            в любом блоке, в котором разрешается декларировать переменные.
        </p>
        <p>
            Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться
            многократно.
        </p>
        <p>
            Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в
            нестатическом контексте.
        </p>
        <div>
            <h4 class="no_mb">Локальные классы имеют следующие особенности:</h4>
            <ul>
                <li>Видны только в пределах блока, в котором объявлены;</li>
                <li>Не могут быть объявлены как private/public/protected или static;</li>
                <li>Не могут иметь внутри себя статических объявлений (полей, методов, классов);</li>
                <li>Имеют доступ к полям и методам обрамляющего класса;</li>
                <li>
                    Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором
                    final или effectively&nbsp;final.
                </li>
            </ul>
        </div>
        <div>
            <h4>Локальные классы обычно используются в следующих случаях:</h4>
            <ol class="margined">
                <li class="term">
                    <span>Когда класс связан с одним методом</span>:
                    <br>Если класс нужен только в одном методе, его можно объявить внутри этого метода. Это делает код
                    более
                    читаемым и поддерживаемым.
                </li>
                <li class="term">
                    <span>Когда класс необходим для поддержки операций, специфичных для метода</span>:
                    <br>Если вам нужно выполнить сложную операцию, которая лучше всего реализуется с использованием
                    класса,
                    но эта операция не имеет отношения к остальной части программы, тогда локальный класс может быть
                    подходящим решением.
                </li>
                <li class="term">
                    <span>Когда требуется скрыть класс от остальной части программы</span>:
                    <br>Поскольку локальные классы не видны за пределами метода, в котором они объявлены, они являются
                    полезным инструментом инкапсуляции.
                </li>
            </ol>
        </div>
    </div>
</section>

<section class="container" id="q4">
    <h1><a href="#">Что такое анонимные классы?<br>Где они применяются?</a></h1>
    <p class="main-mind">
        Это вложенный локальный класс без имени, который разрешено декларировать в любом месте
        обрамляющего класса, разрешающем размещение выражений.
    </p>
    <p>
        Создание экземпляра анонимного класса происходит одновременно с его объявлением.
    </p>
    <p>
        В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный
        класс - в нестатическом контексте появляется окружающий его экземпляр.
    </p>
    <h4 class="no_mb">Анонимные классы имеют несколько ограничений:</h4>
    <ul>
        <li>Их использование разрешено только в одном месте программы - месте его создания;</li>
        <li>
            Применение возможно только в том случае, если после порождения экземпляра нет
            необходимости на него ссылаться;
        </li>
        <li>
            Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов,
            так как для доступа к ним нет поименованного типа.
        </li>
    </ul>

    <h4 class="no_mb">Анонимные классы обычно применяются для:</h4>
    <ul>
        <li>создания объекта функции (function object), например реализация интерфейса Comparator;</li>
        <li>создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;</li>
        <li>в статическом методе генерации;</li>
        <li>
            инициализации открытого статического поля final, которое соответствует сложному
            перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный.
        </li>
    </ul>

    <hr>
    <div>
        <h3>Сколько объектов анонимного класса можно создать в программе?</h3>
        <div>
            <p>Если речь об объектах разных классов - сколько позволяет память вашей системы.</p>
            <p>
                Если об экземплярах конкретного класса, то каждое объявление анонимного класса ведет к созданию нового
                класса во время компиляции. т.е. один.
            </p>
        </div>
    </div>

</section>

<section class="container" id="q5">
    <h1><a href="#">Что такое перечисления (enum)?</a></h1>
    <p class="main-mind">
        Перечисления представляют набор логически связанных констант.
    </p>
    <p>
        Объявление перечисления происходит с помощью оператора <span class="code-word">enum</span>,
        после которого идет название перечисления. Затем идет список элементов перечисления через запятую.
    </p>
    <p>Каждый из них явно объявлен как открытый статический финальный член класса.</p>

    <h4 class="no_mb">Особенности Enum классов:</h4>
    <ul class="tab-2">
        <li>Конструктор всегда private или default</li>
        <li>Могут имплементировать интерфейсы</li>
        <li>Не могут наследовать класс</li>
        <li>Можем переопределить toString()</li>
        <li>Нет public конструктора, поэтому нельзя создать экземпляр вне Enum</li>
        <li>При equals() выполняется ==</li>
        <li>values() возвращает все элементы</li>
        <li>ordinal() возвращает порядок элементов</li>
        <li>Может использоваться в TreeSet и TreeMap т.к. Enum имплементирует Comparable</li>
        <li>compareTo() имитирует порядок элементов предоставляемый ordinal()</li>
        <li>Можно использовать в Switch Case</li>
        <li>Легко создать потокобезопасный синглтон без double check volatile переменных.</li>
    </ul>

</section>

<section class="container" id="q6">
    <h1><a href="#">Конструкторы</a></h1>
    <p class="main-mind">
        Это специальные методы, которые вызываются при создании объекта класса.
        <br>Имя конструктора должно совпадать с именем класса.
        <br>Они используются для инициализации полей класса.
    </p>

    <h3>Что такое конструктор по умолчанию?</h3>
    <p>
        Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так
        называемый «конструктор по умолчанию».
    </p>
    <p>
        Если вы создали конструктор с аргументами, то конструктор по умолчанию использоваться не будет (если он не
        создан).
    </p>
    <h3>Могут ли быть приватные конструкторы? Для&nbsp;чего&nbsp;они&nbsp;нужны?</h3>
    <p>
        Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим
        методом генерации объектов данного класса.
    </p>
    <p> Также доступ к нему разрешен вложенным классам и может использоваться для их нужд.</p>
    <p>
        Запрещает создание экземпляра класса вне методов самого класса, например, чтобы гарантировать существование
        только одного объекта определённого класса, предположим какого-то ресурса, например БД.
    </p>
    <h3>Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами? </h3>
    <p class="no_mb">У конструктора по умолчанию отсутствуют какие-либо аргументы.</p>
    <p class="no_mb">
        Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания
        его клона.
    </p>
    <p>
        Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для
        инициализации полей класса).
    </p>
    <h3>Можно ли наследовать конструктор?</h3>
    <p>
        В Java конструкторы не наследуются, и поэтому они не могут быть переопределены в подклассах. Однако, подкласс
        может вызывать конструктор суперкласса с помощью ключевого слова super.
    </p>
    <h3>Что такое перегрузка конструктора?</h3>
    <div>
        <p>
            Перегрузка конструктора в Java это механизм, который позволяет классу иметь более одного конструктора, но с
            различными параметрами.
        </p>
        <p>
            Перегруженные конструкторы отличаются друг от друга по числу параметров или по типу параметров. Компилятор
            Java использует эти различия для определения, какой из конструкторов следует вызывать при создании объекта.
        </p>
        <p>
            Основной целью перегрузки конструктора является увеличение гибкости при создании объектов класса.
        </p>
    </div>

</section>

<section class="container" id="q7">
    <h1><a href="#">Какие модификаторы доступа есть в Java?</a></h1>
    <h3>Модификаторы доступа</h3>
    <p><span class="bold">private</span>(приватный): члены класса доступны только внутри класса.</p>
    <p>
        <span class="bold">default, package-private, package level</span>
        (доступ на уровне пакета): видимость класса/членов класса только внутри пакета.
        Является модификатором доступа по умолчанию.
    </p>
    <p><span class="bold">protected</span>(защищённый): члены класса доступны внутри пакета и в наследниках.</p>
    <p><span class="bold">public</span> (публичный): класс/члены класса доступны всем.</p>

    <p>
        Во время наследования возможно изменения модификаторов доступа в сторону большей
        видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
    </p>

    <table class="list list--dictionary list--content-center" aria-label="Access modifiers">
        <colgroup>
            <col style="width: 20%">
            <col style="width: 20%">
            <col style="width: 20%">
            <col style="width: 20%">
            <col style="width: 20%">
        </colgroup>
        <thead>
        <tr>
            <th>Ключевое слово</th>
            <th>Класс</th>
            <th>Пакет</th>
            <th>Наследник</th>
            <th>Все</th>
        </tr>
        </thead>
        <tr>
            <td>private</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>-</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>protected</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="bad bold">NO</td>
        </tr>
        <tr>
            <td>public</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
            <td class="good bold">YES</td>
        </tr>
    </table>

    <h3>Модификатор static</h3>
    <p class="no_mb"> Модификатор, применяемый к полю, блоку, методу, внутреннему классу. </p>
    <p>Данный модификатор указывает на привязку субъекта к текущему классу.</p>

    <h3>Модификатор final</h3>
    <p class="no_mb">
        Модификатор final может применяться к переменным, параметрам методов, полям и методам
        класса или самим классам.
    </p>
    <ul class="tab-2">
        <li>Класс не может иметь наследников;</li>
        <li>Метод не может быть переопределен в классах наследниках;</li>
        <li>Поле не может изменить свое значение после инициализации;</li>
        <li>Параметры методов не могут изменять своё значение внутри метода;</li>
        <li>Локальные переменные не могут быть изменены после присвоения им значения.</li>
    </ul>

</section>

<section class="container" id="q8">
    <h1><a href="#">Использование модификаторов</a></h1>

    <hr>
    <h3>Могут ли классы быть статическими?</h3>
    <p><strong>Да</strong></p>
    <p>Объект статического класса не хранит ссылку на конкретный экземпляр внешнего класса.</p>
    <p>Объект статического вложенного класса вполне может существовать сам по себе.</p>
    <p>Статический вложенный класс может обращаться только к статическим полям и методам внешнего класса.</p>
    <p>
        Объекты статического класса не содержат ссылок на объекты внешнего класса.
        А самих объектов мы можем создать сколько угодно.
    </p>

</section>

<section class="container" id="q9">
    <h1><a href="#">Абстрактные классы</a></h1>
    <div class="after-h1 tab-2">
        <p><a href="#abstract_class">Что такое абстрактные классы?</a></p>
        <p><a href="#abstract_wo_method">Может ли быть абстрактный класс без абстрактных методов?</a></p>
        <p><a href="#abstract_constructor">Могут ли быть конструкторы у абстрактных классов?</a></p>
        <p><a href="#abstract_vol_method">Сколько абстрактных методов должен и может содержать абстрактный
            класс?</a></p>
        <p><a href="#abstract_method">Может ли абстрактный класс содержать обычные методы?</a></p>
        <p><a href="#abstract_element">Сколько объектов абстрактного класса можно создать в программе?</a></p>
        <p><a href="#abstract_to_abstract">Что нужно делать, если наследник абстрактного класса не
            переопределяет все абстрактные методы родителя?</a></p>
        <p><a href="#interface_vs_abstract">Чем отличается интерфейс от абстрактного класса?</a></p>
    </div>

    <div id="abstract_class">
        <h3>Что такое абстрактные классы?<br>Чем они отличаются от обычных?</h3>
        <div>
            <p class="term no_mb">
                <span>Абстрактные классы</span> в Java - это классы, которые не могут быть инстанцированы.
            </p>
            <p class="example ">т.е., вы не можете создать объекты таких классов напрямую)</p>
            <p class="main-mind">
                Создавать экземпляры самого абстрактного класса не разрешается.
            </p>
            <p>
                Они обычно используются как базовые классы для других классов
                и могут выступать <strong>только&nbsp;предками</strong> для других классов.
            </p>
            <p> Для обозначения используется модификатор <span class="code-word">abstract</span>. </p>
            <p>
                Абстрактные классы могут содержать как абстрактные методы, так и не абстрактные методы.
            </p>
            <div class="tab-1">
                <p class="term no_mb">
                    - <span>Абстрактные методы</span>
                    - это методы, которые объявлены, но не реализованы в абстрактном классе.
                </p>
                <p class="example no_mb">
                    Вместо того, чтобы предоставлять реализацию,
                    абстрактные методы обычно заканчиваются точкой с запятой.
                </p>
                <p class="example">Пример: abstract void move();</p>
                <p class="term">
                    - <span>Не абстрактные методы</span>
                    (или конкретные методы) в абстрактных классах реализуются как обычно.
                </p>
            </div>
            <p>
                При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы,
                допускающие создание объектов, т.е. классы в которых реализованы все методы.
            </p>
            <p class="main-mind">
                Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен
                абстрактным.
            </p>
            <p>
                Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть
                реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
            </p>
            <h4 class="no_mb">Особенности абстрактных классов:</h4>
            <ul class="tab-2">
                <li>Может быть конструктор (для вызовов по цепочке из наследников)</li>
                <li>Имплементят интерфейсы, но не обязаны реализовывать их методы</li>
                <li>Не могут быть final</li>
                <li>Могут содержать static методы</li>
                <li>Нельзя создать объект</li>
                <li>Абстрактные методы могут отсутствовать</li>
                <li>Может содержать метод main()</li>
                <li>Классы-наследники не обязаны реализовывать все абстрактные методы</li>
            </ul>
        </div>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_wo_method">
        <h3>Может ли быть абстрактный класс без абстрактных методов?</h3>
        <p>Да</p>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_constructor">
        <h3>Могут ли быть конструкторы у абстрактных классов? Для&nbsp;чего&nbsp;они&nbsp;нужны?</h3>
        <p>Да, может быть конструктор (для вызовов по цепочке из наследников).</p>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_vol_method">
        <h3>Сколько абстрактных методов должен и может содержать абстрактный класс?</h3>
        <div>
            <p>
                Абстрактный класс в Java может содержать <strong>от нуля и более</strong> абстрактных методов.
            </p>
            <p>
                Однако, даже если абстрактный класс не содержит ни одного абстрактного метода,
                он все равно не может быть инстанциирован.
            </p>
            <p>
                Ключевое слово <span class="code-word">abstract</span>
                при объявлении класса говорит о том, что класс предназначен для наследования и не подразумевает его
                прямого использования.
            </p>
            <p class="no_mb">
                В то же время не существует верхнего предела для количества абстрактных методов, которые может содержать
                абстрактный класс.
            </p>
            <p class="example">
                Вы можете иметь столько абстрактных методов, сколько вам нужно, в зависимости от того,
                какая структура и поведение у вас есть в вашем приложении.
            </p>
            <p>
                Но важно помнить, что все абстрактные методы, объявленные в абстрактном классе, должны быть реализованы
                в любом конкретном (неабстрактном) наследнике этого абстрактного класса. Если какие-то методы не
                реализованы, то этот наследник также должен быть объявлен как абстрактный.
            </p>
        </div>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_method">
        <h3>Может ли абстрактный класс содержать обычные методы?</h3>
        <div>
            <p>
                <strong>Да</strong>,
                абстрактный класс в Java может содержать обычные методы.
                <br>Это одна из особенностей абстрактных классов.
            </p>
            <p class="term">
                <span>Обычные методы</span> в абстрактном классе - это методы, которые имеют реализацию (т.е. они не
                являются абстрактными).
                <br>Эти методы могут быть вызваны напрямую из любого наследника этого абстрактного класса.
                <br>Это позволяет разработчикам предоставить общую функциональность для всех наследников,
                которую можно переопределить при необходимости.
            </p>
            <p>
                Важно помнить, что, несмотря на наличие обычных методов, абстрактные классы по-прежнему не могут быть
                инстанцированы. Они могут только быть расширены другими классами.
            </p>
        </div>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_element">
        <h3>Сколько объектов абстрактного класса можно создать в программе?</h3>
        <div>
            <p>
                <strong>Ни одного</strong>. Невозможно создать объект абстрактного класса в Java.
            </p>
            <p>
                Абстрактные классы в Java предназначены для того, чтобы быть унаследованными другими классами, а не для
                создания объектов напрямую. Если вы попытаетесь создать объект абстрактного класса, компилятор Java
                выдаст ошибку.
            </p>
            <p>
                Однако, вы можете иметь ссылку на абстрактный класс, которая указывает на объект подкласса. Это полезно,
                когда вы хотите использовать полиморфизм, где ссылка на родительский класс (в данном случае абстрактный
                класс) может быть использована для ссылки на объект любого его насделника.
                <br>Но прямого создания объекта абстрактного класса не может быть.
            </p>
        </div>
        <a class="button button--content_list" href="#q9"></a>
    </div>

    <hr>
    <div id="abstract_to_abstract">
        <h3>Что нужно делать, если наследник абстрактного класса не
            переопределяет все абстрактные методы родителя?</h3>
        <div>
            <p>
                Если наследник абстрактного класса не переопределяет все абстрактные методы родителя, то этот наследник
                также <strong>должен быть объявлен как абстрактный</strong>.
            </p>
            <p>
                В противном случае, компилятор Java выдаст ошибку, так как любой конкретный (не абстрактный) класс,
                который расширяет абстрактный класс, должен предоставить реализацию для всех абстрактных методов
                родителя.
            </p>
            <p>
                Объявление наследника как абстрактного означает, что он не может быть инстанциирован напрямую и должен
                быть расширен другим классом, который предоставит реализации для оставшихся абстрактных методов.
            </p>
            <p>
                Это позволяет вам создавать иерархии классов, где некоторые аспекты поведения определяются на более
                высоком уровне, но конкретные реализации предоставляются на более низком уровне.
            </p>
        </div>
        <a class="button button--content_list" href="#q9"></a>
    </div>

</section>

<section class="container" id="q10">
    <h1><a href="#">Интерфейсы</a></h1>
    <div class="after-h1 tab-2">
        <p><a href="#interface">Что такое интерфейсы?</a></p>
        <p><a href="#interface_element">Можно ли создать объект интерфейса?</a></p>
        <p><a href="#interface_field_modifier">Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</a></p>
        <p><a href="#interface_static_method">Что такое static метод интерфейса?</a></p>
        <p><a href="#interface_default_method">Что такое дефолтные методы интерфейсов?</a></p>
        <p><a href="#interface_impl_method">Может ли интерфейс содержать какие-либо методы с реализацией?</a></p>
        <p><a href="#interface_vs_abstract">Чем интерфейсы отличаются от абстрактных классов?</a></p>
        <p><a href="#interface_inheritance">Может ли один интерфейс наследоваться от другого?</a></p>
        <p><a href="#interface_diamond_problem">Проблема ромбовидного наследования</a></p>
    </div>

    <div id="interface">
        <h3>Что такое интерфейсы?</h3>
        <div>
            <p>
                Ключевое слово <span class="code-word">interface</span> используется для создания полностью абстрактных
                классов.
            </p>
            <p class="main-mind">
                Основное предназначение интерфейса - определять каким образом мы можем использовать класс,
                который его реализует.
            </p>
            <p>Интерфейс в Java может содержать следующие элементы:</p>
            <ol class="margined">
                <li>
                    <p><span class="term">Методы:</span> Интерфейс может объявлять любое количество методов.</p>
                    <p>Все методы в интерфейсе по умолчанию являются публичными и абстрактными.</p>
                    <p class="example">
                        Т.е. определяются имена методов, списки аргументов и типы возвращаемых значений, но не
                        реализуется
                        их
                        поведение. Все методы неявно объявляются как public.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="term">Константы:</span>
                        Интерфейс может содержать переменные, которые по умолчанию являются
                        <strong>public</strong>, <strong>static</strong> и <strong>final</strong>.
                    </p>
                    <p class="example">Т.е. по факту это константы.</p>
                </li>
                <li>
                    <p>
                        <span class="term">Вложенные типы:</span>
                        Интерфейс может содержать вложенные интерфейсы, классы и перечисления.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="term">Методы по умолчанию:</span>
                        Начиная с Java 8, интерфейсы могут содержать методы по умолчанию (default), которые
                        предоставляют их
                        реализацию. Методы по умолчанию помогают в расширении интерфейсов без опасения нарушения
                        существующих
                        классов, которые уже реализуют эти интерфейсы.
                    </p>
                </li>
                <li>
                    <p>
                        <span class="term">Статические методы:</span>
                        Также, начиная с Java 8, интерфейс может содержать статические методы.
                    </p>
                </li>
                <li>
                    <p><span class="term">Частные (приватные) методы:</span>
                        Начиная с Java 9, интерфейсы могут содержать частные (приватные) методы, которые могут быть
                        использованы
                        для повторного использования общего кода между методами.
                    </p>
                </li>
            </ol>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_element">
        <h3>Можно ли создать объект интерфейса? Если да, то как?</h3>
        <div>
            <p>
                <strong>Нет</strong>, напрямую создать объект интерфейса в Java <strong>нельзя</strong>,
                потому что интерфейсы не могут иметь экземпляров.
            </p>
            <p>
                Однако вы можете объявить ссылку, которая является типом интерфейса, и эта ссылка может
                указывать на объект любого класса, который реализует этот интерфейс.
            </p>
            <p class="no_mb">
                Кстати, можно использовать анонимные классы для создания объекта интерфейса на лету.
            </p>
            <p class="example">
                Объявляем переменную, пишем new ИмяИнтрефейса{и тут же реализацию методов}
            </p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_field_modifier">
        <h3>Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h3>
        <div>
            <p>
                Поля <strong>автоматически</strong> являются публичными <strong>public</strong>,
                статическими <strong>static</strong> и неизменяемыми <strong>final</strong>.
            </p>
            <p>
                Все методы неявно объявляются как <strong>public</strong>.
            </p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_static_method">
        <h3>Что такое static метод интерфейса?</h3>
        <div>
            <p class="no_mb">
                Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что
                для них <strong>отсутствует возможность переопределения в классах</strong>, реализующих интерфейс.
            </p>
            <p class="no_mb">
                Статические методы в интерфейсе являются частью интерфейса без возможности
                использовать их для объектов класса реализации;
            </p>
            <p class="example no_mb"> Методы класса java.lang.Object нельзя переопределить как статические; </p>
            <p class="example">
                Статические методы в интерфейсе используются для обеспечения вспомогательных методов,
                например, проверки на null, сортировки коллекций и т.д.
            </p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_default_method">
        <h3>Что такое дефолтные методы интерфейсов?</h3>
        <div>
            <p>
                Если <strong>класс</strong> реализует интерфейс, он может, но <strong>не обязан, реализовать</strong>
                методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
            </p>
            <p> Дефолтные методы <strong>можно переопределить</strong>.</p>
            <p class="main-mind">
                Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по
                умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно.
            </p>
            <p class="main-mind">
                Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод
                является абстрактным - никакой реализации по умолчанию классом не наследуется.
            </p>
            <p>Метод по умолчанию не может переопределить метод класса java.lang.Object.</p>

            <h3>Для чего они нужны?</h3>
            <p class="no_mb">Помогают реализовывать интерфейсы без страха нарушить работу других классов.</p>
            <p class="no_mb">
                Позволяют избежать создания служебных классов, так как все необходимые методы могут
                быть представлены в самих интерфейсах.
            </p>
            <p> Дают свободу классам выбрать метод, который нужно переопределить.</p>

            <p>
                Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8
                использовать
                лямбда-выражения.
            </p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_impl_method">
        <h3>Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?</h3>
        <div>
            <p class="no_mb">Методы по умолчанию, Статические методы и Частные (приватные) методы.</p>
            <p class="example">см. <a href="#q10">содержимое интерфейса</a></p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_vs_abstract">
        <h3>Чем интерфейсы отличаются от абстрактных классов?</h3>
        <ul>
            <li>
                Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса
                состояние есть: он описывает и то, и другое.
            </li>
            <li>
                <p>
                    Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую
                    связь (птицы: голуби, воробьи).
                </p>
                <p>
                    В то же время, один и тот же интерфейс могут реализовать классы,
                    у которых вообще нет ничего общего
                    <span class="example">(Flyable: птицы, наркоман, самолет)</span>.
                </p>
            </li>
            <li>
                Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только
                от одного класса
            </li>
        </ul>
        <table style="width: 100%;font-size: small" aria-label="content_list_links">
            <tr>
                <th></th>
            </tr>
            <tr>
                <td><a class="button button--content_list" href="#q9"> (Абстрактные классы)</a></td>
                <td><a class="button button--content_list" href="#q10"> (Интерфейсы)</a></td>
            </tr>
        </table>
    </div>

    <hr>
    <div id="interface_inheritance">
        <h3>Может ли один интерфейс наследоваться от другого?</h3>
        <div>
            <p>Да.</p>
            <h4>От двух других?</h4>
            <p>И снова да.</p>
        </div>
        <a class="button button--content_list" href="#q10"></a>
    </div>

    <hr>
    <div id="interface_diamond_problem">
        <h3>
            Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
        </h3>
        <p>Через переопределение.</p>
        <a class="button button--content_list" href="#q10"></a>
    </div>

</section>

<section class="container" id="q11">
    <h1><a href="#">Порядок вызова конструкторов и блоков инициализации</a></h1>
    <p>
        Сначала вызываются <strong>все статические блоки</strong> в очередности от первого статического блока
        корневого предка и выше <strong>по цепочке иерархии</strong> до статических блоков самого класса.
    </p>
    <p>
        Затем вызываются <strong>нестатические блоки</strong> инициализации корневого предка,
        <strong>конструктор корневого предка</strong> и так далее вплоть
        <strong>до</strong> нестатических блоков и конструктора <strong>самого класса</strong>.
    </p>
    <p class="main-mind">
        Parent&nbsp;static&nbsp;block(s)&nbsp;→ Child&nbsp;static&nbsp;block(s)&nbsp;→
        Grandchild&nbsp;static&nbsp;block(s)&nbsp;→<br>Parent&nbsp;nonstatic&nbsp;block(s)&nbsp;→
        Parent&nbsp;constructor&nbsp;→<br>Child&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Child&nbsp;constructor&nbsp;→<br>
        Grandchild&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Grandchild&nbsp;constructor
    </p>
    <hr>
    <h3>Зачем нужны и какие бывают блоки инициализации?</h3>
    <p>
        Блоки инициализации представляют собой код, заключенный в фигурные скобки и
        размещаемый внутри класса вне объявления методов или конструкторов.
    </p>
    <p>Существуют статические и нестатические блоки инициализации.</p>
    <p class="main-mind">
        Блок инициализации выполняется перед инициализацией класса загрузчиком классов или
        созданием объекта класса с помощью конструктора.
    </p>
    <p> Несколько блоков инициализации выполняются в порядке следования в коде класса. </p>
    <p>
        Блок инициализации способен генерировать исключения, если их объявления перечислены в
        throws всех конструкторов класса.
    </p>
    <p>Блок инициализации возможно создать и в анонимном классе.</p>
    <div class="code">
        <p>class Dog {</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-1">private String poroda;</p>
        <p class="tab-1">private int age;</p>
        <p class="tab-1">{</p>
        <p class="tab-2">name = "Шарик";</p>
        <p class="tab-2">poroda = "овчарка";</p>
        <p class="tab-2">age = 2;</p>
        <p class="tab-1">}</p>
        <p class="tab-1">public Dog(String x, String y, int z){</p>
        <p class="tab-2">name = x;</p>
        <p class="tab-2">poroda = y;</p>
        <p class="tab-2">age = z;</p>
        <p class="tab-2">}</p>
        <p>}</p>
    </div>
    <hr>
    <h3>Для чего в Java используются статические блоки инициализации?</h3>
    <p>
        Статические блоки инициализация используются для выполнения кода, который должен
        выполняться <strong>один раз</strong> при инициализации класса загрузчиком классов,
        <strong>в момент предшествующий созданию</strong> объектов этого класса
        <strong>при помощи конструктора</strong>.
    </p>
    <p>
        Такой блок (в отличие от нестатических, принадлежащих конкретному
        объекту класса) принадлежит только самому классу (объекту метакласса Class).
    </p>
    <hr>
    <h3>Что произойдет, если в блоке инициализации возникнет исключительная ситуация?</h3>
    <p class="main-mind">
        Если блок статический – ExceptionInInitializerError,<br>
        Если нестатический – вылетит само исключение.
    </p>
    <p>
        Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
        образом требуется, чтобы объявления этих исключений были перечислены в throws всех
        конструкторов класса. Иначе будет ошибка компиляции.
    </p>
    <p>
        Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
    </p>
    <p>
        В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом
        другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и
        объект класса не будет создан, если ошибка возникает в нестатическом блоке.
    </p>
    <hr>
    <h3>Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</h3>
    <p class="no_mb">Если возникшее исключение - наследник RuntimeException:</p>
    <ul class="tab-2">
        <li>для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;</li>
        <li> для нестатических будет проброшено исключение-источник.</li>
    </ul>
    <p>
        Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено
        java.lang.Error. Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое
        исключение выброшено не будет.
    </p>

</section>

<section class="container" id="object">
    <h1><a href="#">Object и его методы</a></h1>
    <div>
        <p class="term">
            <span>Object</span>
            это базовый класс для всех остальных объектов в Java.</p>
        <p class="main-mind">Любой класс наследуется от Object и, соответственно, наследуют его методы.</p>
        <h3>Методы класса Object</h3>
        <table class="list list--dictionary" aria-label="Методы класса Object">
            <thead>
            <tr>
                <th>Метод</th>
                <th>Описание</th>
            </tr>
            </thead>
            <tr>
                <td>equals()</td>
                <td>
                    <p>Служит для сравнения объектов по значению; == по ссылке</p>
                    <p class="code-word">public boolean equals(Object obj)</p>
                </td>
            </tr>
            <tr>
                <td>hashCode()</td>
                <td>
                    <p>Возвращает hash код для объекта</p>
                    <p class="code-word">int hashCode()</p>
                </td>
            </tr>
            <tr>
                <td>toString()</td>
                <td>
                    <p>Возвращает строковое представление объекта</p>
                    <p class="code-word">String toString()</p>
                </td>
            </tr>
            <tr>
                <td>getClass()</td>
                <td>
                    <p>Возвращает класс объекта во время выполнения</p>
                    <p class="code-word">Class getClass()</p>
                </td>
            </tr>
            <tr>
                <td>clone()</td>
                <td>
                    <p>Создает и возвращает копию объекта</p>
                    <p class="code-word">protected Object clone()</p>
                </td>
            </tr>
            <tr>
                <td>notify()</td>
                <td>
                    <p>Возобновляет поток, ожидающий монитор</p>
                    <p class="code-word">void notify()</p>
                </td>
            </tr>
            <tr>
                <td>notifyAll()</td>
                <td>
                    <p>Возобновляет все потоки, ожидающие монитор</p>
                    <p class="code-word">void notifyAll()</p>
                </td>
            </tr>
            <tr>
                <td>wait()</td>
                <td>
                    <p>
                        Остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или
                        notifyAll() для этого объекта
                    </p>
                    <p class="code-word">void wait()</p>
                </td>
            </tr>
            <tr>
                <td>wait()</td>
                <td>
                    <p>
                        Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет
                        метод
                        notify() или notifyAll() для этого объекта
                    </p>
                    <p class="code-word">void wait(long timeout)</p>
                </td>
            </tr>
            <tr>
                <td>wait()</td>
                <td>
                    <p>
                        Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет
                        метод
                        notify() или notifyAll() для этого объекта
                    </p>
                    <p class="code-word">void wait(long timeout, int nanos)</p>
                </td>
            </tr>
            <tr>
                <td>finalize()</td>
                <td>
                    <p>Может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
                    <p class="code-word">protected void finalize()</p>
                </td>
            </tr>
        </table>
        <p>
            <a class="link-to-source"
               href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html"
               target="_blank">Документация по OBJECT (Java17)</a>
        </p>
    </div>
</section>

<section class="container" id="equals_hashcode">
    <h1><a href="#">Equals и HashCode</a></h1>

    <h3>Базовый контракт между hashCode() и equals()</h3>
    <ul class="margined tab-2">
        <li>одно и то же число каждый раз когда объект не меняется;</li>
        <li>
            если два объекта равны через вызов <span class="accent-mono">equals()</span>,
            то вызов у них <span class="accent-mono">hashCode()</span> должен приводить к одному результату;
        </li>
        <li>если <span class="accent-mono">hashCode()</span> у объектов разные, то объекты разные;</li>
    </ul>

    <hr>
    <div id="equals">
        <h2>Equals</h2>
        <p class="main-mind">Метод equals() - определяет отношение эквивалентности объектов.</p>
        <div class="after-h1 tab-2">
            <p><a href="#equals_base_impl">Базовая реализация</a></p>
            <p><a href="#equals_base">Основные принципы</a></p>
            <p><a href="#equals_override_rules">Правила переопределения</a></p>
            <p><a href="#equals_not_needed">Когда уместно не переопределять equals()</a></p>
        </div>

        <div>
            <h3>Зачем нужен equals().<br>Чем он отличается от операции ==?</h3>
            <div>
                <p>Метод equals() - определяет отношение эквивалентности объектов.
                    <br>При сравнении объектов с помощью == сравнение происходит лишь между ссылками.
                    <br>При сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.
                </p>
            </div>
        </div>

        <hr>
        <div id="equals_base_impl">
            <h3>Базовая реализация:</h3>
            <p>equals в классе Object проверяет только равенство ссылок:</p>
            <div class="code">
                    <pre>public boolean <method>equals</method>(Object obj) {
    return (this == obj);
}</pre>
            </div>
            <p>
                По умолчанию каждый экземпляр равен только самому себе.
                <br>Это не всегда хорошо, поэтому для новых классов обычно переопределяют метод equals.
            </p>
            <a class="button button--content_list" href="#equals"></a>
        </div>

        <hr>
        <div id="equals_base">
            <h3>Основные принципы:</h3>
            <ol>
                <li>
                    <p class="no_mb accent-mono">Рефлексивность</p>
                    <div class="code no_mb">
                        <p>x.equals(x) = true</p>
                    </div>
                </li>
                <li>
                    <p class="no_mb accent-mono">Симметричность</p>
                    <div class="code no_mb">
                        <p>x.equals(y) = true</p>
                        <p>y.equals(x) = true</p>
                    </div>
                </li>
                <li>
                    <p class="no_mb accent-mono">Транзитивность</p>
                    <div class="code no_mb">
                        <p>x.equals(y) = true</p>
                        <p>y.equals(z) = true</p>
                        <p>x.equals(z) = true</p>
                    </div>
                </li>
                <li>
                    <p class="no_mb accent-mono">Постоянство или Непротиворечивость</p>
                    <div class="code no_mb">
                        <p>Результат одно и то же число пока объект не изменится</p>
                    </div>
                    <p class="example">
                        Для любых ссылок на значения х и у, если несколько раз вызвать
                        х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться
                        значение false при условии, что никакая информация, используемая при сравнении объектов, не
                        поменялась.
                    </p>
                </li>
                <li>
                    <p class="no_mb accent-mono">Если объекта нет - ложь</p>
                    <div class="code no_mb">
                        <p>x.equals(null) = false</p>
                    </div>
                    <p class="example">
                        Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.
                    </p>
                </li>
            </ol>
            <a class="button button--content_list" href="#equals"></a>
        </div>

        <hr>
        <div id="equals_override_rules">
            <h3>Правила переопределения equals():</h3>
            <ul class="tab-2">
                <li>
                    Использование оператора == для проверки, является ли аргумент ссылкой на указанный
                    объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться
                    false.
                </li>
                <li>
                    Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли
                    аргумент правильный тип. Если не имеет, возвращается false.
                </li>
                <li>
                    Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой
                    instanceof она гарантированно будет выполнена.
                </li>
                <li>
                    <p>
                        Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте
                        и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу.
                    </p>
                    <p>
                        Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае -
                        false.
                    </p>
                </li>
                <li>
                    По окончанию переопределения метода equals() следует проверить: является ли
                    порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и
                    непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.
                </li>
            </ul>
            <div class="code">
                <pre><an>@Override</an>
public boolean <method>equals</method>(Object obj) {
    if (this == obj) <rem>//равен сам себе</rem>
    return true;
    if (obj == null) <rem>//не равен нулю</rem>
    return false;
    if (getClass() != obj.getClass()) <rem>//объекты одного класса</rem>
    return false;
    BlackBox other = (BlackBox) obj; <rem>//приведение</rem>
    if (varA != other.varA) <rem>//для конкретных переменных класса</rem>
    return false;
    if (varB != other.varB)
    return false;
    return true;
}</pre>
            </div>
            <a class="button button--content_list" href="#equals"></a>
        </div>

        <hr>
        <div id="equals_not_needed">
            <h3>Когда уместно не переопределять equals()</h3>
            <div>
                <ol class="margined">
                    <li>Для перечислений (enum)</li>
                    <li>
                        <p>Когда важны сами экземпляры, а не данные внутри них</p>
                        <p class="example">Пример - классы Thread, RecursiveTask</p>
                    </li>
                    <li>
                        <p>Сравнение объектов вообще не предполагается</p>
                        <p class="example">Пример - класс Pattern</p>
                    </li>
                    <li>В базовом классе уже есть equals и нам подходит эта реализация</li>
                    <li>
                        Класс имеет модификатор доступа private или по умолчанию и мы уверены,
                        что метод equals не будет вызван
                    </li>
                </ol>
            </div>
            <a class="button button--content_list" href="#equals"></a>
        </div>

        <hr>
        <div id="equals_vs_instanceof">
            <h3>Чем a.getClass().equals(A.class) отличается от a instanceOf A.class</h3>
            <p class="no_mb">Для equals всегда нужно сравнивать типы объектов через getClass.</p>
            <p>instanceof не соблюдает правило симметрии в наследниках.</p>
            <div class="code">
                <p>my.equals(child) == true</p>
                <p>child.equals(my) == false // должно быть тру</p>
            </div>
            <p class="main-mind">
                Оператор instanceof нужен, чтобы проверить, был ли объект, на который ссылается
                переменная X, создан на основе какого-либо класса Y.
                <br>Оператор instanceof проверяет именно происхождение объекта, а не переменной.
            </p>
        </div>

    </div>

    <hr>
    <div id="hashcode">
        <h2>hashcode</h2>
        <div>
            <p class="main-mind">
                Метод hashCode() необходим для вычисления хэш кода объекта, переданного в качестве входного параметра.
            </p>
            <p>
                В Java это целое число, в более широком смысле - битовая строка фиксированной длины,
                полученная из массива произвольной длины.
                <br>Этот метод реализован таким образом, что для одного и того же входного объекта,
                хэш код всегда будет одинаковым.
            </p>
            <div class="after-h1 tab-2">
                <p><a href="#hashcode_not_unique">Почему hashcode() не может быть уникальным?</a></p>
                <p><a href="#hashCode_base_impl">Базовая реализация</a></p>
                <p><a href="#hashCode_override">Рекомендации по переопределению</a></p>
                <p><a href="#equals_wo_hashCode">
                    Что будет, если переопределить equals() не переопределяя hashCode()?
                </a></p>
                <p><a href="#hashCode_order">Почему хэш-код в виде 31 * x + y предпочтительнее</a></p>
                <p><a href="#hashCode_lombok">Lombok аннотация @EqualsAndHashCode</a></p>
            </div>
        </div>

        <div id="hashcode_not_unique">
            <h3>
                Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
            </h3>
            <p>
                Следует понимать, что в Java <strong>множество возможных хэш кодов ограничено
                <a href="../datatypes/index.html#q1" target="_blank">типом int</a></strong>,
                а множество объектов ничем не ограничено.
            </p>
            <p class="no_mb">Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>
            <ul class="tab-2">
                <li>если хэш коды разные, то и объекты гарантированно разные;</li>
                <li>если хэш коды равны, то объекты могут необязательно равны.</li>
                <li>для одного и того-же объекта, хеш-код всегда будет одинаковым;</li>
                <li>если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот).</li>
            </ul>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>

        <hr>
        <div id="hashCode_base_impl">
            <h3>Каким образом реализованы методы hashCode() и equals() в классе Object?</h3>
            <div class="code no_mb">
                <p>public boolean equals(Object obj) { return (this == obj);}</p>
                <p>public native int hashCode();</p>
            </div>
            <p class="example">
                <span>native</span> означает, что реализация данного метода выполнена на другом языке (здесь на C++) и
                обычно возвращает адрес объекта в памяти.
            </p>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>

        <div id="hashCode_override">
            <h3> Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()? </h3>
            <p class="main-mind">
                Общий совет: выбирать поля, которые с большой долью вероятности будут различаться.
            </p>
            <p>
                Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как
                id, uuid.
                <br>При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(),
                то они должны быть задействованы и при выполнении equals().
            </p>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>

        <hr>
        <div id="equals_wo_hashCode">
            <h3>
                Что будет, если переопределить equals() не переопределяя hashCode()?
                <br>Какие могут возникнуть проблемы?
            </h3>
            <p class="no_mb">Классы и методы, которые используют правила этого контракта могут работать некорректно.</p>
            <p class="no_mb">
                Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в нее
                помещена при использовании нового экземпляра ключа не будет в ней найдена.
            </p>
            <p>
                В HashSet при добавлении объект сначала сравнивается хэш добавляемого и существующие
                (быстрая проверка очень экономит время), если хэш разный – то дальше сравнивается по equals.
            </p>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>

        <hr>
        <div id="hashCode_order">
            <h3>Есть класс Point{int x, y;}.
                <br>Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?</h3>
            <p>
                Множитель создает зависимость значения хэш кода от очередности обработки полей, что в
                итоге порождает лучшую хэш функцию.
            </p>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>

        <hr>
        <div id="hashCode_lombok">
            <h3>Lombok аннотация @EqualsAndHashCode</h3>
            <div>
                <p>Можно использовать если:</p>
                <ul class="margined">
                    <li>
                        <p>
                            Если классы связаны отношением родитель-наследник, сравниваются объекты только одинаковых
                            типов
                        </p>
                        <p class="example">
                            <span>ВАЖНО</span>: у всех классов в иерархии должна быть аннотация
                            <span>@EqualsAndHashCode</span>.
                            <br>Если у одного класса будет аннотация, а у другого явно определён equals,
                            то сравнения могут быть некорректны
                        </p>
                    </li>
                    <li>
                        <p>Сравниваются все поля</p>
                        <p class="example">Изменить список полей можно с помощью аннотаций
                            <span>@EqualsAndHashCode.Include</span> и
                            <span>@EqualsAndHashCode.Exclude</span>.</p>
                        <p class="example">Или явно задать его в <span>@EqualsAndHashCode(of = {"x"}</span>)</p>
                    </li>
                    <li>Все поля проверяются на null</li>
                </ul>
            </div>
            <a class="button button--content_list" href="#hashcode"></a>
        </div>
    </div>

</section>

<section class="container" id="q13">
    <h1><a href="#">this и super</a></h1>

    <hr>
    <div>
        <h3>Для чего используется ключевое слово this?</h3>
        <p>
            В Java, ключевое слово <span class="code-word">this</span> используется в качестве ссылки на текущий объект,
            внутри которого оно используется.
        </p>
        <p>
            Это слово может использоваться для ссылки на текущий класс экземпляр переменной, методы и конструкторы.
        </p>
    </div>

    <hr>
    <div>
        <h3>Как вызвать метод из родительского класса?</h3>
        <p>
            В Java вы можете вызвать метод родительского класса с помощью ключевого слова
            <span class="code-word">super</span>.
        </p>
        <p>
            Это ключевое слова используется для вызова конструктора родительского класса, а также для вызова метода
            родительского класса.
        </p>

        <p class="example">
            Вы можете использовать super для вызова любого метода, определенного в родительском классе.
            Если же метод не определен в родительском классе, вы получите ошибку компиляции.
        </p>
    </div>

</section>

<section class="container" id="q14">
    <h1><a href="#">Методы. Переопределение и перегрузка</a></h1>
    <div class="after-h1 tab-2">
        <p><a href="#method_static">Что такое статический метод?</a></p>
        <p><a href="#method_non_static">Что такое не статический метод?</a></p>
        <p><a href="#method_overriding">Что такое переопределение метода?</a></p>
        <p><a href="#method_overloading">Что такое перегрузка метода?</a></p>
        <p><a href="#method_overriding_static">Можно ли переопределить статический метод?</a></p>
        <p><a href="#method_hiding">Что такое сокрытие метода?</a></p>
        <p><a href="#method_hiding_vs_overriding">Затенение и сокрытие метода. Чем отличаются?</a></p>
        <p><a href="#method_static_over">Может ли статический метод быть переопределён или перегружен?</a></p>
        <p><a href="#method_static_over_non_static">Могут ли нестатические методы перегрузить статические?</a></p>
        <p><a href="#method_overriding_modifier">
            Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
        </a></p>
        <p><a href="#vir_func">Что такое виртуальная функция и используются ли они в Java?</a></p>
    </div>

    <div id="method_static">
        <h3>Что такое статический метод?</h3>
        <div>
            <p>
                Статический метод в Java — это метод, который <strong>принадлежит классу</strong>,
                а не экземпляру класса (объекту).
                Он может быть вызван без создания объекта класса.
            </p>
            <p>Статические методы объявляются с помощью ключевого слова <span class="code-word">static</span>.</p>
            <p>Основные характеристики статических методов:</p>
            <ol>
                <li>Статический метод может быть вызван прямо из класса и не требует создания экземпляра класса.</li>
                <li>Статический метод может прямо обращаться только к статическим переменным и статическим методам.
                    Он не может прямо обращаться к нестатическим членам (переменным и методам).
                </li>
                <li>Не могут быть переопределены (в прямом смысле это слова, см.
                    <a href="#method_hiding">сокрытие</a>), но могут быть перегружены.
                </li>
            </ol>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_non_static">
        <h3>Что такое не статический метод?</h3>
        <div>
            <p>
                Нестатический метод в Java, также известный как <strong>метод экземпляра</strong>,
                принадлежит конкретному объекту (экземпляру класса), а не классу в целом.
            </p>
            <p>Основные характеристики нестатических методов:</p>
            <ol>
                <li>Нестатический метод требует создания экземпляра класса для его вызова.</li>
                <li>Нестатический метод может прямо обращаться к любому другому члену класса (как статическому, так и
                    нестатическому).
                </li>
                <li>Нестатические методы могут быть переопределены, если они не объявлены как final.</li>
            </ol>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_overriding">
        <h3>Что такое переопределение метода?</h3>
        <div>
            <p>
                Переопределение метода (Method Overriding) в Java - это механизм, который позволяет дочернему классу
                предоставить свою собственную реализацию метода, уже определенного в родительском классе.
            </p>
            <p>
                Это важный аспект объектно-ориентированного программирования, так как он поддерживает принцип
                <a href="../oop/index.html#q8" target="_blank">полиморфизма</a>.
            </p>
            <p>
                Переопределенный метод в подклассе должен иметь ту же сигнатуру, что и метод в родительском классе.
                Это означает, что переопределенный метод должен иметь то же имя, возвращаемый тип и параметры.
            </p>
            <p class="example">
                Аннотация @Override не является обязательной, но это хорошая практика использовать её при
                переопределении
                методов, так как это помогает быстрее выявить ошибки во время компиляции, если метод родительского
                класса не
                существует или имеет другую сигнатуру.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_overloading">
        <h3>Что такое перегрузка метода?</h3>
        <div>
            <p>
                Перегрузка метода (Method Overloading) - это возможность в языке программирования Java, которая
                позволяет классу иметь два или более метода с одинаковым именем, но разными параметрами.
            </p>

            <p>Важно помнить:</p>
            <ol>
                <li>Методы должны иметь одинаковое имя, но разные параметры (как по типу, так и по количеству).</li>
                <li>Перегруженные методы могут иметь разные модификаторы доступа (private, public, protected).</li>
                <li>
                    Перегруженный метод может выбросить любое количество исключений, независимо от того, выбрасывают ли
                    исключения оригинальные методы.
                </li>
                <li>Перегруженный метод может иметь разные возвращаемые типы.*</li>
            </ol>
            <h4 class="tab-1">*Можно ли изменить тип возвращаемых данных при перегрузке метода?</h4>
            <div class="tab-1">
                <p class="no_mb">
                    Изменение <strong>только</strong> типа возвращаемых данных не достаточно для перегрузки метода в
                    Java.
                </p>
                <p class="no_mb">
                    Перегрузить метод путем изменения возвращаемого типа не допускается, если такое произойдет, будет
                    выброшена
                    ошибка при компиляции.
                </p>
                <p>Однако, если вы измените список параметров, то сможете успешно перегрузить метод.</p>
            </div>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_overriding_static">
        <h3>Можно ли переопределить статический метод?</h3>
        <div>
            <p><strong>Нет, однако...</strong></p>
            <p>
                В Java статические методы не могут быть переопределены. Это связано с тем, что статические методы
                являются частью класса, а не экземпляра класса.
                Они принадлежат классу, в котором определены, и не могут быть переопределены в подклассе.
            </p>
            <p>
                Однако, статический метод может сокрыт в подклассе.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_hiding">
        <h3>Что такое сокрытие метода?</h3>
        <div>
            <p>
                Сокрытие метода в Java (Method Hiding) - это механизм, позволяющий подклассу предоставить
                свою собственную реализацию статического метода, уже определенного в родительском классе.
            </p>
            <p>
                Сокрытие метода в Java применяется только к статическим методам. Нестатические методы поддерживают
                переопределение, но не сокрытие.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_hiding_vs_overriding">
        <h3>Затенение и сокрытие метода. Чем отличаются?</h3>
        <div>
            <p>
                Затенение метода (method overriding) и сокрытие метода (method hiding) - это разные понятия в Java.
            </p>

            <p class="no_mb">
                Затенение метода (Method Overriding): Это механизм, который позволяет подклассу предоставить реализацию
                метода, уже предоставленного в его суперклассе.
            </p>
            <p class="no_mb">Этот механизм используется для достижения полиморфизма времени выполнения.</p>
            <p>При затенении метода используется ключевое слово <span class="code-word">super</span>.</p>

            <p class="no_mb">
                Сокрытие метода (Method Hiding): Если суперкласс и подкласс имеют статические методы с одинаковым именем
                и параметрами, то метод в подклассе скрывает метод в суперклассе.
            </p>
            <p class="no_mb">Это известно как сокрытие метода.</p>
            <p>Важно помнить, что статические методы связаны с классом, а не с экземпляром.</p>

            <p>
                Так что, хотя оба термина относятся к тому, что метод в подклассе заменяет или скрывает метод в
                суперклассе, они используются в разных контекстах и имеют разные последствия.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_static_over">
        <h3>Может ли статический метод быть переопределён или перегружен?</h3>
        <div>
            <p>
                Статические методы <strong>не могут быть переопределены</strong> в точном смысле слова, <strong>но они
                могут</strong> скрыть родительские статические методы (<strong>затирать</strong>).
            </p>
            <p>
                <strong>Да, могут быть перегружены.</strong> Мы можем иметь два или более статических метода с
                одинаковым именем, но с различиями во входных параметрах.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_static_over_non_static">
        <h3>Могут ли нестатические методы перегрузить статические?</h3>
        <div>
            <p><strong>Да</strong>, могут.</p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="method_overriding_modifier">
        <h3> Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода? </h3>
        <div>
            <p>
                При переопределении метода сужать модификатор доступа <strong>нельзя</strong>, т.к. это приведет
                к нарушению принципа подстановки Барбары Лисков.
                <strong>Расширение</strong> уровня доступа <strong>возможно</strong>.
            </p>
            <p>
                Изменять <strong>тип</strong> возвращаемого значения при переопределении метода разрешено
                <strong>только в сторону сужения</strong> типа (вместо родительского класса - наследника).
            </p>
            <p>
                При <strong>изменении типа, количества, порядка</strong> следования аргументов
                <strong>вместо переопределения</strong>
                будет происходить <strong>overloading (перегрузка)</strong> метода.
            </p>
            <p class="no_mb">
                Секцию <strong>throws</strong> метода можно не указывать, но стоит помнить, что она остаётся
                действительной, если уже определена у метода родительского класса.
            </p>
            <p class="no_mb">
                Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения
                RuntimeException.
            </p>
            <p>Порядок следования таких элементов при переопределении значения не имеет.</p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

    <hr>
    <div id="vir_func">
        <h3>Что такое виртуальная функция и используются ли они в Java?</h3>
        <div>
            <p class="term no_mb">
                <span>Виртуальная функция</span> - это термин, который используется в некоторых языках программирования,
                для обозначения метода, который может быть переопределен в производном классе.
            </p>
            <p class="example">
                В C++, например, виртуальные функции позволяют достичь "позднего связывания" или "динамического
                связывания",
                что является ключевой составляющей полиморфизма.
            </p>
            <p class="no_mb">
                Однако в Java все не-статические и не-финальные методы по умолчанию являются "виртуальными" в том
                смысле,
                что они могут быть переопределены в подклассах.
            </p>
            <p>
                Таким образом, в Java нет необходимости (и даже возможности) явно
                обозначать методы как "виртуальные" - это поведение является стандартным.
            </p>
        </div>
        <a class="button button--content_list" href="#q14"></a>
    </div>

</section>

<section class="container" id="q15">
    <h1><a href="#">Effectively final</a></h1>
    <div>
        <p>
            В Java термин <span class="accent-mono">effectively&nbsp;final</span>
            введен в Java 8 и относится к переменным, которые
            <strong>не&nbsp;модифицируются после инициализации</strong>.
            <br>Другими словами, переменная "effectively&nbsp;final", если она не изменяется после того, как ей
            впервые присваивается значение.
        </p>
        <p>
            Это понятие используется преимущественно в контексте лямбда-выражений и анонимных классов.
            В Java 8 и более поздних версиях такие сущности могут обращаться к локальным переменным,
            которые являются final или "effectively&nbsp;final".
        </p>
        <p>
            Технически, вам не обязательно явно объявлять переменную как final, чтобы она была "effectively&nbsp;final".
            Если Java видит, что локальная переменная не изменяется после инициализации, она считается
            "effectively&nbsp;final", и вы можете безопасно ссылаться на нее в лямбда-выражении или анонимном классе.
        </p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q16">
    <h1><a href="#">Что такое record? Когда можно его применять?</a></h1>
    <div>
        <p>
            Подробненько <a href="https://www.tune-it.ru/web/romo/blog/-/blogs/java-records" target="_blank">тут</a>
        </p>
        <p class="example">
            Record в Java — это нововведение, введенное в Java 14 в качестве превью-функции и стабилизированное в Java
            16. Record позволяет сократить количество шаблонного кода при создании классов, которые служат просто
            контейнерами данных.
        </p>
        <p class="term">
            <span>Record</span>
            — это новый тип объявления (type of declaration) для определения неизменяемых (immutable) классов
            данных.
        </p>
        <p>
            Он автоматически предоставляет реализации
            <span class="accent-mono">конструктора</span>
            и методов
            <span class="accent-mono">equals()</span>,
            <span class="accent-mono">hashCode()</span>,
            <span class="accent-mono">toString()</span>,
            а также
            <span class="accent-mono">геттеров</span>
            для каждого объявленного поля (с именами полей, а не с префиксом get).
        </p>
        <p>
            Record лучше всего подходит для небольших и неизменяемых классов данных. Они не предназначены для больших
            классов с некоторой сложной логикой или состоянием.
        </p>
        <p>
            Помимо этого, Record не может наследоваться от другого класса (кроме java.lang.Record) и не может быть
            суперклассом.
        </p>
    </div>
</section>

<section class="container" id="q17">
    <h1><a href="#">VARARGS</a></h1>
    <div>
        <h3>Что такое varargs?<br>В каких случаях стоит его применять?</h3>
        <div>
            <p class="term">
                <span>Varargs (Variable-Length Arguments)</span>
                - это возможность в Java, которая позволяет методу принимать нуль или
                более аргументов одного типа.
                <br>Это очень удобно, когда вы не знаете, сколько аргументов нужно передать методу.
            </p>
            <p>
                Вы можете определить varargs в методе, указав тип аргумента, за которым следуют три точки (...).
            </p>
            <p class="no_mb">Например:</p>
            <div class="code"><pre>
public void <method>printNumbers</method>(int... numbers) {
    for (int number : numbers) {
        System.out.println(number);
    }
}</pre>
            </div>
            <p>
                Теперь вы можете вызвать этот метод с любым количеством аргументов типа int (включая ноль&nbsp;аргументов):
            </p>
            <div class="code"><pre>
printNumbers();        // No arguments
printNumbers(1);       // One argument
printNumbers(1, 2, 3); // Three arguments</pre>
            </div>
            <p>
                Varargs очень полезны, когда вы создаете методы, которые требуют произвольного числа аргументов.
                <br>Однако стоит
                <strong>быть осторожным</strong> при использовании varargs <strong>вместе с другими аргументами</strong>
                , так как <strong>порядок аргументов становится важным</strong>.
            </p>
            <p class="main-mind">
                Varargs должен быть последним в списке аргументов метода.
            </p>
        </div>
    </div>
    <hr>
    <div>
        <h3>В каких случаях может возникнуть неоднозначность при работе с varargs?</h3>
        <div>
            <p> Неоднозначность при работе с varargs в Java может возникнуть в следующих случаях: </p>
            <ol class="margined">
                <li class="term">
                    <p>
                        <span>Перегрузка методов с varargs и без</span>.
                        <br>Если у вас есть перегруженные методы, один из которых принимает varargs, а другой
                        - фиксированное количество аргументов, компилятор может не определить, какой метод
                        вызвать.
                    </p>
                    <p class="example">Например, если у вас есть методы
                        <span>foo(int&nbsp;a,&nbsp;int&nbsp;b)</span>
                        и
                        <span>foo(int...&nbsp;a)</span>,
                        вызов
                        <span>foo(1,&nbsp;2)</span>
                        может быть неоднозначным.
                    </p>
                </li>
                <li class="term">
                    <p>
                        <span> Перегрузка методов с разными типами varargs</span>.
                        <br>Если у вас есть два метода, оба с varargs, но с разными типами, и вы пытаетесь вызвать метод
                        с
                        аргументами, которые могут быть приведены к обоим типам, это может привести к неоднозначности.
                    </p>
                    <p class="example">
                        Например, есть методы
                        <span>foo(Integer...&nbsp;a)</span>
                        и
                        <span>foo(String...&nbsp;a),</span>,
                        вызов
                        <span>foo(null)</span>
                        может вызвать неоднозначность.
                    </p>
                </li>
                <li class="term">
                    <span>Неоднозначность с передачей null</span>.
                    <br>Если метод принимает varargs и вы передаете null, это может привести к
                    исключению NullPointerException, если метод пытается обработать varargs как массив (что он и есть),
                    так как null не может быть обработан как массив.
                </li>
            </ol>
            <p>
                Во всех этих случаях, чтобы избежать неоднозначности, нужно более ясно указать, какой метод вы хотите
                вызвать, возможно, явно приведя типы аргументов или явно создав массив для varargs.
            </p>
        </div>
    </div>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../datatypes/">Типы данных</a>
    <a class="navi-button navi--next" href="../exceptions/">Исключения</a>
</div>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

<a href="#" class="button button--top"></a>

</body>

</html>