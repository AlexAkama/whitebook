<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Classes</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Классы JAVA</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>Classes</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Какие виды классов есть в java?</a></li>
        <li><a href="#q2">Что такое вложенный класс</a></li>
        <li><a href="#q3">Что такое локальный класс?</a></li>
        <li><a href="#q4">Что такое анонимные классы?</a></li>
        <li><a href="#q5">Что такое перечисления (enum)?</a></li>
        <li><a href="#q6">Что такое конструктор?</a></li>
        <li><a href="#q7">Модификаторы доступа</a></li>
        <li><a href="#q8">Использование модификаторов</a></li>
        <li><a href="#q9">Абстрактные классы</a></li>
        <li><a href="#q10">Интерфейсы</a></li>
        <li><a href="#q11">Порядок вызова конструкторов</a></li>
        <li><a href="#q12">Object, equals и hashCode</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1>Какие виды классов есть в JAVA?</h1>
    <ul>
        <li>
            <p><span class="accent-mono">Top level class</span> (Обычный класс):</p>
            <ul>
                <li>Abstract class (Абстрактный класс);</li>
                <li>Final class (Финализированный класс).</li>
            </ul>
        </li>
        <li class="mb10"><span class="accent-mono">Interfaces</span> (Интерфейс).</li>
        <li class="mb10"><span class="accent-mono">Enum</span> (Перечисление).</li>
        <li>
            <p><span class="accent-mono">Nested class</span> (Вложенный класс):</p>
            <ul>
                <li>Static nested class (Статический вложенный класс);</li>
                <li>Member inner class (Простой внутренний класс);</li>
                <li>Local inner class (Локальный класс);</li>
                <li>Anonymous inner class (Анонимный вложенный класс).</li>
            </ul>
        </li>
    </ul>
    <p>К классам верхнего уровня модификатор static неприменим.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>Расскажите про вложенные классы.<br>В каких случаях они применяются?</h1>
    <p class="main-mind">
        Класс называется вложенным (Nested class), если он определен внутри другого класса.
    </p>
    <p class="no_mb">
        Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его
        класс.
    </p>
    <p>
        Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен
        стать классом верхнего уровня.
    </p>
    <p>
        Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот.
        Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.
    </p>
    <p class="no_mb">Существуют четыре категории вложенных классов:</p>
    <ul class="tab-2 no_mb">
        <li>Static nested class (Статический вложенный класс);</li>
        <li>Member inner class (Простой внутренний класс);</li>
        <li><a href="#q3">Local inner class (Локальный класс)</a>;</li>
        <li><a href="#q4">Anonymous inner class (Анонимный класс)</a>.</li>
    </ul>
    <p>
        Такие категории классов, за исключением первого, также называют
        <span class="bold">внутренними (Inner class)</span>.
    </p>
    <p>Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>
    <p class="no_mb">Каждая из категорий имеет рекомендации по своему применению:</p>
    <ul>
        <li>
            <span class="bold">Cтатический</span>:
            если вложенный класс должен быть виден за пределами одного метода или
            он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода
            и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр.
        </li>
        <li>
            <span class="bold">Нестатический</span>:
            если ссылка на обрамляющий класс не требуется. Доступ к полям стат. и нестат. класса.
        </li>
        <li>
            <span class="bold">Локальный</span>:
            если класс необходим только внутри какого-то метода и требуется создавать
            экземпляры этого класса только в этом методе.
        </li>
        <li>
            <span class="bold">Анонимный</span>:
            если к тому же применение класса сводится к использованию лишь в одном
            месте и уже существует тип, характеризующий этот класс.
        </li>
    </ul>

    <h4>Каким образом из вложенного класса получить доступ к полю внешнего класса?</h4>
    <p class="no_mb">Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.</p>
    <p class="no_mb">
        Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В
        случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к
        такому полю следует через ссылку на его экземпляр.
    </p>
    <p class="example">Например: Outer.this.field.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Что такое локальный класс?<br>Каковы его особенности?</h1>
    <p class="main-mind">
        Local inner class (Локальный класс) - это вложенный класс, который может быть декларирован
        в любом блоке, в котором разрешается декларировать переменные.
    </p>
    <p>
        Как и простые внутренние классы (Member inner class) локальные классы имеют имена и могут использоваться
        многократно.
    </p>
    <p>
        Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в
        нестатическом контексте.
    </p>
    <h4 class="no_mb">Локальные классы имеют следующие особенности:</h4>
    <ul>
        <li>Видны только в пределах блока, в котором объявлены;</li>
        <li>Не могут быть объявлены как private/public/protected или static;</li>
        <li>Не могут иметь внутри себя статических объявлений (полей, методов, классов);</li>
        <li>Имеют доступ к полям и методам обрамляющего класса;</li>
        <li>Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Что такое анонимные классы?<br>Где они применяются?</h1>
    <p class="main-mind">
        Это вложенный локальный класс без имени, который разрешено декларировать в любом месте
        обрамляющего класса, разрешающем размещение выражений.
    </p>
    <p>
        Создание экземпляра анонимного класса происходит одновременно с его объявлением.
    </p>
    <p>
        В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный
        класс - в нестатическом контексте появляется окружающий его экземпляр.
    </p>
    <h4 class="no_mb">Анонимные классы имеют несколько ограничений:</h4>
    <ul>
        <li>Их использование разрешено только в одном месте программы - месте его создания;</li>
        <li>
            Применение возможно только в том случае, если после порождения экземпляра нет
            необходимости на него ссылаться;
        </li>
        <li>
            Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов,
            так как для доступа к ним нет поименованного типа.
        </li>
    </ul>

    <h4 class="no_mb">Анонимные классы обычно применяются для:</h4>
    <ul>
        <li>создания объекта функции (function object), например реализация интерфейса Comparator;</li>
        <li>создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;</li>
        <li>в статическом методе генерации;</li>
        <li>
            инициализации открытого статического поля final, которое соответствует сложному
            перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный.
        </li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Что такое перечисления (enum)?</h1>
    <p class="main-mind">
        Перечисления представляют набор логически связанных констант.
    </p>
    <p>
        Объявление перечисления происходит с помощью оператора <span class="code-word">enum</span>,
        после которого идет название перечисления. Затем идет список элементов перечисления через запятую.
    </p>
    <p>Каждый из них явно объявлен как открытый статический финальный член класса.</p>

    <h4 class="no_mb">Особенности Enum классов:</h4>
    <ul class="tab-2">
        <li>Конструктор всегда private или default</li>
        <li>Могут имплементировать интерфейсы</li>
        <li>Не могут наследовать класс</li>
        <li>Можем переопределить toString()</li>
        <li>Нет public конструктора, поэтому нельзя создать экземпляр вне Enum</li>
        <li>При equals() выполняется ==</li>
        <li>values() возвращает все элементы</li>
        <li>ordinal() возвращает порядок элементов</li>
        <li>Может использоваться в TreeSet и TreeMap т.к. Enum имплементирует Comparable</li>
        <li>compareTo() имитирует порядок элементов предоставляемый ordinal()</li>
        <li>Можно использовать в Switch Case</li>
        <li>Легко создать потокобезопасный синглтон без double check volatile переменных.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Конструкторы</h1>
    <h3>Что такое конструктор по умолчанию?</h3>
    <p>
        Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так
        называемый «конструктор по умолчанию».
    </p>
    <p>
        Если вы создали конструктор с аргументами, то конструктор по умолчанию использоваться не будет (если он не
        создан).
    </p>
    <h3>Могут ли быть приватные конструкторы?<br>Для чего они нужны?</h3>
    <p>
        Приватный (помеченный ключевым словом private, скрытый) конструктор может использоваться публичным статическим
        методом генерации объектов данного класса.
    </p>
    <p> Также доступ к нему разрешен вложенным классам и может использоваться для их нужд.</p>
    <p>
        Запрещает создание экземпляра класса вне методов самого класса, например, чтобы гарантировать существование
        только одного объекта определённого класса, предположим какого-то ресурса, например БД.
    </p>
    <h3>Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами? </h3>
    <p class="no_mb">У конструктора по умолчанию отсутствуют какие-либо аргументы.</p>
    <p class="no_mb">
        Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания
        его клона.
    </p>
    <p>
        Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для
        инициализации полей класса).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Какие модификаторы доступа есть в Java?</h1>
    <h3>Модификаторы доступа</h3>
    <p><span class="bold">private</span>(приватный): члены класса доступны только внутри класса.</p>
    <p>
        <span class="bold">default, package-private, package level</span>
        (доступ на уровне пакета): видимость класса/членов класса только внутри пакета.
        Является модификатором доступа по умолчанию.
    </p>
    <p><span class="bold">protected</span>(защищённый): члены класса доступны внутри пакета и в наследниках.</p>
    <p><span class="bold">public</span> (публичный): класс/члены класса доступны всем.</p>

    <p>
        Во время наследования возможно изменения модификаторов доступа в сторону большей
        видимости (для поддержания соответствия принципу подстановки Барбары Лисков).
    </p>

    <h3>Модификатор static</h3>
    <p class="no_mb"> Модификатор, применяемый к полю, блоку, методу, внутреннему классу. </p>
    <p>Данный модификатор указывает на привязку субъекта к текущему классу.</p>

    <h3>Модификатор final</h3>
    <p class="no_mb">
        Модификатор final может применяться к переменным, параметрам методов, полям и методам
        класса или самим классам.
    </p>
    <ul class="tab-2">
        <li>Класс не может иметь наследников;</li>
        <li>Метод не может быть переопределен в классах наследниках;</li>
        <li>Поле не может изменить свое значение после инициализации;</li>
        <li>Параметры методов не могут изменять своё значение внутри метода;</li>
        <li>Локальные переменные не могут быть изменены после присвоения им значения.</li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Использование модификаторов</h1>
    <hr>
    <h3>Может ли статический метод быть переопределён или перегружен?</h3>
    <p>
        Статические методы <strong>не могут быть переопределены</strong> в точном смысле слова, <strong>но они
        могут</strong>
        скрыть родительские статические методы (<strong>затирать</strong>).
    </p>
    <p>
        <strong>Да, могут быть перегружены.</strong> Мы можем иметь два или более статических метода с одинаковым
        именем, но с различиями во входных параметрах.
    </p>
    <hr>
    <h3>Могут ли нестатические методы перегрузить статические?</h3>
    <p><strong>Да</strong>, могут.</p>
    <hr>
    <h3>Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</h3>
    <p>
        При переопределении метода сужать модификатор доступа <strong>нельзя</strong>, т.к. это приведет
        к нарушению принципа подстановки Барбары Лисков.
        <strong>Расширение</strong> уровня доступа <strong>возможно</strong>.
    </p>
    <p>
        Изменять <strong>тип</strong> возвращаемого значения при переопределении метода разрешено
        <strong>только в сторону сужения</strong> типа (вместо родительского класса - наследника).
    </p>
    <p>
        При <strong>изменении типа, количества, порядка</strong> следования аргументов
        <strong>вместо переопределения</strong>
        будет происходить <strong>overloading (перегрузка)</strong> метода.
    </p>
    <p class="no_mb">
        Секцию <strong>throws</strong> метода можно не указывать, но стоит помнить, что она остаётся
        действительной, если уже определена у метода родительского класса.
    </p>
    <p class="no_mb">
        Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения
        RuntimeException.
    </p>
    <p>Порядок следования таких элементов при переопределении значения не имеет.</p>
    <hr>
    <h3>Могут ли классы быть статическими?</h3>
    <p><strong>Да</strong></p>
    <p>Объект статического класса не хранит ссылку на конкретный экземпляр внешнего класса.</p>
    <p>Объект статического вложенного класса вполне может существовать сам по себе.</p>
    <p>Статический вложенный класс может обращаться только к статическим полям и методам внешнего класса.</p>
    <p>
        Объекты статического класса не содержат ссылок на объекты внешнего класса.
        А самих объектов мы можем создать сколько угодно.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Абстрактные классы</h1>
    <hr>
    <h3>Что такое абстрактные классы?<br>Чем они отличаются от обычных?</h3>
    <p>
        Класс помеченный модификатором <span class="code-word">abstract</span> называется
        абстрактным классом.
    </p>
    <p class="main-mind">
        Создавать экземпляры самого абстрактного класса не разрешается.
    </p>
    <p class="no_mb">
        Такие классы могут выступать <strong>только предками</strong> для других классов.
    </p>
    <p>
        При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие
        создание объектов.
    </p>
    <p>
        Метод помеченный ключевым словом <span class="code-word">abstract</span> - абстрактный метод,
        т.е. метод, который не имеет реализации.
    </p>
    <p class="main-mind">
        Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.
    </p>
    <p>
        Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть
        реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.
    </p>

    <h4 class="no_mb">Особенности абстрактных классов:</h4>
    <ul class="tab-2">
        <li>Может быть конструктор (для вызовов по цепочке из наследников)</li>
        <li>Имплементят интерфейсы, но не обязаны реализовывать их методы</li>
        <li>Не могут быть final</li>
        <li>Могут содержать static методы</li>
        <li>Нельзя создать объект</li>
        <li>Абстрактные методы могут отсутствовать</li>
        <li>Может содержать метод main()</li>
        <li>Классы-наследники не обязаны реализовывать все абстрактные методы</li>
    </ul>
    <hr>
    <h3>Может ли быть абстрактный класс без абстрактных методов?</h3>
    <p>Да</p>
    <hr>
    <h3>Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?</h3>
    <p>Да, может быть конструктор (для вызовов по цепочке из наследников).</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1>Интерфейсы</h1>
    <h3>Что такое интерфейсы?</h3>
    <p>
        Ключевое слово <span class="code-word">interface</span> используется для создания полностью абстрактных классов.
    </p>
    <p class="main-mind">
        Основное предназначение интерфейса - определять каким образом мы можем использовать класс,
        который его реализует.
    </p>
    <p>
        Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует
        их поведение. <strong>Все методы неявно объявляются как public</strong>.
    </p>
    <p>
        Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических
        static методов.
    </p>
    <h4>Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</h4>
    <p>
        Интерфейс также может содержать и <strong>поля</strong>.
        В этом случае они <strong>автоматически</strong> являются публичными <strong>public</strong>,
        статическими <strong>static</strong> и неизменяемыми <strong>final</strong>.
    </p>
    <h4 class="no_mb">Что такое static метод интерфейса?</h4>
    <p class="no_mb">
        Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что
        для них отсутствует возможность переопределения в классах, реализующих интерфейс.
    </p>
    <p class="no_mb">
        Статические методы в интерфейсе являются частью интерфейса без возможности
        использовать их для объектов класса реализации;
    </p>
    <p class="example no_mb"> Методы класса java.lang.Object нельзя переопределить как статические; </p>
    <p class="example">
        Статические методы в интерфейсе используются для обеспечения вспомогательных методов,
        например, проверки на null, сортировки коллекций и т.д.
    </p>
    <hr>
    <h3> Чем интерфейсы отличаются от абстрактных классов?</h3>
    <ul>
        <li>
            Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса
            состояние есть: он описывает и то, и другое.
        </li>
        <li>
            <p>
                Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую
                связь (птицы: голуби, воробьи).
            </p>
            <p>
                В то же время, один и тот же интерфейс могут реализовать классы,
                у которых вообще нет ничего общего
                <span class="example">(Flyable: птицы, наркоман, самолет)</span>.
            </p>
        </li>
        <li>
            Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только
            от одного класса
        </li>
    </ul>
    <hr>
    <h3>Может ли один интерфейс наследоваться от другого?</h3>
    <p>Да.</p>
    <h4>От двух других?</h4>
    <p>И снова да.</p>
    <hr>
    <h3> Что такое дефолтные методы интерфейсов?</h3>
    <p>
        Если <strong>класс</strong> реализует интерфейс, он может, но <strong>не обязан, реализовать</strong>
        методы по-умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.
    </p>
    <p> Дефолтные методы <strong>можно переопределить</strong>.</p>
    <p class="main-mind">
        Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по
        умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно.
    </p>
    <p class="main-mind">
        Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод
        является абстрактным - никакой реализации по умолчанию классом не наследуется.
    </p>
    <p>Метод по умолчанию не может переопределить метод класса java.lang.Object.</p>

    <h4>Для чего они нужны?</h4>
    <p class="no_mb">Помогают реализовывать интерфейсы без страха нарушить работу других классов.</p>
    <p class="no_mb">
        Позволяют избежать создания служебных классов, так как все необходимые методы могут
        быть представлены в самих интерфейсах.
    </p>
    <p> Дают свободу классам выбрать метод, который нужно переопределить. </p>

    <p>
        Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать
        лямбда-выражения.
    </p>
    <hr>
    <h3>Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?</h3>
    <p>Через переопределение.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1>Порядок вызова конструкторов и блоков инициализации</h1>
    <p>
        Сначала вызываются <strong>все статические блоки</strong> в очередности от первого статического блока
        корневого предка и выше <strong>по цепочке иерархии</strong> до статических блоков самого класса.
    </p>
    <p>
        Затем вызываются <strong>нестатические блоки</strong> инициализации корневого предка,
        <strong>конструктор корневого предка</strong> и так далее вплоть
        <strong>до</strong> нестатических блоков и конструктора <strong>самого класса</strong>.
    </p>
    <p class="main-mind">
        Parent&nbsp;static&nbsp;block(s)&nbsp;→ Child&nbsp;static&nbsp;block(s)&nbsp;→
        Grandchild&nbsp;static&nbsp;block(s)&nbsp;→<br>Parent&nbsp;nonstatic&nbsp;block(s)&nbsp;→
        Parent&nbsp;constructor&nbsp;→<br>Child&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Child&nbsp;constructor&nbsp;→<br>
        Grandchild&nbsp;nonstatic&nbsp;block(s)&nbsp;→ Grandchild&nbsp;constructor
    </p>
    <hr>
    <h3>Зачем нужны и какие бывают блоки инициализации?</h3>
    <p>
        Блоки инициализации представляют собой код, заключенный в фигурные скобки и
        размещаемый внутри класса вне объявления методов или конструкторов.
    </p>
    <p>Существуют статические и нестатические блоки инициализации.</p>
    <p class="main-mind">
        Блок инициализации выполняется перед инициализацией класса загрузчиком классов или
        созданием объекта класса с помощью конструктора.
    </p>
    <p> Несколько блоков инициализации выполняются в порядке следования в коде класса. </p>
    <p>
        Блок инициализации способен генерировать исключения, если их объявления перечислены в
        throws всех конструкторов класса.
    </p>
    <p>Блок инициализации возможно создать и в анонимном классе.</p>
    <div class="code">
        <p>class Dog {</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-1">private String poroda;</p>
        <p class="tab-1">private int age;</p>
        <p class="tab-1">{</p>
        <p class="tab-2">name = "Шарик";</p>
        <p class="tab-2">poroda = "овчарка";</p>
        <p class="tab-2">age = 2;</p>
        <p class="tab-1">}</p>
        <p class="tab-1">public Dog(String x, String y, int z){</p>
        <p class="tab-2">name = x;</p>
        <p class="tab-2">poroda = y;</p>
        <p class="tab-2">age = z;</p>
        <p class="tab-2">}</p>
        <p>}</p>
    </div>
    <hr>
    <h3>Для чего в Java используются статические блоки инициализации?</h3>
    <p>
        Статические блоки инициализация используются для выполнения кода, который должен
        выполняться <strong>один раз</strong> при инициализации класса загрузчиком классов,
        <strong>в момент предшествующий созданию</strong> объектов этого класса
        <strong>при помощи конструктора</strong>.
    </p>
    <p>
        Такой блок (в отличие от нестатических, принадлежащих конкретному
        объекту класса) принадлежит только самому классу (объекту метакласса Class).
    </p>
    <hr>
    <h3>Что произойдет, если в блоке инициализации возникнет исключительная ситуация?</h3>
    <p class="main-mind">
        Если блок статический – ExceptionInInitializerError,<br>
        Если нестатический – вылетит само исключение.
    </p>
    <p>
        Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
        образом требуется, чтобы объявления этих исключений были перечислены в throws всех
        конструкторов класса. Иначе будет ошибка компиляции.
    </p>
    <p>
        Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
    </p>
    <p>
        В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом
        другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и
        объект класса не будет создан, если ошибка возникает в нестатическом блоке.
    </p>
    <hr>
    <h3>Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</h3>
    <p class="no_mb">Если возникшее исключение - наследник RuntimeException:</p>
    <ul class="tab-2">
        <li>для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;</li>
        <li> для нестатических будет проброшено исключение-источник.</li>
    </ul>
    <p>
        Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено
        java.lang.Error. Исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое
        исключение выброшено не будет.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q12">
    <h1>OBJECT</h1>
    <p class="no_mb">Object это базовый класс для всех остальных объектов в Java.</p>
    <p class="main-mind">Любой класс наследуется от Object и, соответственно, наследуют его методы.</p>
    <h3>Методы класса Object</h3>
    <table class="list list--dictionary" aria-label="Методы класса Object">
        <thead>
        <tr>
            <th>Метод</th>
            <th>Описание</th>
        </tr>
        </thead>
        <tr>
            <td>equals()</td>
            <td>
                <p>Служит для сравнения объектов по значению; == по ссылке</p>
                <p class="code-word">public boolean equals(Object obj)</p>
            </td>
        </tr>
        <tr>
            <td>hashCode()</td>
            <td>
                <p>Возвращает hash код для объекта</p>
                <p class="code-word">int hashCode()</p>
            </td>
        </tr>
        <tr>
            <td>toString()</td>
            <td>
                <p>Возвращает строковое представление объекта</p>
                <p class="code-word">String toString()</p>
            </td>
        </tr>
        <tr>
            <td>getClass()</td>
            <td>
                <p>Возвращает класс объекта во время выполнения</p>
                <p class="code-word">Class getClass()</p>
            </td>
        </tr>
        <tr>
            <td>clone()</td>
            <td>
                <p>Создает и возвращает копию объекта</p>
                <p class="code-word">protected Object clone()</p>
            </td>
        </tr>
        <tr>
            <td>notify()</td>
            <td>
                <p>Возобновляет поток, ожидающий монитор</p>
                <p class="code-word">void notify()</p>
            </td>
        </tr>
        <tr>
            <td>notifyAll()</td>
            <td>
                <p>Возобновляет все потоки, ожидающие монитор</p>
                <p class="code-word">void notifyAll()</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока до момента пока другой поток не вызовет метод notify() или
                    notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait()</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод
                    notify() или notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait(long timeout)</p>
            </td>
        </tr>
        <tr>
            <td>wait()</td>
            <td>
                <p>
                    Остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет метод
                    notify() или notifyAll() для этого объекта
                </p>
                <p class="code-word">void wait(long timeout, int nanos)</p>
            </td>
        </tr>
        <tr>
            <td>finalize()</td>
            <td>
                <p>Может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>
                <p class="code-word">protected void finalize()</p>
            </td>
        </tr>
    </table>
    <hr>
    <h3>Equals и HashCode</h3>
    <h4>Какой контракт между hashCode() и equals()?</h4>
    <p class="no_mb"><strong>HashCode</strong> - Общий контракт:</p>
    <ul>
        <li>одно и то же число каждый раз когда объект не меняется;</li>
        <li>
            если два объекта равны через вызов equals(),
            то вызов у них hashCode() должен приводить к одному результату;
        </li>
        <li>если hashCode() у объектов разные, то объекты разные;</li>
    </ul>
    <p class="no_mb"><strong> Equals</strong> - Основные принципы:</p>
    <ol>
        <li>
            <p class="no_mb">Рефлексивность</p>
            <div class="code no_mb">
                <p>x.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Симметричность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Транзитивность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(z) = true</p>
                <p>x.equals(z) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Постоянство или Непротиворечивость</p>
            <div class="code no_mb">
                <p>Результат одно и то же число пока объект не изменится</p>
            </div>
            <p class="example">
                Для любых ссылок на значения х и у, если несколько раз вызвать
                х.equals(y), постоянно будет возвращаться значение true либо постоянно будет возвращаться
                значение false при условии, что никакая информация, используемая при сравнении объектов, не
                поменялась.
            </p>
        </li>
        <li>
            <p class="no_mb">Если объекта нет - ложь</p>
            <div class="code no_mb">
                <p>x.equals(null) = false</p>
            </div>
            <p class="example">
                Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false.
            </p>
        </li>
    </ol>

    <p class="no_mb">Метод equals() - определяет отношение эквивалентности объектов.</p>
    <p>
        При сравнение объектов с помощью <strong>== сравнение</strong> происходит лишь <strong>между ссылками</strong>.
        При сравнении по переопределённому разработчиком <strong>equals() - по внутреннему состоянию объектов</strong>.
    </p>
    <p class="example no_mb">Для чего нужен метод hashCode()?</p>
    <p>
        Метод hashCode() необходим для вычисления хэш кода переданного в качестве входного параметра объекта.
    </p>
    <p>
        В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива
        произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта,
        хэш код всегда будет одинаковым.
    </p>
    <p class="example no_mb">
        Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
    </p>
    <p>
        Следует понимать, что в Java <strong>множество возможных хэш кодов ограничено типом int</strong>,
        а множество объектов ничем не ограничено.
    </p>
    <p class="no_mb">Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>
    <ul class="tab-2">
        <li>если хэш коды разные, то и объекты гарантированно разные;</li>
        <li>если хэш коды равны, то объекты могут необязательно равны.</li>
        <li>для одного и того-же объекта, хеш-код всегда будет одинаковым;</li>
        <li>если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот).</li>
    </ul>
    <p class="example no_mb">
        Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
    </p>
    <p>
        <strong>Общий совет:</strong> выбирать поля, которые с большой долью вероятности будут различаться. Для
        этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как
        id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(),
        то они должны быть задействованы и при выполнении equals().
    </p>
    <hr>
    <h3>Каким образом реализованы методы hashCode() и equals() в классе Object?</h3>
    <div class="code no_mb">
        <p>public boolean equals(Object obj) { return (this == obj);}</p>
        <p>public native int hashCode();</p>
    </div>
    <p class="example">
        native означает, что реализация данного метода выполнена на другом языке (здесь на C++) и
        обычно возвращает адрес объекта в памяти.
    </p>
    <hr>
    <h3>Зачем нужен equals(). Чем он отличается от операции ==?</h3>
    <p class="no_mb">Метод equals() - определяет отношение эквивалентности объектов.</p>
    <p>
        При сравнении объектов с помощью == сравнение происходит лишь между ссылками. При
        сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов
    </p>
    <hr>
    <h3>Правила переопределения equals()</h3>
    <ul class="tab-2">
        <li>
            Использование оператора == для проверки, является ли аргумент ссылкой на указанный
            объект. Если является, возвращается true. Если сравниваемый объект == null, должно вернуться
            false.
        </li>
        <li>
            Использование оператор instanceof и вызова метода getClass() для проверки, имеет ли
            аргумент правильный тип. Если не имеет, возвращается false.
        </li>
        <li>
            Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой
            instanceof она гарантированно будет выполнена.
        </li>
        <li>
            <p>
                Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте
                и значение того же поля в проверяемом на эквивалентность аргументе соответствуют друг другу.
            </p>
            <p>
                Если проверки для всех полей прошли успешно, возвращается результат true, в противном случае - false.
            </p>
        </li>
        <li>
            По окончанию переопределения метода equals() следует проверить: является ли
            порождаемое отношение эквивалентности рефлексивным, симметричным, транзитивным и
            непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей правке.
        </li>
    </ul>
    <div class="code">
        <p>@Override</p>
        <p>public boolean equals(Object obj) {</p>
        <p class="tab-1">if (this == obj) // равен сам себе</p>
        <p class="tab-1">return true;</p>
        <p class="tab-1">if (obj == null) // не равен нулю</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">if (getClass() != obj.getClass()) // объекты одинакового класса</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">BlackBox other = (BlackBox) obj; // приведение</p>
        <p class="tab-1">if (varA != other.varA) // для конкретных переменных класса</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">if (varB != other.varB)</p>
        <p class="tab-1">return false;</p>
        <p class="tab-1">return true;</p>
        <p>}</p>
    </div>
    <hr>
    <h4>
        Что будет, если переопределить equals() не переопределяя hashCode()?
        Какие могут возникнуть проблемы?
    </h4>
    <p class="no_mb">Классы и методы, которые используют правила этого контракта могут работать некорректно.</p>
    <p class="no_mb">
        Так для HashMap это может привести к тому, что пара «ключ-значение», которая была в нее
        помещена при использовании нового экземпляра ключа не будет в ней найдена.
    </p>
    <p>
        В HashSet при добавлении объект сначала сравнивается хэш добавляемого и существующие
        (быстрая проверка очень экономит время), если хэш разный – то дальше сравнивается по equals.
    </p>
    <hr>
    <h4>Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее
        чем x + y</h4>
    <p>
        Множитель создает зависимость значения хэш кода от очередности обработки полей, что в
        итоге порождает лучшую хэш функцию
    </p>
    <hr>
    <h4>Чем a.getClass().equals(A.class) отличается от a instanceOf A.class</h4>
    <p class="no_mb">Для equals всегда нужно сравнивать типы объектов через <span class="code-word">getClass</span>.</p>
    <p><span class="code-word">instanceof</span> не соблюдает правило симметрии в наследниках.</p>
    <div class="code">
        <p>my.equals(child) == true</p>
        <p>child.equals(my) == false // должно быть тру</p>
    </div>
    <p class="main-mind">
        Оператор <span class="code-word">instanceof</span> нужен, чтобы проверить, был ли объект, на который ссылается
        переменная X, создан на основе какого-либо класса Y. Оператор instanceof проверяет именно
        происхождение объекта, а не переменной.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../datatypes/">Типы данных</a>
    <a class="navi-button navi--next" href="../exceptions/">Исключения</a>
</div>

<footer>
        <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

</body>

</html>