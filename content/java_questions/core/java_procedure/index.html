<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Процедурная JAVA</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>JAVA</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Какие примитивные типы данных есть в Java?</a></li>
        <li><a href="#q2">Что такое классы-обертки?</a></li>
        <li><a href="#q3">Что такое Aвтоупаковка и Aвтораспаковка</a></li>
        <li><a href="#q4">Расскажите про приведение типов</a></li>
        <li><a href="#q5">Что такое пул интов?</a></li>
        <li><a href="#q6">Какие нюансы у строк в Java?</a></li>
        <li><a href="#q7">Что такое пул строк?</a></li>
        <li><a href="#q8">Почему String неизменяемый и финализированный класс?</a></li>
        <li><a href="#q9">Какая основная разница между String, StringBuffer, StringBuilder?</a></li>
        <li><a href="#q10">Что такое сигнатура метода?</a></li>
        <li><a href="#q11">Каким образом переменные передаются в методы?</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1>Какие примитивные типы данных есть в Java</h1>
    <p class="main-mind">Два основных типа: примитивы и ссылочные</p>
    <h3>Примитивы</h3>
    <table class="schema" aria-label="Primitives">
        <tr>
            <th id="primitives-table"></th>
        </tr>
        <tr>
            <td rowspan="10">Object</td>
            <td rowspan="8">Number</td>
            <td class="p0">Numeric types</td>
        </tr>
        <tr>
            <td>Byte</td>
        </tr>
        <tr>
            <td>Short</td>
        </tr>
        <tr>
            <td>Long</td>
        </tr>
        <tr>
            <td>Integer</td>
        </tr>
        <tr>
            <td class="p0">Floating-Point Types</td>
        </tr>
        <tr>
            <td>Double</td>
        <tr>
            <td>Float</td>
        </tr>
        <tr>
            <td>Character</td>
        </tr>
        <tr>
            <td>Boolean</td>
        </tr>
    </table>
    <p class="no_mb bold">Инициализация:</p>
    <p class="no_mb tab-1">Числа 0 или 0.0</p>
    <p class="no_mb tab-1">boolean = false</p>
    <p class="tab-1">Объекты (в том числе Sting) = null</p>
    <table class="list list--alter" aria-label="Примитивы">
        <thead>
        <tr>
            <th>Тип</th>
            <th>Умолчание</th>
            <th>Память</th>
            <th>Допустимо</th>
        </tr>
        </thead>
        <tr>
            <td colspan="4">Целочисленные типы</td>
        </tr>
        <tr>
            <td>byte</td>
            <td>0</td>
            <td>8 бит</td>
            <td>от -128 до&nbsp;127</td>
        </tr>
        <tr>
            <td>short</td>
            <td>0</td>
            <td>16 бит</td>
            <td>от -32_768 до&nbsp;32_767</td>
        </tr>
        <tr>
            <td>char</td>
            <td>'\u0000'</td>
            <td>16 бит</td>
            <td>от 0 до 65_536<br>беззнаковое целое число, представляющее собой символ UTF-16 (буквы и цифры)</td>
        </tr>
        <tr>
            <td>int</td>
            <td>0</td>
            <td>32 бита</td>
            <td>от -2_147_483_648 до&nbsp;&nbsp;2_147_483_647</td>
        </tr>
        <tr>
            <td>long</td>
            <td>0L</td>
            <td>64 бита</td>
            <td>от -9_223_372_036_854_775_808L до&nbsp;&nbsp;9_223_372_036_854_775_807L</td>
        </tr>
        <tr>
            <td colspan="4">Типы с плавающей точкой</td>
        </tr>
        <tr>
            <td>float</td>
            <td>0.0f</td>
            <td>32 бита</td>
            <td>от 1.4e-45f до 3.4e+38f</td>
        </tr>
        <tr>
            <td>double</td>
            <td>0.0d</td>
            <td>64 бита</td>
            <td>от 4.9e-324 до 1.7e+308</td>
        </tr>
        <tr>
            <td colspan="4">Логический тип</td>
        </tr>
        <tr>
            <td>boolean</td>
            <td>false</td>
            <td>8 бит (в&nbsp;массивах)<br> 32 бит (не в&nbsp;массивах - int)</td>
            <td>true (истина) или false (ложь)</td>
        </tr>
    </table>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>Что такое классы-обертки?</h1>
    <p class="no_mb">Значение примитива становится объектом, чтобы выполнять различные операции ( .parseInt()).</p>
    <p class="no_mb">Примитивы не имеют методов. </p>
    <p>Объекты классов-оберток являются неизменяемыми (Immutable).</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Что такое автоупаковка и автораспаковка?</h1>
    <p>
        Для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется
        ничего делать, все происходит автоматически
    </p>
    <div class="code">
        <p>int x = 7;</p>
        <p>Integer y = 111;</p>
        <p>x = y; // автораспаковка</p>
        <p>y = x * 123; // автоупаковка</p>
    </div>
    <p>Автоупаковка и распаковка не работают для массивов.</p>
    <p>
        Автоупаковка - это механизм неявной инициализации объектов классов-оберток (Byte, Short,
        Integer, Long, Float, Double, Character, Boolean) значениями соответствующих им исходных
        примитивных типов (byte, short, int...), без явного использования конструктора класса.
    </p>
    <p>
        Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью
        оператора =), либо при передаче примитива в параметры метода (типа класса-обертки).
    </p>
    <p>
        Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и
        константы времени компиляции (литералы и final-примитивы). При этом литералы должны быть
        синтаксически корректными для инициализации переменной исходного примитивного типа.
    </p>
    <p class="no_mb">
        Автоупаковка переменных примитивных типов требует точного соответствия типа исходного
        примитива типу класса-обертки.
    </p>
    <p class="example ">
        Например, попытка упаковать переменную типа byte в Short, без
        предварительного явного приведения byte в short вызовет ошибку компиляции.
    </p>
    <p class="no_mb"> Автоупаковка констант примитивных типов допускает более широкие границы соответствия. </p>
    <p class="no_mb">
        В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов.
    </p>
    <p class="example no_mb">
        Неявное расширение/сужение исходного типа примитива до типа примитива соответствующего
        классу-обертке (для преобразования int в Byte, сначала компилятор самостоятельно неявно сужает int
        к byte) автоупаковку примитива в соответствующий класс-обертку.
    </p>
    <p class="no_mb"> Однако, в этом случае существуют два дополнительных ограничения: </p>
    <p class="no_mb tab-1">
        <span class="bold">a)</span>
        присвоение примитива обертке может производится только оператором = (нельзя передать такой примитив в параметры
        метода без явного приведения типов)
    </p>
    <p class="tab-1 no_mb">
        <span class="bold">b)</span>
        тип левого операнда не должен быть старше чем Character, тип правого не должен старше, чем int.
    </p>
    <p class="example">
        Допустимо расширение/сужение byte в/из short, byte в/из char, short в/из char и только сужение byte из
        int, short из int, char из int. Все остальные варианты требуют явного приведения типов.
    </p>
    <p class="main-mind">
        Дополнительной особенностью целочисленных классов-оберток созданных автоупаковкой
        констант в диапазоне -128 ... +127 является то, что они кэшируются JVM. Поэтому такие обертки с
        одинаковыми значениями будут являться ссылками на один объект.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Приведение типов</h1>
    <h4>Что такое явное и неявное приведение типов?<br>
        В каких случаях в JAVA нужно использовать явное приведение?</h4>
    <p class="no_mb">
        Каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции.
        Механизм приведения типов (casting) - способ преобразования значения переменной
        одного типа в значение другого типа:
    </p>
    <p class="tab-1 no_mb">
        <span class="bold">Неявные – выполняются автоматически</span>
        (расширяющие преобразования, сужающие с потерей данных: int->float, long->float, long->double).
    </p>
    <p class="tab-1">
        <span class="bold">Явные – надо указывать тип</span>
        (сужающие преобразования от типа с большей разрядностью к типу с меньшей разрядностью).
        Потеря данных (старшие биты будут потеряны).
    </p>
    <img src="img/casting.png" alt="Схема приведения типов">
    <table class="list list--alter list--content-center" aria-label="Приведение типов">
        <thead>
        <tr>
            <th>↓ИЗ | В→</th>
            <th>boolean</th>
            <th>byte</th>
            <th>short</th>
            <th>char</th>
            <th>int</th>
            <th>long</th>
            <th>float</th>
            <th>double</th>
        </tr>
        </thead>
        <tr>
            <td>boolean</td>
            <td>-</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>byte</td>
            <td>N</td>
            <td>-</td>
            <td>Y</td>
            <td>C</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>short</td>
            <td>N</td>
            <td>C</td>
            <td>-</td>
            <td>C</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>char</td>
            <td>N</td>
            <td>C</td>
            <td>C</td>
            <td>-</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>int</td>
            <td>N</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>-</td>
            <td>Y</td>
            <td>Y*</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>long</td>
            <td>N</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>-</td>
            <td>Y*</td>
            <td>Y*</td>
        </tr>
        <tr>
            <td>float</td>
            <td>N</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>-</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>double</td>
            <td>N</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>C</td>
            <td>-</td>
        </tr>
    </table>
    <p class="no_mb"><span class="bold">N</span> - невозможно</p>
    <p class="no_mb"><span class="bold">Y</span> - автоматически</p>
    <p class="no_mb"><span class="bold">C</span> - сужающее преобразование, требующее явного приведения</p>
    <p><span class="bold">Y*</span> - автоматическое расширяющее преобразование, в процессе которого значение может
        потерять некоторые из наименее значимых разрядов</p>

    <h4>Разновидности приведения:</h4>
    <ul>
        <li>
            <span class="bold">Тождественное (identity)</span>
            - Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.
        </li>
        <li>
            <p>
                <span class="bold">Расширение (повышение, upcasting) примитивного типа (widening primitive)</span>
                - Означает, что осуществляется переход от менее емкого типа к более ёмкому.
                Этот тип приведения всегда допустим и происходит автоматически.
            </p>
            <p class="example">
                Например, от типа byte (длина 8 бит) к типу int (длина 32 бита).
                Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все
                данные, которые хранились в старом типе и таким образом не происходит потери данных.
            </p>
        </li>
        <li>
            <p>
                <span class="bold">Сужение (понижение, downcasting) примитивного типа (narrowing primitive)</span>
                - Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании
                есть <span class="bad">риск потерять данные</span>.
            </p>
            <p class="main-mind no_mb">
                В Java такое преобразование должно
                совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто
                отбрасываются - никакого округления или других действий для получения более корректного
                результата не производится.
            </p>
            <p class="example">
                Например, если число типа int было больше 127, то при приведении его к
                byte значения битов старше восьмого будут потеряны.
            </p>
        </li>
        <li>
            <span class="bold">Расширение объектного типа (widening reference)</span>
            - Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному,
            т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.
        </li>
        <li>
            <p>
                <span class="bold">Сужение объектного типа (narrowing reference)</span>
                - Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу).
                Возможно только если исходная переменная является подтипом приводимого типа.
            </p>
            <p>Требует явного указания типа. При несоответствии типов в момент выполнения выбрасывается исключение
                ClassCastException.</p>
        </li>
        <li>
            <span class="bold">Преобразование к строке (to String)</span>
            - Любой тип может быть приведен к строке, т.е. к экземпляру класса String.
        </li>
        <li>
            <span class="bold">Запрещенные преобразования (forbidden)</span>
            - Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся
            приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того
            невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования и т.п.
        </li>
    </ul>
    <p class="main-mind">
        При приведении ссылочных типов с самим объектом ничего не происходит, меняется лишь
        тип ссылки, через которую происходит обращение к объекту.
    </p>


    <p> Для проверки возможности приведения нужно воспользоваться оператором
        <span class="code-word">instanceof</span>: </p>
    <div class="code">
        <p>Parent parent = new Child();</p>
        <p>if (parent instanceof Child) {</p>
        <p class="tab-1">Child child = (Child) parent;</p>
        <p>}</p>
    </div>


    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Что такое пул интов?</h1>
    <p class="no_mb">
        Для более эффективного использования памяти, в JAVA используются так называемые пулы.
    </p>
    <p>
        Есть строковый пул, Integer pool и тд. Когда мы создаем объект не используя операцию new, объект
        помещается в пул, и в последствии, если мы захотим создать такой же объект (опять не используя
        new), новый объект создан не будет, а мы просто получим ссылку на наш объект из пула.
    </p>
    <p class="main-mind">
        Особенность Integer-пула — он хранит только числа, которые помещаются в тип данных byte:
        от -128 до 127. Для остальных чисел пул не работает.
    </p>
    <div class="code">
        <p>Integer i1 = 127;</p>
        <p>Integer i2 = 127;</p>
        <p>Integer i3 = 128;</p>
        <p>Integer i4 = 128;</p>
        <p>System.out.println(i1==i2); //true</p>
        <p> System.out.println(i3==i4); //false</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Какие нюансы у строк в Java?</h1>
    <p class="main-mind">
        Это неизменяемый (immutable) (не&nbsp;меняется после создания) и финализированный (без&nbsp;потомков) тип
        данных;
        потокобезопасный может использоваться в многопоточке
    </p>
    <ul>
        <li>Все объекты класса String JVM хранит в пуле строк;</li>
        <li>Объект класса String можно получить используя двойные кавычки;</li>
        <li>Можно использовать оператор + для конкатенации строк;</li>
        <li>Начиная с Java 7 строки можно использовать в конструкции switch.</li>
    </ul>
    <p>Каждый объект можно привести к строке <span class="code-word">.toString</span></p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Что такое пул строк?</h1>
    <p>Пул строк – это набор строк хранящийся в <a href="../java_base/index.html#q12">Heap</a> .</p>
    <p class="no_mb">
        Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
    </p>
    <p class="example">
        Интернирование строк — это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
    </p>
    <p>Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;</p>
    <p>
        Когда для создания строки используются <span class="code-word">"</span>, то сначала ищется строка в пуле
        с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле,
        а затем возвращается ссылка на неё;
    </p>
    <div class="code">String habr = "habrahabr"; - “строковый литерал”</div>
    <p class="no_mb">
        При использовании оператора <span class="code-word">new</span> создается новый объект String.
        Затем при помощи метода <span class="code-word">intern()</span> эту строку можно поместить в пул
        или же получить из пула ссылку на другой объект String с таким же значением;
    </p>
    <div class="code">
        <p>String q = "I'm";</p>
        <p>String w = "I'm";</p>
        <p>String r = new String("I'm");</p>
        <p>String t = r.intern();</p>
        <p>System.out.println("q==w: " + (q==w)); //true</p>
        <p>System.out.println("q==r: " + (q==r)); //false</p>
        <p>System.out.println("q==t: " + (q==t)); //true</p>
    </div>
    <p>Пул строк является примером паттерна «Приспособленец» (Flyweight).</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Почему String неизменяемый и финализированный класс?</h1>
    <ul>
        <li>
            Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина
            сохраняет больше свободного места в Heap, поскольку разные строковые переменные указывают
            на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не
            было бы возможным, потому что изменение значения одной переменной отразилось бы также и на
            остальных переменных, ссылающихся на эту строку.
        </li>
        <li>
            Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения.
            Например, имя пользователя базы данных и пароль передаются строкой для получения соединения
            с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как
            строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник
            может изменить значение ссылки и вызвать проблемы в безопасности приложения.
        </li>
        <li>
            Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один
            экземпляр строки может быть совместно использован различными потоками.
        </li>
        <li>
            Строки используются classloader-ом и неизменность обеспечивает правильность загрузки класса.
        </li>
        <li class="main-mind">
            Поскольку строка неизменяемая, её hashCode() кэшируется в момент создания и нет необходимости
            рассчитывать его снова. Это делает строку отличным кандидатом для ключа в HashMap т.к. его
            обработка происходит быстрее.
        </li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Какая основная разница между String, StringBuffer, StringBuilder?</h1>
    <p>
        Класс <span class="bold">String</span>String является неизменяемым (<span class="bold">immutable</span>) -
        модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.
    </p>
    <p>
        Класс <span class="bold">StringBuffer изменяемый</span> - использовать StringBuffer следует тогда, когда
        необходимо
        часто модифицировать содержимое. <span class="bold">Потокобезопасный</span>. <span
            class="bold">Синхронизирован</span>ные методы работают <span class="bold">медленнее</span> не
        сихнронизированных.
    </p>
    <p>
        Класс <span class="bold">StringBuilder</span> был добавлен в Java 5 и он во всем идентичен классу StringBuffer
        за исключением того, что он <span class="bold">не синхронизирован</span> и поэтому его методы выполняются
        значительно <span class="bold">быстрей</span>.
    </p>
    <p>
        Класс <span class="bold">StringJoiner</span> используется, чтобы создать последовательность строк, разделенных
        разделителем с возможностью присоединить к полученной строке префикс и суффикс:
    </p>
    <div class="code">
        <p>StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");</p>
        <p>for (String s : "Hello the brave world".split(" ")) {</p>
        <p class="tab-1">joiner.add(s);</p>
        <p>}</p>
        <p>System.out.println(joiner); //prefix-Hello.the.brave.world-suffix</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1>Что такое сигнатура метода?</h1>
    <p>
        <span>Сигнатура</span>
        - название метода и типы параметров в определенном порядке
    </p>
    <div class="code">public void method(double a, int b)</div>
    <p> Контракт метода - эксепшены.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1>Каким образом переменные передаются в методы, по значению или по ссылке?</h1>
    <p class="main-mind">Java передает параметры по значению. Всегда.</p>
    <div class="code no_mb">
        <p>int х = 3;</p>
        <p>int у = х;</p>
    </div>
    <p>Скопировать значение внутри х и записать эту копию в у.</p>
    <div class="code no_mb">
        <p>Cat A = new Cat ();</p>
        <p>Cat B = A;</p>
    </div>
    <p>
        Ссылка А копируется в ссылку B. К объекту это не относится — у нас по-прежнему всего один объект.
        Но теперь есть две различных ссылки, контролирующие один и тот же объект Cat.
    </p>


    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../java_base/">JAVA Base</a>
    <a class="navi-button navi--next" href="">ООП в JAVA</a>
</div>

<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

</html>