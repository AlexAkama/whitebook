<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/html">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Collections</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Collections</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>collections</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Базовые интерфейсы</a></li>
        <li><a href="#q2">Интерфейс Collection</a></li>
        <li><a href="#q3">Реализации интерфейса List</a></li>
        <li><a href="#q4">Реализации интерфейса Set</a></li>
        <li><a href="#q5">Реализации интерфейса Queue</a></li>
        <li><a href="#q6">Реализации интерфейса Map</a></li>
        <li><a href="#q7">Другие коллекции</a></li>
        <li><a href="#q8">Синхронизированные коллекции</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1>Базовые интерфейсы</h1>
    <p>
        В библиотеке коллекций Java существует <strong>два базовых интерфейса</strong>,
        реализации которых и представляют совокупность всех классов коллекций:
    </p>
    <ol class="sparse-li">
        <li>
            <strong>Collection</strong> - коллекция содержит набор объектов (элементов). Здесь определены основные
            методы для манипуляции с
            данными, такие как вставка (add, addAll), удаление (remove, removeAll, clear), поиск (contains)
        </li>
        <li>
            <p>
                <strong>Map</strong> - описывает коллекцию, состоящую из пар “ключ — значение”. У каждого ключа только
                одно значение, что соответствует математическому понятию однозначной функции или отображения.
            </p>
            <p>
                Такую коллекцию часто называют еще словарем (dictionary) или ассоциативным массивом (associative array).
            </p>
            <p>Никак НЕ относится к интерфейсу Collection и является самостоятельным.</p>
        </li>
    </ol>

    <p class="no_mb">
        Хотя фреймворк называется Java Collections Framework, интерфейс Map и его реализации входят во фреймворк также!
    </p>
    <p class="no_mb">Интерфейсы Collection и Map являются базовыми, но они не есть единственными.</p>
    <p>Их расширяют другие интерфейсы, добавляющие дополнительный функционал.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>Интерфейс Collection</h1>
    <div class="image-box">
        <img class="image" src="./img/collection.png" alt="Интерфейс Collection">
    </div>
    <p class="no_mb">
        Интерфейс <strong>Collection</strong> не является базовым. Он <strong>расширяет</strong>
        интерфейс <strong>Iterable</strong>, у которого есть только один метод iterator().
    </p>
    <p>
        Это значит что любая коллекция будет возвращать итератор, а также ее можно без всяких трудностей использовать в
        конструкции foreach.
    </p>
    <p class="main-mind">
        Итератор – объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. Итератор это паттерн
        позволяющий получить доступ к элементам любой коллекции без вникания в суть ее реализации.
    </p>
    <p>Интерфейс Collection расширяют интерфейсы List, Set и Queue:</p>

    <ul class="sparse-li">
        <li>
            <p class="bold">List</p>
            <p>
                Это <strong>упорядоченная коллекция</strong>,
                в которой <strong>допустимы дублирующие значения</strong>.</p>
            <p>Иногда их называют последовательностями (sequence).</p>
            <p>
                Элементы такой коллекции <strong>пронумерованы</strong>,
                начиная от нуля, к ним <strong>можно обратиться по индексу</strong>.
            </p>
        </li>
        <li>
            <p class="bold">Set</p>
            <p>Описывает коллекцию, <strong>не содержащую повторяющихся элементов</strong>.</p>
            <p>Это соответствует математическому понятию множества (set).</p>
        </li>
        <li>
            <p class="bold">Queue</p>
            <p>
                <strong>Для хранения элементов в порядке, нужном для их обработки</strong>.
                В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции
                вставки, получения и контроля.
            </p>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Реализации интерфейса List</h1>
    <div class="image-box">
        <img class="image" src="./img/list.png" alt="Интерфейс List">
    </div>
    <p>
        Красным выделены интерфейсы, зеленым – абстрактные классы, а синим готовые реализации.
        Здесь не вся иерархия, а только основная её часть.
    </p>
    <p>
        Mежду интерфейсом и конкретной реализацией коллекции существует несколько абстрактных классов.
        Это сделано для того, что бы вынести общий функционал в абстрактный класс, таким образом реализовать повторное
        использование кода.
    </p>
    <p>
        <span class="bold">ArrayList</span> – пожалуй самая часто используемая коллекция. Он инкапсулирует в себе
        обычный массив, длина которого может увеличиваться при добавлении новых элементов. Так как ArrayList использует
        массив, то время доступа к элементу по индексу минимально (В отличии от LinkedList). При удалении произвольного
        элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево, при этом реальный размер
        массива (его емкость, capacity) не изменяется. Если при добавлении элемента, оказывается, что массив полностью
        заполнен, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого
        массива + новый, добавляемый элемент.
    </p>
    <p>
        <span class="bold">LinkedList</span> – Двусвязный список. Это структура данных, состоящая из узлов, каждый из
        которых содержит как
        собственно
        данные, так и две ссылки («связки») на следующий и предыдущий узел списка. Доступ к произвольному элементу
        осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за
        константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка
        вовсе не значит, что прийдется перебирать весь список в поисках последнего элемента).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Реализации интерфейса Set</h1>
    <div class="code">
        <img class="image" src="./img/set.png" alt="Интерфейс Set">
    </div>
    <p class="no_mb">
        <span class="bold">HashSet</span> – коллекция, не позволяющая хранить одинаковые объекты (как и любой Set).
    </p>
    <p class="no_mb">
        <strong>HashSet инкапсулирует в себе объект HashMap</strong> (то-есть использует для хранения хэш-таблицу).
    </p>
    <p class="no_mb">
        Хеш-таблица хранит информацию, используя, так называемый, механизм хеширования, в котором содержимое ключа
        используется для определения уникального значения, называемого хеш-кодом.
        Этот хеш-код затем применяется в качестве индекса, с которым ассоциируются данные, доступные по этому ключу.
    </p>
    <p class="no_mb">
        Если Вы хотите использовать HashSet для хранения объектов своих классов, то вы
        <strong>должны переопределить методы hashCode() и equals()</strong>, иначе два логически-одинаковых объекта
        будут считаться разными по хеш-коду, так как при добавлении элемента в коллекцию будет вызываться метод
        hashCode() класса Object (который скорее-всего вернет разный хэш-код для ваших объектов).
    </p>
    <p>
        Класс HashSet <strong>не гарантирует упорядоченности элементов</strong>, поскольку процесс
        хеширования сам по себе обычно не порождает сортированных наборов. Если нужны сортированные наборы, то
        лучшим выбором может быть другой тип коллекций - TreeSet.
    </p>
    <p>
        <span class="bold"> LinkedHashSet</span>
        – поддерживает связный список элементов набора <strong>в том порядке, в котором они вставлялись</strong>.
        Это позволяет организовать упорядоченную итерацию вставки в набор. То есть, когда идет перебор объекта класса
        LinkedHashSet с применением итератора, элементы извлекаются в том порядке, в каком они были добавлены.
    </p>
    <p>
        <span class="bold">TreeSet</span>
        – коллекция, которая хранит свои элементы в виде упорядоченного по значениям дерева. TreeSet инкапсулирует в
        себе TreeMap, который в свою очередь <strong>использует сбалансированное бинарное красно-черное дерево</strong>
        для хранения элементов. TreeSet хорош тем, что для операций add, remove и contains потребуется гарантированное
        время log(n).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Реализации интерфейса Queue</h1>
    <div class="image-box">
        <img class="image" src="./img/queue.png" alt="Интерфейс Queue">
    </div>
    <p>
        <span class="bold">PriorityQueue</span>
        – единственная прямая реализация интерфейса Queue (не считая LinkedList, который больше является
        списком, чем очередью).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Реализации интерфейса Map</h1>
    <p>
        Интерфейс Map соотносит уникальные ключи со значениями. Ключ — это объект, который используется для
        последующего извлечения данных. Задавая ключ и значение, можно помещать значения в объект карты.
        После того как это значение сохранено, можно получить его по ключу.
    </p>
    <div class="image-box">
        <img class="image" src="./img/map.png" alt="Интерфейс Map">
    </div>
    <hr>
    <h4>HashMap</h4>
    <p>Реализация основана на хэш-таблицах, реализует интерфейс Map. </p>
    <p><strong>Ключи и значения могут быть любых типов, в том числе и null</strong>.</p>
    <p>Данная реализация <strong>не дает гарантий относительно порядка элементов.</strong></p>
    <hr>
    <h4>LinkedHashMap</h4>
    <p>Реализация <strong>расширяет класс HashMap</strong>.</p>
    <p class="no_mb">
        Класс создает <strong>связный список</strong> элементов в карте, расположенных в том порядке,
        <strong>в котором они вставлялись</strong>. Это позволяет организовать перебор карты в порядке вставки.
    </p>
    <p class="example">
        То есть,когда происходит итерация по коллекционному представлению объекта класса LinkedHashMap, элементы будут
        возвращаться в том порядке, в котором они вставлялись.
    </p>
    <p>
        Также <strong>можно</strong> создать объект класса LinkedHashMap, возвращающий свои <strong>элементы в том
        порядке, в котором к ним в последний раз осуществлялся доступ</strong>.
    </p>
    <hr>
    <h4>TreeMap</h4>
    <p>
        <strong>Красно-черное дерево</strong> реализующее <strong>интерфейс NavigableMap</strong>.
    </p>
    <p>
        Коллекция <strong>сортируется по естественному</strong> упорядочиванию (natural ordering) ее ключей
        <strong>или</strong> используя <strong>интерфейс Comparator</strong> который задается при создании
        коллекции.
    </p>
    <p class="no_mb">Эта имплементация гарантирует время доступа log(n) для следующих методов: </p>
    <p>
        <span class="code-word example">containsKey</span>,
        <span class="code-word example">get</span>,
        <span class="code-word example">put</span>, и
        <span class="code-word example">remove</span>
    </p>
    <hr>
    <h4>WeakHashMap</h4>
    <p>
        Основан на хэш-таблицах, реализует интерфейс Map с так называемыми слабыми ключами (weak&nbsp;keys).
        Пара в данной коллекции автоматически будет удалена когда ссылка на ключ больше нигде не используется. Другими
        словами, нахождение объекта представленного ключем в данной коллекции не блокирует сборщик мусора от зачистки.
        После того как ключ будет зачищен вся пара будет удалена из коллекции.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Другие коллекции</h1>
    <p class="no_mb">Их еще называют "устаревшими".</p>
    <p class="example">Но нет аннотации @Deprecated или каких-либо иных, которые бы запрещали их использование в
        коде.</p>
    <hr>
    <h4>Enumeration</h4>
    <p>Интерфейс. В современной версии Java рекомендуется применять Iterator. </p>
    <hr>
    <h4>Dictionary</h4>
    <p class="no_mb">Абстрактный класс, аналог интерфейса Map.</p>
    <p>Реализации не имеет, рекомендуют его рассматривать как интерфейс. Наиболее известная реализация – Hashtable.</p>
    <hr>
    <h4>Hashtable</h4>
    <p class="no_mb">Класс. Имплементирует классическую структуру данных – хэш таблицу.</p>
    <p>В современных версиях Java рекомендуется использовать HashMap.</p>
    <hr>
    <h4>Vector</h4>
    <p class="no_mb">Класс. Аналог класса ArrayList. </p>
    <p>Поддерживает упорядоченный список элементов, хранимых во "внутреннем" массиве.</p>
    <hr>
    <h4>Stack</h4>
    <p class="no_mb">Класс. Производный от Vector.</p>
    <p>
        Добавлены методы "вталкивания" (push) и "выталкивания" (pop) элементов, так что список может трактоваться в
        терминах, принятых для описания структуры данных стека (stack).
    </p>
    <hr>
    <hr>
    <h4></h4>
    <p class="main-mind">
        Все методы Hashtable, Stack, Vector являются синхронизированными, что делает их менее эффективными в
        однопоточных приложениях.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Синхронизированные коллекции</h1>
    <p>
        Получить синхронизированные объекты коллекций можно используя <strong>статические методы класса
        Collections: </strong>
        <span class="code-word">synchronizedMap</span> и
        <span class="code-word">synchronizedList</span>
    </p>
    <div class="code">
        <p>Map m = Collections.synchronizedMap(new HashMap());</p>
        <p>List l = Collections.synchronizedList(new ArrayList());</p>
    </div>
    <p>
        Синхронизированные обрамления коллекций synchronizedMap и synchronizedList иногда называют условно потоко
        безопасными – все операции в отдельности потокобезопасны, но последовательности операций, где управляющий поток
        зависит от результатов предыдущих операций, могут быть причиной конкуренции за данные.
    </p>
    <p>
        Условная безопасность потоков, обеспечиваемая synchronizedList и synchronizedMap представляет скрытую угрозу –
        разработчики полагают, что, раз эти коллекции синхронизированы, значит, они полностью потокобезопасны, и
        пренебрегают должной синхронизацией составных операций. В результате, хотя эти программы и работают при лёгкой
        нагрузке, но при серьёзной нагрузке они могут начать выкидывать NullPointerException или
        ConcurrentModificationException.
    </p>
    <p>Кроме того всегда существует возможность "классической" синхронизации с помощью блока synchronized.</p>

    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../generics/">Дженерики</a>
    <a class="navi-button navi--next" href="../functional_interfaces/">Функциональные интерфейсы</a>
</div>


<footer>
        <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

</body>

<script src="../../../../js/script.js"></script>

</html>