<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA Collections</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Collections</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>collections</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Базовые интерфейсы</a></li>
        <li><a href="#q2">Интерфейс Collection</a></li>
        <li><a href="#q3">Реализации интерфейса List</a></li>
        <li><a href="#q4">Реализации интерфейса Set</a></li>
        <li><a href="#q5">Реализации интерфейса Queue</a></li>
        <li><a href="#q6">Реализации интерфейса Map</a></li>
        <li><a href="#q7">Другие коллекции</a></li>
        <li><a href="#q8">Синхронизированные коллекции</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1>Базовые интерфейсы</h1>
    <p>
        В библиотеке коллекций Java существует <strong>два базовых интерфейса</strong>,
        реализации которых и представляют совокупность всех классов коллекций:
    </p>
    <ol>
        <li class="mb10">
            <strong>Collection</strong> - коллекция содержит набор объектов (элементов). Здесь определены основные
            методы для манипуляции с
            данными, такие как вставка (add, addAll), удаление (remove, removeAll, clear), поиск (contains)
        </li>
        <li>
            <p>
                <strong>Map</strong> - описывает коллекцию, состоящую из пар “ключ — значение”. У каждого ключа только
                одно значение, что соответствует математическому понятию однозначной функции или отображения.
            </p>
            <p>
                Такую коллекцию часто называют еще словарем (dictionary) или ассоциативным массивом (associative array).
            </p>
            <p>Никак НЕ относится к интерфейсу Collection и является самостоятельным.</p>

        </li>
    </ol>

    <p class="no_mb">
        Хотя фреймворк называется Java Collections Framework, интерфейс Map и его реализации входят во фреймворк также!
    </p>
    <p class="no_mb">Интерфейсы Collection и Map являются базовыми, но они не есть единственными.</p>
    <p>Их расширяют другие интерфейсы, добавляющие дополнительный функционал.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>Интерфейс Collection</h1>
    <div class="image-box">
        <img class="image" src="./img/collection.png" alt="Интерфейс Collection">
    </div>
    <p class="no_mb">
        Интерфейс <strong>Collection</strong> не является базовым. Он <strong>расширяет</strong>
        интерфейс <strong>Iterable</strong>, у которого есть только один метод iterator().
    </p>
    <p>
        Это значит что любая коллекция будет возвращать итератор, а также ее можно без всяких трудностей использовать в
        конструкции foreach.
    </p>
    <p class="main-mind">
        Итератор – объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. Итератор это паттерн
        позволяющий получить доступ к элементам любой коллекции без вникания в суть ее реализации.
    </p>
    <p>Интерфейс Collection расширяют интерфейсы List, Set и Queue:</p>

    <ul>
        <li class="mb10">
            <p class="bold">List</p>
            <p>
                Это <strong>упорядоченная коллекция</strong>,
                в которой <strong>допустимы дублирующие значения</strong>.</p>
            <p>Иногда их называют последовательностями (sequence).</p>
            <p>
                Элементы такой коллекции <strong>пронумерованы</strong>,
                начиная от нуля, к ним <strong>можно обратиться по индексу</strong>.
            </p>
        </li>
        <li class="mb10">
            <p class="bold">Set</p>
            <p>Описывает коллекцию, <strong>не содержащую повторяющихся элементов</strong>.</p>
            <p>Это соответствует математическому понятию множества (set).</p>
        </li>
        <li>
            <p class="bold">Queue</p>
            <p>
                <strong>Для хранения элементов в порядке, нужном для их обработки</strong>.
                В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции
                вставки, получения и контроля.
            </p>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Реализации интерфейса List</h1>
    <div class="image-box">
        <img src="./img/list.png" alt="Интерфейс List">
    </div>
    <p>
        Красным выделены интерфейсы, зеленым – абстрактные классы, а синим готовые реализации.
        Здесь не вся иерархия, а только основная её часть.
    </p>
    <p>
        Mежду интерфейсом и конкретной реализацией коллекции существует несколько абстрактных классов.
        Это сделано для того, что бы вынести общий функционал в абстрактный класс, таким образом реализовать повторное
        использование кода.
    </p>
    <p>
        <span class="bold">ArrayList</span> – пожалуй самая часто используемая коллекция. Он инкапсулирует в себе
        обычный массив, длина которого может увеличиваться при добавлении новых элементов. Так как ArrayList использует
        массив, то время доступа к элементу по индексу минимально (В отличии от LinkedList). При удалении произвольного
        элемента из списка, все элементы находящиеся «правее» смещаются на одну ячейку влево, при этом реальный размер
        массива (его емкость, capacity) не изменяется. Если при добавлении элемента, оказывается, что массив полностью
        заполнен, будет создан новый массив размером (n * 3) / 2 + 1, в него будут помещены все элементы из старого
        массива + новый, добавляемый элемент.
    </p>
    <p>
        <span class="bold">LinkedList</span> – Двусвязный список. Это структура данных, состоящая из узлов, каждый из
        которых содержит как
        собственно
        данные, так и две ссылки («связки») на следующий и предыдущий узел списка. Доступ к произвольному элементу
        осуществляется за линейное время (но доступ к первому и последнему элементу списка всегда осуществляется за
        константное время — ссылки постоянно хранятся на первый и последний, так что добавление элемента в конец списка
        вовсе не значит, что прийдется перебирать весь список в поисках последнего элемента).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Реализации интерфейса Set</h1>
    <div class="code">
        <img src="./img/set.png" alt="Интерфейс Set">
    </div>
    <p class="no_mb">
        <span class="bold">HashSet</span> – коллекция, не позволяющая хранить одинаковые объекты (как и любой Set).
    </p>
    <p class="no_mb">
        <strong>HashSet инкапсулирует в себе объект HashMap</strong> (то-есть использует для хранения хэш-таблицу).
    </p>
    <p class="no_mb">
        Хеш-таблица хранит информацию, используя, так называемый, механизм хеширования, в котором содержимое ключа
        используется для определения уникального значения, называемого хеш-кодом.
        Этот хеш-код затем применяется в качестве индекса, с которым ассоциируются данные, доступные по этому ключу.
    </p>
    <p class="no_mb">
        Если Вы хотите использовать HashSet для хранения объектов своих классов, то вы
        <strong>должны переопределить методы hashCode() и equals()</strong>, иначе два логически-одинаковых объекта
        будут считаться разными по хеш-коду, так как при добавлении элемента в коллекцию будет вызываться метод
        hashCode() класса Object (который скорее-всего вернет разный хэш-код для ваших объектов).
    </p>
    <p>
        Класс HashSet <strong>не гарантирует упорядоченности элементов</strong>, поскольку процесс
        хеширования сам по себе обычно не порождает сортированных наборов. Если нужны сортированные наборы, то
        лучшим выбором может быть другой тип коллекций - TreeSet.
    </p>
    <p>
        <span class="bold"> LinkedHashSet</span>
        – поддерживает связный список элементов набора <strong>в том порядке, в котором они вставлялись</strong>.
        Это позволяет организовать упорядоченную итерацию вставки в набор. То есть, когда идет перебор объекта класса
        LinkedHashSet с применением итератора, элементы извлекаются в том порядке, в каком они были добавлены.
    </p>
    <p>
        <span class="bold">TreeSet</span>
        – коллекция, которая хранит свои элементы в виде упорядоченного по значениям дерева. TreeSet инкапсулирует в
        себе TreeMap, который в свою очередь <strong>использует сбалансированное бинарное красно-черное дерево</strong>
        для хранения элементов. TreeSet хорош тем, что для операций add, remove и contains потребуется гарантированное
        время log(n).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Реализации интерфейса Queue</h1>
    <div class="image-box">
        <img src="./img/queue.png" alt="Интерфейс Queue">
    </div>
    <p>
        <span class="bold">PriorityQueue</span>
        – единственная прямая реализация интерфейса Queue (не считая LinkedList, который больше является
        списком, чем очередью).
    </p>

    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../generics/">Дженерики</a>
    <a class="navi-button navi--next" href="../functional_interfaces/">Функциональные интерфейсы</a>
</div>


<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

<script src="../../../../js/script.js"></script>

</html>