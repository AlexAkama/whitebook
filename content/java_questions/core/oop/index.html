<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ООП</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">ООП</h1>
    <div class="after-h1">Вопросы для собеседования</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>ооп</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Что такое ООП?</a></li>
        <li><a href="#q2">Какие преимущества у ООП?</a></li>
        <li><a href="#q3">Какие недостатки у ООП?</a></li>
        <li><a href="#q4">Назовите основные принципы ООП.</a></li>
        <li><a href="#q5">Что такое инкапсуляция? (с&nbsp;примером)</a></li>
        <li><a href="#q6">Что такое наследование?(с&nbsp;примером)</a></li>
        <li><a href="#q7">Что такое полиморфизм? (с&nbsp;примером)</a></li>
        <li><a href="#q8">Что такое ассоциация, агрегация и композиция?</a></li>
        <li><a href="#q9">Расскажите про раннее (статическое) и позднее (динамическое) связывание.</a></li>
        <li><a href="../../../theory/#solid" target="_blank">SOLID</a></li>
        <li><a href="#q11">REST</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1><a href="#">Что такое ООП?</a></h1>
    <p class="main-mind">
        Объектно-ориентированное программирование (ООП) — методология программирования,
        основанная на представлении программы в виде совокупности объектов, каждый из которых
        является экземпляром определенного класса, а классы образуют иерархию наследования.
    </p>
    <ul>
        <li>
            объектно-ориентированное программирование использует в качестве основных логических
            конструктивных элементов объекты, а не алгоритмы;
        </li>
        <li>каждый объект является экземпляром определенного класса</li>
        <li>классы образуют иерархии.</li>
    </ul>
    <p>
        Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями.
        Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать
        ему сообщение, в ответ на которое, объект может изменить собственное состояние.
    </p>

    <p>
        Много букф:
        <a href="https://habr.com/ru/articles/463125/" target="_blank">ООП в картинках</a>
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1 class="no_mb"><a href="#">Какие преимущества у&nbsp;ООП?</a></h1>
    <h3>Преимущества ООП:</h3>
    <ul>
        <li>Возможность легкой модификации (при грамотном анализе и проектировании)</li>
        <li>Возможность отката при наличии версий</li>
        <li>Более легкая расширяемость</li>
        <li>
            «Более естественная» декомпозиция (разделение целого на части) программного
            обеспечения, которая существенно облегчает его разработку «слабая связанность кода».
        </li>
        <li>
            Сокращение количества межмодульных вызовов и уменьшение объемов информации,
            передаваемой между модулями.
        </li>
        <li>Увеличивается показатель повторного использования кода.</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1 class=""><a href="#">Какие недостатки у&nbsp;ООП?</a></h1>
    <h3>Недостатки ООП:</h3>
    <ul>
        <li>Требуется другая квалификация</li>
        <li>Резко увеличивается время на анализ и проектирование систем</li>
        <li>Увеличение времени выполнения</li>
        <li>Размер кода увеличивается</li>
        <li>Неэффективно с точки зрения памяти (мертвый код - тот, который не используется)</li>
        <li>Сложность распределения работ на начальном этапе</li>
        <li>Себестоимость больше</li>
        <li>Скорость</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1 class="no_mb"><a href="#">Назовите основные принципы ООП?</a></h1>
    <h3>Принципы:</h3>
    <ul class="tab-2">
        <li><a href="#q5">инкапсуляция</a></li>
        <li><a href="#q6">наследование</a></li>
        <li><a href="#q7">полиморфизм</a></li>
    </ul>
    <p>Хорошие примеры: <a href="https://habr.com/ru/articles/87205/" target="_blank">ООП с примерами (часть 2)</a></p>
    <p>Альтернативное мнение об ООП: <a href="https://habr.com/ru/articles/147927/" target="_blank">Я не знаю ООП</a>
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1><a href="#">Что такое инкапсуляция?</a></h1>
    <div class="after-h1 tab-2">
        <ul>
            <li><a href="#q6">наследование</a></li>
            <li><a href="#q7">полиморфизм</a></li>
        </ul>
    </div>
    <p class="main-mind">
        Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в
        классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при
        последующем использовании.
    </p>
    <p class="example no_mb">В JAVA реализуется с помощью модификаторов доступа и геттеров/сеттеров.</p>
    <p> Модификаторы доступа (Access modifiers): </p>
    <ul class="tab-2 sparse-li">
        <li>
            <p><span class="accent-mono">public</span></p>
            <p>
                публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны
                другим классам из текущего пакета и из внешних пакетов.
            </p>
        </li>
        <li>
            <p><span class="accent-mono">private</span></p>
            <p>
                закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса
                доступен только из кода в том же классе.
            </p>
        </li>
        <li>
            <p><span class="accent-mono">protected</span></p>
            <p>
                такой класс или член класса доступен из любого места в текущем классе или пакете или в производных
                классах, даже если они находятся в других пакетах.
            </p>
        </li>
        <li>
            <p><span class="accent-mono">default (package visible)</span></p>
            <p>
                отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по
                умолчанию. Такие поля или методы видны всем классам в текущем пакете.
            </p>
        </li>
    </ul>
    <p><a href="../classes/index.html#q7" target="_blank">Табличка модификаторов доступа</a></p>
    <p class="no_mb">
        Определение переменных класса как private означает, что они не могут быть доступны напрямую из внешнего кода.
    </p>
    <p>
        Доступ к таким переменным обычно предоставляется через "геттеры" и "сеттеры" (getters&nbsp;and&nbsp;setters)
        - методы, которые возвращают значение переменной или устанавливают его значение.
    </p>
    <p><span class="bold">Цель инкапсуляции</span> — уйти от зависимости внешнего интерфейса класса (то, что могут
        использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за
        собой изменение внешнего поведения класса.
    </p>
    <p><span class="bold">Состояние объекта</span> – это значение всех его полей. Объект не должен изменяться чем то из
        вне,
        кроме своих методов. Убрать возможность случайного/умышленного изменения объекта.
    </p>
    <p class="example">
        Пример – кондиционер (берем пульт включаем холод - запускаются разные процессы, которые не
        показываются пользователю), пользователю на пульте показывается температура воздуха на
        выходе, остальное все скрыто.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1><a href="#">Что такое наследование?</a></h1>
    <div class="after-h1 tab-2">
        <ul>
            <li><a href="#q5">инкапсуляция</a></li>
            <li><a href="#q7">полиморфизм</a></li>
        </ul>
    </div>
    <p class="main-mind">
        Наследование - свойство системы, позволяющее описать новый класс на основе уже
        существующего с частично или полностью заимствующейся функциональностью.
    </p>
    <p class="no_mb">Наследование форма отношения «is a» (является).</p>
    <p class="no_mb">
        Класс наследника является классом предка, но класс предка не является классом наследника: собака – наследник
        животного, но животное не наследник собаки. Наследник – более «узкий» класс.
    </p>
    <p class="example">
        Пример: кондиционер наследуется от холодильной техники.
    </p>
    <p>
        Есть <span class="bold">одиночное</span> и <span class="bold">множественное</span>.
    </p>
    <p class="term no_mb">
        <span>Множественное наследование</span>
        - это концепция, согласно которой класс может наследовать поведение и функциональность от
        более чем одного суперкласса.
    </p>
    <p class="example">
        Это широко используется в некоторых языках программирования, таких как C++ и Python.
    </p>
    <p class="main-mind">В Java множественное наследование ограничено.</p>
    <p>
        В Java множественное наследование для классов не поддерживается, чтобы избежать проблем, связанных с
        "проблемой ромба" (diamond problem), когда класс наследуется от двух классов, которые имеют одинаковый метод, и
        неясно, какую версию метода следует использовать.
    </p>
    <p>
        Тем не менее, в Java можно реализовать концепцию множественного наследования с помощью интерфейсов. Класс может
        реализовывать любое количество
        <a href="../classes/index.html#q10" target="_blank">интерфейсов</a>,
        а каждый интерфейс может определять методы, которые должен реализовать класс.
    </p>
    <p>
        Также, начиная с Java 8, интерфейсы могут содержать реализации методов по умолчанию, что позволяет классам
        "наследовать" поведение от нескольких источников.
    </p>

    <p class="no_mb">Запретить наследование:</p>
    <p class="code">public final class</p>
    <p class="no_mb">
        Класс, от которого производится наследование, называется предком, базовым или
        родительским. Новый класс – потомком, наследником или производным классом.
    </p>
    <p class="code">class Employee extends Person {}</p>
    <p><span class="bold">Делегирование</span> – один класс вызывает другой класс, не связанный наследованием.</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1><a href="#">Что такое полиморфизм?</a></h1>
    <div class="after-h1 tab-2">
        <ul>
            <li><a href="#q5">инкапсуляция</a></li>
            <li><a href="#q6">наследование</a></li>
        </ul>
    </div>
    <p class="main-mind">
        Полиморфизм - это свойство системы использовать объекты с одинаковым
        интерфейсом без информации о типе и внутренней структуре объекта.
    </p>
    <p class="example">Пример: интерфейс «охлаждать» имеет место в технике, холодное пиво)) и т.п.</p>
    <p>
        Все if –ы можно заменить на полиморфизм (<a
            href="https://refactoring.guru/ru/replace-conditional-with-polymorphism"
            target="_blank">способ рефакторинга</a>).
    </p>
    <p>Позволяет уменьшать размер программы.</p>
    <p class="no_mb">
        Преимуществом полиморфизма является то, что он помогает снижать сложность программ,
        разрешая использование одного и того же интерфейса для задания единого набора действий.
        Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка
        программирования.
    </p>
    <p class="no_mb">
        Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта
        базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться
        по ссылке родительского типа).
    </p>
    <p class="code">Unit ref = new Refrigerator("ref", 24);</p>
    <p class="no_mb">
        <span class="bold">Полиморфная переменная</span> - это переменная, которая может принимать значения разных
        типов.
    </p>
    <p>
        <span class="bold">Полиморфная функция</span> - функция у которой хотя бы один аргумент является полиморфной
        переменной.
    </p>
    <p class="no_mb">Выделяют два вида полиморфных функций:</p>
    <ul>
        <li>
            <span class="bold">ad hoc</span>
            - функция ведет себя по разному для разных типов аргументов.
            <p class="example no_mb"> (например, функция draw() — рисует по разному фигуры разных типов); </p>
        </li>
        <li>
            <span class="bold">параметрический</span>
            - функция ведет себя одинаково для аргументов разных типов.
            <p class="example no_mb">(например, функция add() — одинаково кладет в контейнер элементы разных типов).</p>
        </li>
    </ul>
    <p class="main-mind">
        Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из
        рассмотрения частные и незначимые.
    </p>
    <p class="no_mb"> Соответственно, абстракция – это набор всех таких характеристик. </p>
    <p class="example">(телефон звонил в 19 веке и в 21, функция выделена из разных сложных процессов).</p>
    <p>Объект - Класс - Абстрактный класс - Интерфейс(макс. уровень абстракции).</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1><a href="#">Что такое ассоциация, агрегация и композиция?</a></h1>
    <p class="main-mind no_mb">Ассоциация обозначает связь между объектами.</p>
    <p>Композиция и агрегация — частные случаи ассоциации «часть-целое».</p>
    <div>
        <p class="no_mb">
            <span class="bold">Агрегация</span>
            предполагает, что объекты связаны взаимоотношением
            <span class="bold">«part-of» (часть)</span>.
        </p>
        <p>
            По-другому, жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, и может
            использоваться другими объектами.
        </p>
    </div>
    <div>
        <p class="no_mb"><span class="bold">Композиция</span> более строгий вариант агрегации. </p>
        <p class="no_mb">
            Дополнительно к требованию «part-of» накладывается условие, что
            <span class="bold">экземпляр «части» может входить только в одно целое</span>
            (или никуда не входить), в то время как в случае агрегации экземпляр
            «части» может входить в несколько целых.
        </p>
        <p>
            Другими словами, жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.
        </p>
    </div>
    <p class="example">
        Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в
        другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время
        мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.
    </p>
    <p class="main-mind">
        «Является» подразумевает наследование.<br>
        «Имеет» подразумевает ассоциацию (агрегацию или композицию).
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1><a href="#">Расскажите про раннее (статическое) и позднее (динамическое) связывание.</a></h1>
    <p class="main-mind">Связывание - присоединение вызова метода к телу метода.</p>
    <p class="no_mb"><span class="bold">Раннее (статическое) связывание</span>
        - проводится компилятором (компоновщиком) перед запуском программы.
    </p>
    <p class="example">Например, перегрузка методов; приватные, статические и final методы.</p>
    <p class="no_mb"><span class="bold">Позднее (динамическое) связывание</span>
        - непосредственно во время выполнения программы (runtime), в зависимости от типа объекта.
    </p>
    <p class="example">
        Например, переопределение методов. Компилятор не знает тип объекта, но механизм вызова методов определяет его и
        вызывает соответствующее тело метода.
    </p>
    <p class="main-mind">
        Для всех методов Java используется механизм позднего (динамического) связывания, если
        только метод не был объявлен как final (приватные методы являются final по умолчанию).
    </p>
    <div class="code"><pre>public class <class>Main</class> {
    public static void <method>main</method>(String[] args) {
        Insurance current = new CarInsurance();

        <rem>// Динамическое связывание на основе объекта потому что метод premium() нестатический</rem>
        int premium = current.premium();

        <rem>// Статическое связывание на основе класса, метод category() статический (принадлежит классу)</rem>
        String category = current.category();

        System.out.println("premium : " + premium);
        System.out.println("category : " + category);
    }
}

class <class>Insurance</class> {
    public static final int LOW = 100;

    public static String <method>category()</method> { return "Insurance"; }
    public int <method>premium()</method> { return LOW; }
}

class <class>CarInsurance</class> extends <class>Insurance</class> {
    public static final int HIGH = 200;

    public static String <method>category()</method> { return "Car Insurance"; }
    public int <method>premium()</method> { return HIGH; }
}</pre>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1><a href="#">REST</a></h1>
    <p>
        <span class="accent-mono">REST (Representational state transfer)</span>
        – это стиль архитектуры программного обеспечения для распределенных
        систем, таких как World Wide Web, который, как правило, используется для построения веб-служб.
    </p>
    <p> Системы, поддерживающие REST, называются RESTful-системами. </p>
    <p>
        В общем случае REST является очень простым интерфейсом управления информацией без использования каких-то
        дополнительных внутренних прослоек. Каждая единица информации однозначно определяется глобальным
        идентификатором, таким как URL. Каждая URL в свою очередь имеет строго заданный формат.
    </p>
    <p>
        Отсутствие дополнительных внутренних прослоек означает передачу данных в том же виде, что и сами данные. Т.е. мы
        не заворачиваем данные во что либо.
    </p>
    <p>
        Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом
        для единицы данных.
    </p>
    <p>
        Как происходит управление информацией сервиса – это целиком и полностью основывается на протоколе передачи
        данных. Наиболее распространенный протокол конечно же HTTP.
    </p>
    <p>
        Архитектура REST очень проста в плане использования. По виду пришедшего запроса сразу можно определить, что он
        делает, не разбираясь в форматах (в отличие от SOAP, XML-RPC). Данные передаются без применения дополнительных
        слоев, поэтому REST считается менее ресурсоемким, поскольку не надо парсить запрос чтоб понять что он должен
        сделать и не надо переводить данные из одного формата в другой.
    </p>
    <a class="link-to-source" href="https://habr.com/ru/post/38730/" target="_blank">источник</a>

    <a href="#" class="button button--top"></a>
</section>


<div class="navi">
    <p></p>
    <a class="navi-button navi--next" href="../base/">Base</a>
</div>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм">
        Алексей Маслов, 2021-2023
    </a></div>
</footer>

</body>

</html>