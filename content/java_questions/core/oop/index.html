<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ООП</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">ООП</h1>
    <div class="after-h1">Вопросы для собеседования</div>
    <div class="breadcrumbs">
        <p><a href="../../../../">главная</a></p>
        <p><a href="../../">Questions</a></p>
        <p><a href="..">core</a></p>
        <p>ооп</p>
    </div>
    <h4 class="no_mt">Вопросы:</h4>
    <ol class="menu">
        <li><a href="#q1">Что такое ООП?</a></li>
        <li><a href="#q2">Какие преимущества у ООП?</a></li>
        <li><a href="#q3">Какие недостатки у ООП?</a></li>
        <li><a href="#q4">Назовите основные принципы ООП.</a></li>
        <li><a href="#q5">Что такое инкапсуляция? (с&nbsp;примером)</a></li>
        <li><a href="#q6">Что такое наследование?(с&nbsp;примером)</a></li>
        <li><a href="#q7">Что такое полиморфизм? (с&nbsp;примером)</a></li>
        <li><a href="#q8">Что такое ассоциация, агрегация и композиция?</a></li>
        <li><a href="#q9">Расскажите про раннее (статическое) и позднее (динамическое) связывание.</a></li>
        <li><a href="../../../theory/#solid">SOLID</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1>Что такое ООП?</h1>
    <p class="main-mind">
        Объектно-ориентированное программирование (ООП) — методология программирования,
        основанная на представлении программы в виде совокупности объектов, каждый из которых
        является экземпляром определенного класса, а классы образуют иерархию наследования.
    </p>
    <ul>
        <li>
            объектно-ориентированное программирование использует в качестве основных логических
            конструктивных элементов объекты, а не алгоритмы;
        </li>
        <li>каждый объект является экземпляром определенного класса</li>
        <li>классы образуют иерархии.</li>
    </ul>
    <p>
        Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями.
        Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать
        ему сообщение, в ответ на которое, объект может изменить собственное состояние.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1 class="no_mb">Какие преимущества у&nbsp;ООП?</h1>
    <h3>Преимущества ООП:</h3>
    <ul>
        <li>Возможность легкой модификации (при грамотном анализе и проектировании)</li>
        <li>Возможность отката при наличии версий</li>
        <li>Более легкая расширяемость</li>
        <li>
            «Более естественная» декомпозиция (разделение целого на части) программного
            обеспечения, которая существенно облегчает его разработку «слабая связанность кода».
        </li>
        <li>
            Сокращение количества межмодульных вызовов и уменьшение объемов информации,
            передаваемой между модулями.
        </li>
        <li>Увеличивается показатель повторного использования кода.</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1 class="">Какие недостатки у&nbsp;ООП?</h1>
    <h3>Недостатки ООП:</h3>
    <ul>
        <li>Требуется другая квалификация</li>
        <li>Резко увеличивается время на анализ и проектирование систем</li>
        <li>Увеличение времени выполнения</li>
        <li>Размер кода увеличивается</li>
        <li>Неэффективно с точки зрения памяти (мертвый код - тот, который не используется)</li>
        <li>Сложность распределения работ на начальном этапе</li>
        <li>Себестоимость больше</li>
        <li>Скорость</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1 class="no_mb">Назовите основные принципы ООП?</h1>
    <h3>Принципы:</h3>
    <ul>
        <li>инкапсуляция</li>
        <li>наследование</li>
        <li>полиморфизм</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Что такое инкапсуляция?</h1>
    <p class="main-mind">
        Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в
        классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при
        последующем использовании.
    </p>
    <p class="no_mb">
        Модификаторы доступа (Access modifiers: private, default (package visible), protected, public)
    </p>
    <p>Геттеры и Сеттеры (Getters and Setters)</p>
    <p><strong>Цель инкапсуляции</strong> — уйти от зависимости внешнего интерфейса класса (то, что могут
        использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за
        собой изменение внешнего поведения класса.
    </p>
    <p><strong>Состояние объекта</strong> – это значение всех его полей. Объект не должен изменяться чем то из вне,
        кроме своих методов. Убрать возможность случайного/умышленного изменения объекта.
    </p>
    <p class="example">
        Пример – кондиционер (берем пульт включаем холод - запускаются разные процессы, которые не
        показываются пользователю), пользователю на пульте показывается температура воздуха на
        выходе, остальное все скрыто.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Что такое наследование?</h1>
    <p class="main-mind">
        Наследование - свойство системы, позволяющее описать новый класс на основе уже
        существующего с частично или полностью заимствующейся функциональностью.
    </p>
    <p class="no_mb">Наследование форма отношения «is a» (является).</p>
    <p>
        Класс наследника является классом предка, но класс предка не является классом наследника: собака – наследник
        животного, но животное не наследник собаки. Наследник – более «узкий» класс.
    </p>
    <p class="example">
        Пример: кондиционер наследуется от холодильной техники.
    </p>
    <p class="no_mb">
        Есть <strong>одиночное</strong> и <strong>множественное</strong> наследование
        (класс наследуется от нескольких классов).
    </p>
    <p>Проблема – ромбовидное наследование: у одного базового класса есть два наследника, а у
        наследника этих двух классов свой наследник, какая реализация попадет в последний – ХЗ.
    </p>
    <p class="main-mind">В Java множественное наследование ограничено.</p>
    <p class="no_mb">Запретить наследование:</p>
    <p class="code">public final class</p>
    <p class="no_mb">
        Класс, от которого производится наследование, называется предком, базовым или
        родительским. Новый класс – потомком, наследником или производным классом.
    </p>
    <p class="code">class Employee extends Person {}</p>
    <p><strong>Делегирование</strong> – один класс вызывает другой класс, не связанный наследованием.</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Что такое полиморфизм?</h1>
    <p class="main-mind">
        Полиморфизм - это свойство системы использовать объекты с одинаковым
        интерфейсом без информации о типе и внутренней структуре объекта.
    </p>
    <p class="example">Пример: интерфейс «охлаждать» имеет место в технике, холодное пиво)) и т.п.</p>
    <p>
        Все if –ы можно заменить на полиморфизм (
        <a href="https://refactoring.guru/ru/replace-conditional-with-polymorphism"
           target="_blank">способ рефакторинга</a>
        ).
    </p>
    <p>Позволяет уменьшать размер программы.</p>
    <p class="no_mb">
        Преимуществом полиморфизма является то, что он помогает снижать сложность программ,
        разрешая использование одного и того же интерфейса для задания единого набора действий.
        Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка
        программирования.
    </p>
    <p class="no_mb">
        Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта
        базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться
        по ссылке родительского типа).
    </p>
    <p class="code">Unit ref = new Refrigerator("ref", 24);</p>
    <p class="no_mb">
        <strong>Полиморфная переменная</strong> - это переменная, которая может принимать значения разных типов.
    </p>
    <p>
        <strong>Полиморфная функция</strong> - функция у которой хотя бы один аргумент является полиморфной переменной.
    </p>
    <p class="no_mb">Выделяют два вида полиморфных функций:</p>
    <ul>
        <li>
            <strong>ad hoc</strong>
            - функция ведет себя по разному для разных типов аргументов.
            <p class="example no_mb"> (например, функция draw() — рисует по разному фигуры разных типов); </p>
        </li>
        <li>
            <strong>параметрический</strong>
            - функция ведет себя одинаково для аргументов разных типов.
            <p class="example no_mb">(например, функция add() — одинаково кладет в контейнер элементы разных типов).</p>
        </li>
    </ul>
    <p class="main-mind">
        Абстрагирование – это способ выделить набор общих характеристик объекта, исключая из
        рассмотрения частные и незначимые.
    </p>
    <p class="no_mb"> Соответственно, абстракция – это набор всех таких характеристик. </p>
    <p class="example">(телефон звонил в 19 веке и в 21, функция выделена из разных сложных процессов).</p>
    <p>Объект - Класс - Абстрактный класс - Интерфейс(макс. уровень абстракции).</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Что такое ассоциация, агрегация и композиция?</h1>
    <p class="main-mind no_mb">Ассоциация обозначает связь между объектами.</p>
    <p>Композиция и агрегация — частные случаи ассоциации «часть-целое».</p>
    <p>
        <strong>Агрегация</strong>
        предполагает, что объекты связаны взаимоотношением
        <strong>«part-of» (часть)</strong>.
    </p>
    <p class="no_mb"><strong>Композиция</strong> более строгий вариант агрегации. </p>
    <p>
        Дополнительно к требованию «part-of» накладывается условие, что
        <strong>экземпляр «части» может входить только в одно целое</strong>
        (или никуда не входить), в то время как в случае агрегации экземпляр
        «части» может входить в несколько целых.
    </p>
    <p class="example">
        Например, книга состоит из страниц, и мы не можем вырвать страницу из книги и вложить в
        другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция. В тоже время
        мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.
    </p>
    <p class="main-mind">
        «Является» подразумевает наследование.<br>
        «Имеет» подразумевает ассоциацию (агрегацию или композицию).
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Расскажите про раннее (статическое) и позднее (динамическое) связывание.</h1>
    <p class="main-mind">Связывание - присоединение вызова метода к телу метода.</p>
    <p class="no_mb"><strong>Раннее (статическое) связывание</strong>
        - проводится компилятором (компоновщиком) перед запуском программы.
    </p>
    <p class="example">Например, перегрузка методов; приватные, статические и final методы.</p>
    <p class="no_mb"><strong>Позднее (динамическое) связывание</strong>
        - непосредственно во время выполнения программы (runtime), в зависимости от типа объекта.
    </p>
    <p class="example">
        Например, переопределение методов. Компилятор не знает тип объекта, но механизм вызова методов определяет его и
        вызывает соответствующее тело метода.
    </p>
    <p class="main-mind">
        Для всех методов Java используется механизм позднего (динамического) связывания, если
        только метод не был объявлен как final (приватные методы являются final по умолчанию).
    </p>
    <div class="code">
        <p>public class Main {</p>
        <p class="tab-1">public static void main(String[] args) {</p>
        <p class="tab-2">Insurance current = new CarInsurance();</p>
        <p>&nbsp;</p>
        <p class="tab-2">// Динамическое связывание на основе объекта потому что метод premium() нестатический</p>
        <p class="tab-2">int premium = current.premium();</p>
        <p class="tab-2">
            // Статическое связывание на основе класса, метод category() статический (принадлежит классу)
        </p>
        <p class="tab-2">String category = current.category();</p>
        <p>&nbsp;</p>
        <p class="tab-2">System.out.println("premium : " + premium);</p>
        <p class="tab-2">System.out.println("category : " + category);</p>
        <p class="tab-1">}</p>
        <p>}</p>
        <p>&nbsp;</p>
        <p>class Insurance{</p>
        <p class="tab-1">public static final int LOW = 100;</p>
        <p class="tab-1">public int premium() { return LOW; }</p>
        <p class="tab-1">public static String category() { return "Insurance"; }</p>
        <p>}</p>
        <p>&nbsp;</p>
        <p>class CarInsurance extends Insurance {</p>
        <p class="tab-1">public static final int HIGH = 200;</p>
        <p class="tab-1">public int premium() { return HIGH; }</p>
        <p class="tab-1">public static String category() { return "Car Insurance"; }</p>
        <p>}</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>


<div class="navi">
    <p></p>
    <a class="navi-button navi--next" href="../java_base/">JAVA Base</a>
</div>

<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

</html>