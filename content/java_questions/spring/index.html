<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPRING</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">SPRING</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="..">Questions</a></p>
        <p>spring</p>
    </div>
    <h3 class="no_mt">Вопросы:</h3>
    <ol class="menu">
        <li>
            <p>
                <a href="#q1">Инверсия контроля (<span>IoC</span>) и внедрение зависимостей (<span>DI</span>)</a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2 example"><a href="#q1_ioc">Inversion of Control (IoC)</a></p>
                <p class="tab-2 example"><a href="#q1_di">Dependency Injection (DI)</a></p>
            </div>
        </li>
        <li><a href="#q2"><span>IoC Container</span></a></li>
        <li><a href="#q3">Bean в Spring</a></li>
        <li><a href="#q4">Аннотация <span>@Bean</span></a></li>
        <li><a href="#q5">Аннотация <span>@Component</span></a></li>
        <li><a href="#q6">Отличия <span>@Bean</span> и <span>@Component</span></a></li>
        <li><a href="#q7">Отличия <span>@Service</span> и <span>@Repository</span></a></li>
        <li><a href="#q8">Аннотация <span>@Autowired</span></a></li>
        <li><a href="#q9">Аннотация <span>@Resource</span></a></li>
        <li><a href="#q10">Аннотация <span>@Inject</span></a></li>
        <li><a href="#q11">Аннотация <span>@Lookup</span></a></li>
        <li><a href="#q12">Можно ли вставить бин в статическое поле?</a></li>
    </ol>

    <table aria-label="Вопросы по Spring">

        <tr>
            <td>13.</td>
            <td>Расскажите про аннотации <span>@Primary</span> и <span>@Qualifier</span></td>
        </tr>
        <tr>
            <td>14.</td>
            <td>
                Как заинжектить примитив?
                <p>@Value</p>
                <p>@Value with SpEL</p>
                <p>@Value with Map</p>
                <p>@Value with Constructor</p>
                <p>@Value with Setter</p>
            </td>
        </tr>
        <tr>
            <td>15.</td>
            <td>
                Как заинжектить коллекцию?
                <p>Array Injection</p>
                <p>Collections Injection</p>
                <p>Коллекции бинов одного типа</p>
                <p>Использование @Qualifier</p>
                <p>Упорядочивание элементов массивов / списков</p>
            </td>
        </tr>
        <tr>

            <td>16.</td>
            <td>Расскажите про аннотацию <span>@Conditional</span></td>
        </tr>
        <tr>
            <td>17.</td>
            <td>Расскажите про аннотацию <span>@ComponentScan</span></td>
        </tr>
        <tr>
            <td>18.</td>
            <td>Расскажите про аннотацию <span>@Profile</span></td>
        </tr>
        <tr>
            <td>19.</td>
            <td>
                Расскажите про <span>ApplicationContext</span> и <span>BeanFactory</span>,
                чем отличаются? В каких случаях что стоит использовать?
                <p>BeanFactory</p>
                <p>ApplicationContext</p>
                <p>ApplicationContext vs. BeanFactory</p>
            </td>
        </tr>
        <tr>
            <td>20.</td>
            <td>
                Расскажите про жизненный цикл бина, аннотации <span>@PostConstruct</span> и <span>@PreDestroy</span>
                <div>
                    Жизненный цикл бинов
                    <ol>
                        <li>Парсирование конфигурации и создание BeanDefinition</li>
                        <li>Настройка созданных BeanDefinition</li>
                        <li>Создание кастомных FactoryBean (только для XML-конфигурации)</li>
                        <li>Создание экземпляров бинов</li>
                        <li>Настройка созданных бинов</li>
                        <li>Бины готовы к использованию</li>
                        <li>Закрытие контекста</li>
                    </ol>
                </div>
                <p>@PostConstruct</p>
                <p>@PreDestroy</p>


            </td>
        </tr>
        <tr>
            <td>21.</td>
            <td>
                Расскажите про scope бинов. Какой scope используется по умолчанию? Что изменилось в пятом Spring?
                <p>Singleton</p>
                <p>Prototype</p>
                <p>Request</p>
                <p>Session</p>
                <p>Application</p>
                <p>Websocket</p>
                <p>Custom thread scope</p>
            </td>
        </tr>
        <tr>
            <td>22.</td>
            <td>Что такое АОП? Как реализовано в спринге?</td>
        </tr>
        <tr>
            <td>23.</td>
            <td>Как спринг работает с транзакциями? Расскажите про аннотацию <span>@Transactional</span></td>
        </tr>
        <tr>
            <td>24.</td>
            <td>
                Расскажите про паттерн MVC, как он реализован в Spring?
                <p>MVC (Model-View-Controller)</p>
                <p>Spring Web MVC</p>
            </td>
        </tr>
        <tr>
            <td>25.</td>
            <td>Что такое <span>ViewResolver</span>?</td>
        </tr>
        <tr>
            <td>26.</td>
            <td>Расскажите про шаблон проектирования Front Controller, как он реализован в Spring?</td>
        </tr>
        <tr>
            <td>27.</td>
            <td>
                Чем отличаются <span>Model</span>, <span>ModelMap</span> и <span>ModelAndView</span>?
                <p>Model</p>
                <p>ModelMap</p>
                <p>ModelAndView</p>
            </td>
        </tr>
        <tr>
            <td>28.</td>
            <td>
                Расскажите про аннотации <span>@Controller</span> и <span>@RestController</span>. Чем они отличаются?
                Как вернуть ответ со своим статусом (например 213)?
                <p>@Controller</p>
                <p>@RestController</p>
                <p>ResponseEntity</p>
            </td>
        </tr>
        <tr>
            <td>29.</td>
            <td>
                В чем разница между <span>Filters</span>, <span>Listeners</span> и <span>Interceptors</span>?
                <p>Filter</p>
                <p>Interceptor</p>
                <p>Filter vs. Interceptor</p>
                <p>Java Listener</p>
            </td>
        </tr>
        <tr>
            <td>30.</td>
            <td>Можно ли передать в GET-запросе один и тот же параметр несколько раз? Как?</td>
        </tr>
        <tr>
            <td>31.</td>
            <td>Как работает <span>Spring Security</span>? Как сконфигурировать? Какие интерфейсы используются?</td>
        </tr>
        <tr>
            <td>32.</td>
            <td>Что такое <span>Spring Boot</span>? Какие у него преимущества? Как конфигурируется? Подробно</td>
        </tr>
        <tr>
            <td>33.</td>
            <td>Расскажите про нововведения Spring 5</td>
        </tr>
    </table>

</section>

<section class="container" id="q1">
    <h1>Инверсия контроля (IoC) и внедрение зависимостей (DI)</h1>
    <hr>
    <h3 id="q1_ioc">Inversion of Control (IoC)</h3>
    <p class="main-mind">Инверсия (от латинского inversio) - перестановка.</p>
    <p class="no_mb main-mind">
        Инверсия контроля (инверсия управления) — это <strong>принцип</strong> в разработке программного обеспечения,
        при котором <strong>управление объектами</strong> или частями программы
        <strong>передается контейнеру или фреймворку</strong>.
    </p>
    <p class="example">Чаще всего этот принцип используется в контексте объектно-ориентированного программирования.</p>
    <p>
        В отличие от традиционного программирования, в котором наш пользовательский код обращается напрямую к
        библиотекам, IoC позволяет фреймворку контролировать ход программы и обращаться к нашему коду, когда это
        необходимо. Для этого, фреймворки используют абстракции со встроенным дополнительным поведением. Если мы хотим
        добавить наше собственное поведение, нам нужно расширить классы фреймворка или подключить наши собственные
        классы.
    </p>
    <p class="no_mb">Преимущества этой архитектуры:</p>
    <ul class="tab-2">
        <li><strong>отделение выполнения задачи от ее реализации</strong>;</li>
        <li>легкое <strong>переключение между различными реализациями</strong>;</li>
        <li>большая <strong>модульность</strong> программы;</li>
        <li>
            более легкое <strong>тестирование</strong> программы путем изоляции компонента или проверки его
            зависимостей и обеспечения взаимодействия компонентов через контракты.
        </li>
    </ul>
    <p>
        Инверсия управления может быть достигнута с помощью различных механизмов, таких как: шаблон проектирования
        “Стратегия”, шаблон “Локатор служб”, шаблон “Фабрика” и внедрение зависимостей (DI).
    </p>
    <hr>
    <h3 id="q1_di">Dependency Injection (DI)</h3>
    <p class="main-mind">
        Внедрение зависимостей — это <strong>шаблон</strong> проектирования для реализации IoC,
        где <strong>инвертируемым (переопределяемым) элементом контроля является настройка зависимостей объекта</strong>.
    </p>
    <p>
        <strong>Соединение</strong> объектов с другими объектами или «внедрение»
        объектов в другие объекты <strong>выполняется <a href="#q2">контейнером IoC</a></strong>, а не самими объектами.
    </p>
    <p class="main-mind">
        В Spring Framework инверсия контроля достигается именно внедрением зависимостей.
    </p>
    <p class="main-mind">
        В Spring Framework инверсия контроля и внедрение зависимостей считаются одним и тем же.
    </p>
    <p>
        В Spring Framework внедрение зависимостей описывается как процесс, посредством которого <strong>объект
        определяет свои зависимости</strong> (то есть другие объекты, с которыми он работает) <strong>только через
        аргументы конструктора, аргументы фабричного метода или свойства</strong>, которые устанавливаются в экземпляре
        объекта после того, как он создан или возвращен из метода фабрики.
        После чего <strong>контейнер IoC внедряет</strong> эти зависимости в компонент <strong>при его создании</strong>.
    </p>
    <p>
        Мы можем создать зависимость объекта следующим традиционным способом,
        <strong>без использования принципа IoC</strong>:
    </p>
    <div class="code no_mb">
        <p>public class Store {</p>
        <p class="tab-1">private Item item;</p>
        <p class="tab-1">public Store() {</p>
        <p class="tab-2">item = new ItemImpl1();</p>
        <p class="tab-1">}</p>
        <p>}</p>
    </div>
    <p class="example">
        В приведенном выше примере мы создаем экземпляр конкретной реализации интерфейса Item (ItemImpl1) внутри самого
        класса Store.
    </p>

    <p>
        <strong>Используя DI</strong> , мы можем переписать пример без указания конкретной реализации Item, не создавая
        её внутри нашего объекта, а ожидая её получение извне (от внешнего фреймворка - контейнера IoC):
    </p>
    <div class="code no_mb">
        <p>public class Store {</p>
        <p class="tab-1">private Item item;</p>
        <p class="tab-1">public Store(Item item) {</p>
        <p class="tab-2">this.item = item;</p>
        <p class="tab-1">}</p>
        <p>}</p>
    </div>
    <p class="example">
        В данном случае инверсия контроля — это переход контроля над зависимостями от объекта Store к контейнеру IoC.
        Объект Store более не контролирует инстанцирование своего поля (зависимости) item, не создаёт этот объект
        самостоятельно, а делегирует этот процесс внешним силам - контейнеру IoC, который в нашем примере передаёт в
        конструктор Store любую из реализаций Item.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>IoC Container?</h1>
    <p>
        В Spring Framework IoC Container <strong> отвечает за создание, настройку и сборку объектов, известных как бины,
        а также за управление их жизненным циклом</strong>.
    </p>
    <p>Он (контейнер) представлен интерфейсом ApplicationContext.</p>
    <p>Spring Framework предоставляет несколько реализаций интерфейса ApplicationContext:</p>
    <ul class="tab-2 sparse-li">
        <li>
            <p>ClassPathXmlApplicationContext и FileSystemXmlApplicationContext</p>
            <p class="example">- для автономных приложений;</p>
        </li>
        <li>
            <p>WebApplicationContext</p>
            <p class="example">- для веб-приложений;</p>
        </li>
        <li>
            <p>AnnotationConfigApplicationContext</p>
            <p class="example">
                - для обычной Java-конфигурации,в качестве аргумента которому передается класс, либо список классов с
                аннотацией
                <an>@Configuration</an>
                , либо с любой другой аннотацией JSR-330, в том числе и
                <an>@Component</an>
                .
            </p>

        </li>
    </ul>

    <p>
        Контейнер получает инструкции о том, какие объекты создавать, настраивать и собирать, через метаданные
        конфигурации, которые представлены в виде XML, Java-аннотаций или Java-кода:
    </p>
    <ul class="tab-2 sparse-li">
        <li>XML - Метаданные считываются из файла с расширением *.xml;</li>
        <li>
            Java-аннотации - В Spring 2.5 появилась поддержка метаданных конфигурации на основе аннотаций, которая
            использует данные байт-кода для подключения компонентов.
            Вместо того, чтобы использовать XML-файл для описания связывания компонентов, разработчик перемещает
            конфигурацию в сам класс компонента, используя аннотации к соответствующему классу, методу или полю.
            При этом, сам XML-файл с базовыми настройками остаётся. Контейнер считывает аннотации перед
            считыванием XML, поэтому, если бин конфигурируется и через аннотации и через XML-файл, то
            <strong>настройки XML переопределят настройки аннотаций</strong>.
        </li>
        <li>
            <p>
                Java-код - Начиная со Spring 3.0, используя Java-код, а не файлы XML, мы можем определять настройки в
                специальном классе, помеченном аннотацией
                <an>@Configuration</an>
                .
            </p>
            <p class="example">
                Появились аннотации
                <an>@Configuration</an>
                ,
                <an>@Bean</an>
                ,
                <an>@Import</an>
                и
                <an>@DependsOn</an>
                и т.д.
            </p>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Bean в Spring?</h1>
    <p>
        В Spring объекты, образующие основу приложения и управляемые контейнером Spring IoC, называются бинами.
    </p>
    <p class="main-mind no_mb">
        Бин — это объект, который создается, собирается и управляется контейнером <a href="#q2">Spring IoC</a>.
    </p>
    <p class="example">Иначе говоря, бин — это просто один из множества объектов в вашем приложении.</p>
    <p> Бины и их зависимости отражаются в метаданных конфигурации, используемых контейнером. </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Аннотация @Bean</h1>
    <p class="main-mind">
        @Bean - Это аннотация Spring Framework, она используется над методом для указания того, что данный метод
        создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером.
    </p>
    <p>
        Такие методы можно использовать как в классах с аннотацией
        <an>@Configuration</an>
        , так и в классах с аннотацией
        <an>@Component</an>
        (или её наследниках).
    </p>
    <p class="no_mb"> Позволяет дополнительно определить у бина: </p>
    <table class="list list--dictionary" aria-label="">
        <thead>
        <tr>
            <th>Параметр</th>
            <th>Описание</th>
        <tr>
        </thead>
        <tr>
            <td>name</td>
            <td>имя (уникальный идентификатор) бина;</td>
        </tr>
        <tr>
            <td>initMethod</td>
            <td>имя метода для вызова во время инициализации бина;</td>
        </tr>
        <tr>
            <td>destroyMethod</td>
            <td>имя метода для вызова во время удаления бина из контекста;</td>
        </tr>
        <tr>
            <td>autowireCandidate</td>
            <td>является ли этот бин кандидатом на автоматическое внедрение в другой бин.</td>
        </tr>
    </table>
    <p>
        Классы, аннотированные
        <an>@Configuration</an>, <strong>проксируются через CGLIB</strong>.
    </p>
    <p>
        Классы
        <an>@Component</an>
        <strong>или обычные классы не проксируются</strong> и не перехватывают вызовы методов с аннотациями @Bean, что
        означает, что вызовы не будут маршрутизироваться через контейнер
        и каждый раз будет возвращаться новый экземпляр бина.
    </p>
    <p>
        Также методы бинов, вызывая друг друга в таких классах, не будут создавать бины, а будет просто выполняться код
        метода, ведь в данном случае они отработают не через прокси.
    </p>
    <p>
        <span class="bold">CGLIB (Code Generation Library)</span>
        - Это библиотека инструментария байтов, используемая во многих средах Java, таких
        как Hibernate или Spring. Инструментарий байт-кода позволяет манипулировать или создавать классы после фазы
        компиляции программы.
    </p>
    <p class="no_mb"> Hibernate использует CGLIB для генерации динамических прокси. </p>
    <p class="example">
        Например, он не вернет полный объект, хранящийся в базе данных, но вернет инструментальную версию хранимого
        класса, которая лениво загружает значения из базы данных по требованию.
    </p>
    <p>
        <span class="bold">Прокси</span>
        — это шаблон проектирования. Создаем и используем его для добавления и изменения функционала уже существующих
        классов. В таком случае, прокси-объект применяется вместо исходного. Обычно он использует тот же метод, что и
        оригинальный, и в Java прокси-классы расширяют исходные.
    </p>
    <hr>
    <h3>Имена бинов</h3>
    <p>
        <strong>Имя бина</strong>, которое в контейнере является одновременно и его
        <strong>уникальным идентификатором</strong>, по умолчанию соответствует имени метода, аннотированного @Bean.
    </p>
    <p class="no_mb">
        Но если требуется указать иное имя, то можно использовать <strong>атрибут name</strong>, который
        принимает String. Однако, атрибут name также <strong>может принимать массив String</strong>,
        что позволяет использовать несколько имен.
    </p>
    <p>
        <strong>
            Первый элемент массива будет являться именем и уникальным
            идентификатором бина, а остальные будут его псевдонимами.
        </strong>
    </p>
    <div class="code">
        <p><an>@Bean</an>({"b1", "b2"}) //
            <span class="good">bean available as 'b1' and 'b2'</span>, <span class="bad">but not 'myBean'</span></p>
        <p>public MyBean myBean() {</p>
        <p class="tab-1">// instantiate and configure MyBean obj</p>
        <p class="tab-1">return obj;</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Аннотация @Component</h1>
    <p class="no_mb">Если хотим, <strong>чтобы из этого класса был создан бин</strong>, то используем
        <an>@Component</an></p>
    <p class="example"> Именно эту аннотацию ищет Spring Framework, когда сканирует наши классы.</p>
    <p class="no_mb"><strong>Именем бина будет название класса с маленькой буквы</strong>. </p>
    <p class="example">Можно указать имя (Id) для создаваемого бина.</p>

    <p class="no_mb"> Аннотация @Component имеет наследников: </p>
    <p class="no_mb"><an>@Repository</an>, <an>@Service</an> и <an>@Controller</an>.</p>
    <p class="example no_mb">
        Все они являются частными случаями использования @Component для слоёв DAO, сервиса и
        контроллера MVC соответственно.
    </p>
    <p class="example no_mb">Также эти аннотации могут иметь дополнительный смысл в будущих версиях Spring
        Framework.</p>
    <p class="example">В остальных же случаях достаточно использовать аннотацию @Component.</p>

    <table class="list list--dictionary" aria-label="@Component">
        <thead>
        <tr>
            <th>Аннотация</th>
            <th>Описание</th>
        <tr>
        </thead>
        <tr>
            <td>@Component</td>
            <td>Spring определяет этот класс как кандидата для создания bean.</td>
        </tr>
        <tr>
            <td>@Service</td>
            <td>
                <p>указывает, что класс содержит бизнес-логику и вызывает методы на уровне хранилища.</p>
                <p class="example">Ничем не отличается от классов с @Component.</p>
            </td>
        </tr>
        <tr>
            <td>@Repository</td>
            <td>
                <p>указывает, что класс выполняет роль хранилища (объект доступа к DAO).</p>
                <p class="example">
                    Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и
                    пробрасывать их как одно непроверенное исключение Spring Framework.
                    Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть добавлен класс
                    PersistenceExceptionTranslationPostProcessor.
                </p>
            </td>
        </tr>
        <tr>
            <td>@Controller</td>
            <td>
                <p>указывает, что класс выполняет роль контроллера MVC.</p>
                <p class="example">DispatcherServlet просматривает такие классы для поиска @RequestMapping.</p>
            </td>
        </tr>
    </table>
    <p>
        <span class="bold">@RequestMapping</span> используется для мапинга (связывания) с URL для всего класса
        или для конкретного метода обработчика.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Отличия @Bean и @Component</h1>
    <p class="main-mind">
        Аннотация @Component (как и @Service и @Repository) используется для автоматического обнаружения и
        автоматической настройки бинов в ходе сканирования путей к классам.
    </p>
    <p class="main-mind no_mb">Аннотация @Bean используется для явного объявления бина.</p>
    <p class="no_mb">
        A не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам:
    </p>
    <ul class="tab-2">
        <li>прописываем <strong>вручную метод для создания бина</strong>;</li>
        <li>
            делает возможным <strong>объявление бина независимо от объявления класса</strong>,
            что позволяет использовать классы из сторонних библиотек,
            у которых мы не можем указать аннотацию @Component;
        </li>
        <li>
            аннотацией @Bean <strong>можно настроить initMethod, destroyMethod, autowireCandidate</strong>,
            делая создание бина более гибким.
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Отличия @Service и @Repository</h1>
    <p class="no_mb">
        @Service и @Repository являются частными случаями @Component.
    </p>
    <p>
        <strong>Технически они одинаковы</strong> , но мы используем их<strong>для разных целей</strong>.
    </p>
    <p class="no_mb">
        Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать
        их как одно непроверенное исключение Spring Framework.
    </p>
    <p> Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor. </p>
    <p class="no_mb"> Мы помечаем бины аннотацией @Service, чтобы указать, что они содержат бизнес-логику. </p>
    <p>Так что нет никакого другого предназначения, кроме как использовать ее на уровне сервиса.</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Аннотация @Autowired</h1>
    <p class="main-mind">
        Аннотация Spring Framework, которой отмечают конструктор, поле, сеттер-метод или метод конфигурации,
        указывая, что им обязательно требуется внедрение зависимостей.
    </p>
    <p>
        Если в контейнере не будет обнаружен необходимый для вставки бин, то будет выброшено исключение, либо можно
        указать <an>@Autowired(required = false)</an>, означающее, что внедрение зависимости в данном месте
        необязательно.
    </p>
    <p>
        Аннотация @Autowired является альтернативой Java-аннотации @Inject, не имеющей required = false (зависимость
        должна быть обязательно внедрена).
    </p>
    <p class="no_mb">
        Начиная со Spring Framework 4.3, аннотация @Autowired для конструктора больше не требуется, если целевой
        компонент определяет только один конструктор.
    </p>
    <p>
        Однако, если доступно несколько конструкторов и нет
        основного/стандартного конструктора, по крайней мере один из конструкторов должен быть аннотирован @Autowired,
        чтобы указать контейнеру, какой из них использовать.
    </p>
    <p class="no_mb">
        <strong>По умолчанию Spring распознает объекты для вставки по типу</strong>.
    </p>
    <p>
        Если в контейнере доступно более одного бина одного и того же типа, будет исключение. Для избежания этого можно
        указать аннотацию Spring Framework - <an>@Qualifier</an>("fooFormatter"), где fooFormatter — это имя (Id) одного
        из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения:
    </p>
    <div class="code">
        <p>public class FooService {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1"><an>@Qualifier("fooFormatter")</an></p>
        <p class="tab-1">private Formatter formatter;</p>
        <p>}</p>
    </div>
    <hr>
    <h4>Выбор из нескольких бинов</h4>
    <p>
        <strong>При выборе</strong> между несколькими бинами при автоматическом внедрении
        <strong>используется имя поля</strong>.
        Это поведение по умолчанию, если нет других настроек.
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@Qualifier("fooFormatter")</an></p>
        <p>public class FooFormatter implements Formatter {</p>
        <p class="tab-1">//...</p>
        <p class="mb10">}</p>
        <p><an>@Component</an></p>
        <p><an>@Qualifier("barFormatter")</an></p>
        <p>public class BarFormatter implements Formatter {</p>
        <p class="tab-1">//...</p>
        <p class="mb10">}</p>
        <p>public class FooService {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">private Formatter fooFormatter;</p>
        <p>}</p>
    </div>
    <p>
        В этом случае Spring определит, что нужно внедрить бин с именем FooFormatter, поскольку имя поля соответствует
        значению, которое мы использовали в аннотации @Component для этого бина.
    </p>
    <hr>
    <h4>Вставка всех бинов</h4>
    <p>
        Мы также можем указать Spring предоставить все бины определенного типа из ApplicationContext, добавив аннотацию
        @Autowired в поле или метод с массивом или коллекцией этого типа:
    </p>
    <div class="code">
        <p><an>@Autowired</an></p>
        <p class="mb10">private MovieCatalog[] movieCatalogs;</p>
        <p class="mb10">или</p>
        <p><an>@Autowired</an></p>
        <p class="mb10">private Set &lt;MovieCatalog&gt; movieCatalogs;</p>
        <p class="mb10">или</p>
        <p><an>@Autowired</an></p>
        <p>public void setMovieCatalogs(Set &lt;MovieCatalog&gt; movieCatalogs) {</p>
        <p class="tab-1">this.movieCatalogs = movieCatalogs;</p>
        <p>}</p>
    </div>
    <p class="no_mb">Даже коллекции типа Map могут быть подключены автоматически, если тип ключа - String.</p>
    <p>Ключами будут имена бинов, а значениями - сами бины:</p>
    <div class="code">
        <p class="mb10">public class MovieRecommender {</p>
        <p class="tab-1 mb10">private Map&lt;String, MovieCatalog&gt; movieCatalogs;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {</p>
        <p class="tab-2">this.movieCatalogs = movieCatalogs;</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1 mb10">//...</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Аннотация @Resource</h1>
    <p><strong>Java-аннотация</strong>@Resource может применяться к классам, полям и методам.</p>
    <p class="main-mind">
        Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier).
    </p>
    <p>
        Имя извлекается <strong>из имени аннотируемого сеттера или поля,
        либо</strong> берется из параметра <strong>name</strong>.
    </p>
    <p>
        <strong>При аннотировании классов имя не извлекается из имени класса</strong>
        по умолчанию, поэтому оно <strong>должно быть указано явно</strong>.
    </p>
    <p>
        Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с
        данным именем, и <strong>в контейнере должен быть бин</strong> с таким именем:
    </p>
    <div class="code">
        <p><an>@Resource(name="namedFile")</an></p>
        <p>private File defaultFile;</p>
    </div>
    <p>
        Если указать её без аргументов, то Spring Framework может найти бин по типу.
    </p>
    <p>
        Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию <an>@Qualifier</an>
    </p>
    <div class="code">
        <p><an>@Resource</an></p>
        <p><an>@Qualifier("defaultFile")</an></p>
        <p>private File dependency1;</p>
        <p class="mb10"></p>
        <p><an>@Resource</an></p>
        <p><an>@Qualifier("namedFile")</an></p>
        <p>private File dependency2;</p>
    </div>

    <hr>
    <h4>Разница с @Autowired:</h4>
    <ul class="tab-2 sparse-li">
        <li>ищет бин сначала по имени, а потом по типу;</li>
        <li>не нужна дополнительная аннотация для указания имени конкретного бина;</li>
        <li>@Autowired позволяет отметить место вставки бина как необязательное @Autowired(required=false);</li>
        <li>при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1>Аннотация @Inject</h1>
    <p>
        <strong>Java-аннотация</strong>
        @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:
    </p>
    <div class="code">
        <p>&lt;dependency&gt;</p>
        <p class="tab-1">&lt;groupId&gt;javax.inject&lt;/groupId&gt;</p>
        <p class="tab-1">&lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</p>
        <p class="tab-1">&lt;version&gt;1&lt;/version&gt;</p>
        <p>&lt;/dependency&gt;</p>
    </div>
    <p>Размещается над полями, методами, и конструкторами с аргументами.</p>
    <p class="main-mind">
        @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только
        потом по имени.
    </p>
    <p>
        Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но
        они одинакового типа, зависимость все равно будет разрешена:
    </p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p>private ArbitraryDependency fieldInjectDependency;</p>
    </div>
    <p>отличается от имени компонента, настроенного в контексте приложения:</p>
    <div class="code">
        <p><an>@Bean</an></p>
        <p>public ArbitraryDependency injectDependency() {</p>
        <p class="tab-1">ArbitraryDependency injectDependency = new ArbitraryDependency();</p>
        <p class="tab-1">return injectDependency;</p>
        <p>}</p>
    </div>
    <p>
        Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу
        ArbitraryDependency.
    </p>
    <br>
    <p>
        Если в контейнере <strong>несколько бинов-кандидатов</strong> на внедрение,
        то нужно использовать аннотацию <strong>@Qualifier</strong>:
    </p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p><an>@Qualifier("defaultFile")</an></p>
        <p class="mb10">private ArbitraryDependency defaultDependency;</p>
        <p><an>@Inject</an></p>
        <p><an>@Qualifier("namedFile")</an></p>
        <p>private ArbitraryDependency namedDependency;</p>
    </div>
    <br>
    <p>При использовании конкретного имени (Id) бина используем @Named:</p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p><an>@Named("yetAnotherFieldInjectDependency")</an></p>
        <p>private ArbitraryDependency yetAnotherFieldInjectDependency;</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1>Аннотация @Lookup</h1>
    <p>
        Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей
        мы используем конструктор или сеттер.
    </p>
    <p>

    </p>
    <p>
        Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый
        экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean).
        Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз
        новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь-то и пригодится
        <strong>внедрение бина с помощью Lookup-метода</strong> . Оно происходит не при инициализации контейнера, а
        позднее: <strong>каждый раз, когда вызывается метод</strong>.
    </p>
    <p>
        Суть в том, что мы создаём метод-заглушку в бине Car и помечаем его специальным образом – аннотацией @Lookup.
        Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст
        прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове
        аннотированного метода. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот
        метод будет переопределен в прокси-подклассе):
    </p>
    <div class="code">
        <p>@Component</p>
        <p class="mb10">public class Car {</p>
        <p class="tab-1"><an>@Lookup</an></p>
        <p class="tab-1">public Passenger createPassenger() {</p>
        <p class="tab-2">return null;</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1">public String drive(String name) {</p>
        <p class="tab-2">Passenger passenger = createPassenger();</p>
        <p class="tab-2">passenger.setName(name);</p>
        <p class="tab-2">return "car with " + passenger.getName();</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <p>
        Допустим, в бине есть метод drive(), и при каждом вызове метода drive() бину Car требуется новый экземпляр бина
        Passenger – сегодня пассажир Петя, завтра – Вася. То есть <strong></strong>бин Passenger прототипный. Для
        получения этого бина
        надо написать метод-заглушку createPassenger() и аннотировать его с помощью @Lookup.
    </p>
    <p>
        Контейнер Spring переопределит этот метод-заглушку и будет выдавать при его вызове каждый раз новый экземпляр
        Passenger.
    </p>
    <p>
        Переопределяем бин Passenger как прототипный:
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@Scope("prototype")</an></p>
        <p class="mb10">public class Passenger {</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-1">// + геттер и сеттер</p>
        <p>}</p>
    </div>
    <p>
        Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передаётся в аргументе
        метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q12">
    <h1>Можно ли вставить бин в статическое поле?</h1>
    <p class="main-mind">Spring не позволяет внедрять бины напрямую в статические поля.</p>
    <p>Пример:</p>
    <div class="code">
        <p><an>@Component</an></p>
        <p>public class TestDataInit {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">private static OrderItemService orderItemService;</p>
        <p>}</p>
    </div>
    <p>
        <strong>Если вы распечатать TestDataInit.orderItemService, там будет null.</strong>
    </p>
    <p>Чтобы исправить это, необходимо создать нестатический сеттер-метод:</p>
    <div class="code">
        <p><an>@Component</an></p>
        <p class="mb10">public class TestDataInit {</p>
        <p class="tab-1 mb10">private static OrderItemService orderItemService;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setOrderItemService(OrderItemService orderItemService) {</p>
        <p class="tab-2">TestDataInit.orderItemService = orderItemService;</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

<script src="../../../js/spoiler.js"></script>

</html>



