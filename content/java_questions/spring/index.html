<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPRING</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">SPRING</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="..">Questions</a></p>
        <p>spring</p>
    </div>
    <h3 class="no_mt">Вопросы:</h3>
    <ol class="menu">
        <li>
            <p>
                <a href="#q1">Инверсия контроля (<span>IoC</span>) и внедрение зависимостей (<span>DI</span>)</a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2"><a href="#q1_ioc">Inversion of Control (IoC)</a></p>
                <p class="tab-2"><a href="#q1_di">Dependency Injection (DI)</a></p>
            </div>
        </li>
        <li><a href="#q2"><span>IoC Container</span></a></li>
        <li><a href="#q3">Bean в Spring</a></li>
        <li><a href="#q4">Аннотация <span>@Bean</span></a></li>
        <li><a href="#q5">Аннотация <span>@Component</span></a></li>
        <li><a href="#q6">Отличия <span>@Bean</span> и <span>@Component</span></a></li>
        <li><a href="#q7">Отличия <span>@Service</span> и <span>@Repository</span></a></li>
        <li><a href="#q8">Аннотация <span>@Autowired</span></a></li>
        <li><a href="#q9">Аннотация <span>@Resource</span></a></li>
        <li><a href="#q10">Аннотация <span>@Inject</span></a></li>
        <li><a href="#q11">Аннотация <span>@Lookup</span></a></li>
        <li><a href="#q12">Можно ли вставить бин в статическое поле?</a></li>
        <li><a href="#q13">Аннотации <span>@Primary</span> и <span>@Qualifier</span></a></li>
        <li>
            <p>
                <a href="#q14">Как заинжектить примитив?</a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2"><a href="#q14_value">@Value</a></p>
                <p class="tab-2"><a href="#q14_spel">@Value with SpEL</a></p>
                <p class="tab-2"><a href="#q14_map">@Value with Map</a></p>
                <p class="tab-2"><a href="#q14_constructor">@Value with Constructor</a></p>
                <p class="tab-2"><a href="#q14_setter">@Value with Setter</a></p>
            </div>
        </li>
        <li>
            <p>
                <a href="#q15">Как заинжектить коллекцию?</a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2"><a href="#q15_array">Array Injection</a></p>
                <p class="tab-2"><a href="#q15_collection">Collections Injection</a></p>
                <p class="tab-2"><a href="#q15_beans">Коллекции бинов одного типа</a></p>
                <p class="tab-2"><a href="#q15_qualifier">Использование @Qualifier</a></p>
                <p class="tab-2"><a href="#q15_sort">Упорядочивание элементов массивов/списков</a></p>
            </div>
        </li>
        <li><a href="#q16">Аннотация <span>@Conditional</span></a></li>
        <li><a href="#q17">Аннотация <span>@ComponentScan</span></a></li>
        <li><a href="#q18">Аннотация <span>@Profile</span></a></li>
        <li>
            <p>
                <a href="#q19"><span>ApplicationContext</span> и <span>BeanFactory</span></a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2"><a href="#q19_bf">BeanFactory</a></p>
                <p class="tab-2"><a href="#q19_ac">ApplicationContext</a></p>
                <p class="tab-2"><a href="#q19_eq">ApplicationContext vs. BeanFactory</a></p>
            </div>
        </li>
        <li>
            <p>
                <a href="#q20">Жизненный цикл бина, аннотации <span>@PostConstruct</span> и <span>@PreDestroy</span></a>
                <span class="spoiler-button"></span>
            </p>
            <div class="spoiler">
                <p class="tab-2 no_mb"><a href="#q20_beans">Жизненный цикл бинов</a></p>
                <ul class="tab-3">
                    <li class="no_mb">Парсирование конфигурации и создание BeanDefinition</li>
                    <li class="no_mb">Настройка созданных BeanDefinition</li>
                    <li class="no_mb">Создание кастомных FactoryBean (только для XML-конфигурации)</li>
                    <li class="no_mb">Создание экземпляров бинов</li>
                    <li class="no_mb">Настройка созданных бинов</li>
                    <li class="no_mb">Бины готовы к использованию</li>
                    <li class="no_mb">Закрытие контекста</li>
                </ul>
                <p class="tab-2"><a href="#q20_predestroy">@PreDestroy</a></p>
                <p class="tab-2"><a href="#q20_postconstuct">@PostConstruct</a></p>
            </div>
        </li>
    </ol>

    <table aria-label="Вопросы по Spring">

        <tr>
            <td>21.</td>
            <td>
                Расскажите про scope бинов. Какой scope используется по умолчанию? Что изменилось в пятом Spring?
                <p>Singleton</p>
                <p>Prototype</p>
                <p>Request</p>
                <p>Session</p>
                <p>Application</p>
                <p>Websocket</p>
                <p>Custom thread scope</p>
            </td>
        </tr>
        <tr>
            <td>22.</td>
            <td>Что такое АОП? Как реализовано в спринге?</td>
        </tr>
        <tr>
            <td>23.</td>
            <td>Как спринг работает с транзакциями? Расскажите про аннотацию <span>@Transactional</span></td>
        </tr>
        <tr>
            <td>24.</td>
            <td>
                Расскажите про паттерн MVC, как он реализован в Spring?
                <p>MVC (Model-View-Controller)</p>
                <p>Spring Web MVC</p>
            </td>
        </tr>
        <tr>
            <td>25.</td>
            <td>Что такое <span>ViewResolver</span>?</td>
        </tr>
        <tr>
            <td>26.</td>
            <td>Расскажите про шаблон проектирования Front Controller, как он реализован в Spring?</td>
        </tr>
        <tr>
            <td>27.</td>
            <td>
                Чем отличаются <span>Model</span>, <span>ModelMap</span> и <span>ModelAndView</span>?
                <p>Model</p>
                <p>ModelMap</p>
                <p>ModelAndView</p>
            </td>
        </tr>
        <tr>
            <td>28.</td>
            <td>
                Расскажите про аннотации <span>@Controller</span> и <span>@RestController</span>. Чем они отличаются?
                Как вернуть ответ со своим статусом (например 213)?
                <p>@Controller</p>
                <p>@RestController</p>
                <p>ResponseEntity</p>
            </td>
        </tr>
        <tr>
            <td>29.</td>
            <td>
                В чем разница между <span>Filters</span>, <span>Listeners</span> и <span>Interceptors</span>?
                <p>Filter</p>
                <p>Interceptor</p>
                <p>Filter vs. Interceptor</p>
                <p>Java Listener</p>
            </td>
        </tr>
        <tr>
            <td>30.</td>
            <td>Можно ли передать в GET-запросе один и тот же параметр несколько раз? Как?</td>
        </tr>
        <tr>
            <td>31.</td>
            <td>Как работает <span>Spring Security</span>? Как сконфигурировать? Какие интерфейсы используются?</td>
        </tr>
        <tr>
            <td>32.</td>
            <td>Что такое <span>Spring Boot</span>? Какие у него преимущества? Как конфигурируется? Подробно</td>
        </tr>
        <tr>
            <td>33.</td>
            <td>Расскажите про нововведения Spring 5</td>
        </tr>
    </table>

</section>

<section class="container" id="q1">
    <h1>Инверсия контроля (IoC) и внедрение зависимостей (DI)</h1>
    <hr>
    <h3 id="q1_ioc">Inversion of Control (IoC)</h3>
    <p class="main-mind">Инверсия (от латинского inversio) - перестановка.</p>
    <p class="no_mb main-mind">
        Инверсия контроля (инверсия управления) — это <strong>принцип</strong> в разработке программного обеспечения,
        при котором <strong>управление объектами</strong> или частями программы
        <strong>передается контейнеру или фреймворку</strong>.
    </p>
    <p class="example">Чаще всего этот принцип используется в контексте объектно-ориентированного программирования.</p>
    <p>
        В отличие от традиционного программирования, в котором наш пользовательский код обращается напрямую к
        библиотекам, IoC позволяет фреймворку контролировать ход программы и обращаться к нашему коду, когда это
        необходимо. Для этого, фреймворки используют абстракции со встроенным дополнительным поведением. Если мы хотим
        добавить наше собственное поведение, нам нужно расширить классы фреймворка или подключить наши собственные
        классы.
    </p>
    <p class="no_mb">Преимущества этой архитектуры:</p>
    <ul class="tab-2">
        <li><strong>отделение выполнения задачи от ее реализации</strong>;</li>
        <li>легкое <strong>переключение между различными реализациями</strong>;</li>
        <li>большая <strong>модульность</strong> программы;</li>
        <li>
            более легкое <strong>тестирование</strong> программы путем изоляции компонента или проверки его
            зависимостей и обеспечения взаимодействия компонентов через контракты.
        </li>
    </ul>
    <p>
        Инверсия управления может быть достигнута с помощью различных механизмов, таких как: шаблон проектирования
        “Стратегия”, шаблон “Локатор служб”, шаблон “Фабрика” и внедрение зависимостей (DI).
    </p>
    <hr>
    <h3 id="q1_di">Dependency Injection (DI)</h3>
    <p class="main-mind">
        Внедрение зависимостей — это <strong>шаблон</strong> проектирования для реализации IoC,
        где <strong>инвертируемым (переопределяемым) элементом контроля является настройка зависимостей объекта</strong>.
    </p>
    <p>
        <strong>Соединение</strong> объектов с другими объектами или «внедрение»
        объектов в другие объекты <strong>выполняется <a href="#q2">контейнером IoC</a></strong>, а не самими объектами.
    </p>
    <p class="main-mind">
        В Spring Framework инверсия контроля достигается именно внедрением зависимостей.
    </p>
    <p class="main-mind">
        В Spring Framework инверсия контроля и внедрение зависимостей считаются одним и тем же.
    </p>
    <p>
        В Spring Framework внедрение зависимостей описывается как процесс, посредством которого <strong>объект
        определяет свои зависимости</strong> (то есть другие объекты, с которыми он работает) <strong>только через
        аргументы конструктора, аргументы фабричного метода или свойства</strong>, которые устанавливаются в экземпляре
        объекта после того, как он создан или возвращен из метода фабрики.
        После чего <strong>контейнер IoC внедряет</strong> эти зависимости в компонент <strong>при его создании</strong>.
    </p>
    <p>
        Мы можем создать зависимость объекта следующим традиционным способом,
        <strong>без использования принципа IoC</strong>:
    </p>
    <div class="code no_mb">
        <p>public class Store {</p>
        <p class="tab-1">private Item item;</p>
        <p class="tab-1">public Store() {</p>
        <p class="tab-2">item = new ItemImpl1();</p>
        <p class="tab-1">}</p>
        <p>}</p>
    </div>
    <p class="example">
        В приведенном выше примере мы создаем экземпляр конкретной реализации интерфейса Item (ItemImpl1) внутри самого
        класса Store.
    </p>

    <p>
        <strong>Используя DI</strong> , мы можем переписать пример без указания конкретной реализации Item, не создавая
        её внутри нашего объекта, а ожидая её получение извне (от внешнего фреймворка - контейнера IoC):
    </p>
    <div class="code no_mb">
        <p>public class Store {</p>
        <p class="tab-1">private Item item;</p>
        <p class="tab-1">public Store(Item item) {</p>
        <p class="tab-2">this.item = item;</p>
        <p class="tab-1">}</p>
        <p>}</p>
    </div>
    <p class="example">
        В данном случае инверсия контроля — это переход контроля над зависимостями от объекта Store к контейнеру IoC.
        Объект Store более не контролирует инстанцирование своего поля (зависимости) item, не создаёт этот объект
        самостоятельно, а делегирует этот процесс внешним силам - контейнеру IoC, который в нашем примере передаёт в
        конструктор Store любую из реализаций Item.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>IoC Container?</h1>
    <p>
        В Spring Framework IoC Container <strong> отвечает за создание, настройку и сборку объектов, известных как бины,
        а также за управление их жизненным циклом</strong>.
    </p>
    <p>Он (контейнер) представлен интерфейсом ApplicationContext.</p>
    <p>Spring Framework предоставляет несколько реализаций интерфейса ApplicationContext:</p>
    <ul class="tab-2 sparse-li">
        <li>
            <p>ClassPathXmlApplicationContext и FileSystemXmlApplicationContext</p>
            <p class="example">- для автономных приложений;</p>
        </li>
        <li>
            <p>WebApplicationContext</p>
            <p class="example">- для веб-приложений;</p>
        </li>
        <li>
            <p>AnnotationConfigApplicationContext</p>
            <p class="example">
                - для обычной Java-конфигурации,в качестве аргумента которому передается класс, либо список классов с
                аннотацией
                <an>@Configuration</an>
                , либо с любой другой аннотацией JSR-330, в том числе и
                <an>@Component</an>
                .
            </p>

        </li>
    </ul>

    <p>
        Контейнер получает инструкции о том, какие объекты создавать, настраивать и собирать, через метаданные
        конфигурации, которые представлены в виде XML, Java-аннотаций или Java-кода:
    </p>
    <ul class="tab-2 sparse-li">
        <li>XML - Метаданные считываются из файла с расширением *.xml;</li>
        <li>
            Java-аннотации - В Spring 2.5 появилась поддержка метаданных конфигурации на основе аннотаций, которая
            использует данные байт-кода для подключения компонентов.
            Вместо того, чтобы использовать XML-файл для описания связывания компонентов, разработчик перемещает
            конфигурацию в сам класс компонента, используя аннотации к соответствующему классу, методу или полю.
            При этом, сам XML-файл с базовыми настройками остаётся. Контейнер считывает аннотации перед
            считыванием XML, поэтому, если бин конфигурируется и через аннотации и через XML-файл, то
            <strong>настройки XML переопределят настройки аннотаций</strong>.
        </li>
        <li>
            <p>
                Java-код - Начиная со Spring 3.0, используя Java-код, а не файлы XML, мы можем определять настройки в
                специальном классе, помеченном аннотацией
                <an>@Configuration</an>
                .
            </p>
            <p class="example">
                Появились аннотации
                <an>@Configuration</an>
                ,
                <an>@Bean</an>
                ,
                <an>@Import</an>
                и
                <an>@DependsOn</an>
                и т.д.
            </p>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Bean в Spring?</h1>
    <p>
        В Spring объекты, образующие основу приложения и управляемые контейнером Spring IoC, называются бинами.
    </p>
    <p class="main-mind no_mb">
        Бин — это объект, который создается, собирается и управляется контейнером <a href="#q2">Spring IoC</a>.
    </p>
    <p class="example">Иначе говоря, бин — это просто один из множества объектов в вашем приложении.</p>
    <p> Бины и их зависимости отражаются в метаданных конфигурации, используемых контейнером. </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Аннотация @Bean</h1>
    <p class="main-mind">
        @Bean - Это аннотация Spring Framework, она используется над методом для указания того, что данный метод
        создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером.
    </p>
    <p>
        Такие методы можно использовать как в классах с аннотацией
        <an>@Configuration</an>
        , так и в классах с аннотацией
        <an>@Component</an>
        (или её наследниках).
    </p>
    <p class="no_mb"> Позволяет дополнительно определить у бина: </p>
    <table class="list list--dictionary" aria-label="">
        <thead>
        <tr>
            <th>Параметр</th>
            <th>Описание</th>
        <tr>
        </thead>
        <tr>
            <td>name</td>
            <td>имя (уникальный идентификатор) бина;</td>
        </tr>
        <tr>
            <td>initMethod</td>
            <td>имя метода для вызова во время инициализации бина;</td>
        </tr>
        <tr>
            <td>destroyMethod</td>
            <td>имя метода для вызова во время удаления бина из контекста;</td>
        </tr>
        <tr>
            <td>autowireCandidate</td>
            <td>является ли этот бин кандидатом на автоматическое внедрение в другой бин.</td>
        </tr>
    </table>
    <p>
        Классы, аннотированные
        <an>@Configuration</an>, <strong>проксируются через CGLIB</strong>.
    </p>
    <p>
        Классы
        <an>@Component</an>
        <strong>или обычные классы не проксируются</strong> и не перехватывают вызовы методов с аннотациями @Bean, что
        означает, что вызовы не будут маршрутизироваться через контейнер
        и каждый раз будет возвращаться новый экземпляр бина.
    </p>
    <p>
        Также методы бинов, вызывая друг друга в таких классах, не будут создавать бины, а будет просто выполняться код
        метода, ведь в данном случае они отработают не через прокси.
    </p>
    <p>
        <span class="bold">CGLIB (Code Generation Library)</span>
        - Это библиотека инструментария байтов, используемая во многих средах Java, таких
        как Hibernate или Spring. Инструментарий байт-кода позволяет манипулировать или создавать классы после фазы
        компиляции программы.
    </p>
    <p class="no_mb"> Hibernate использует CGLIB для генерации динамических прокси. </p>
    <p class="example">
        Например, он не вернет полный объект, хранящийся в базе данных, но вернет инструментальную версию хранимого
        класса, которая лениво загружает значения из базы данных по требованию.
    </p>
    <p>
        <span class="bold">Прокси</span>
        — это шаблон проектирования. Создаем и используем его для добавления и изменения функционала уже существующих
        классов. В таком случае, прокси-объект применяется вместо исходного. Обычно он использует тот же метод, что и
        оригинальный, и в Java прокси-классы расширяют исходные.
    </p>
    <hr>
    <h3>Имена бинов</h3>
    <p>
        <strong>Имя бина</strong>, которое в контейнере является одновременно и его
        <strong>уникальным идентификатором</strong>, по умолчанию соответствует имени метода, аннотированного @Bean.
    </p>
    <p class="no_mb">
        Но если требуется указать иное имя, то можно использовать <strong>атрибут name</strong>, который
        принимает String. Однако, атрибут name также <strong>может принимать массив String</strong>,
        что позволяет использовать несколько имен.
    </p>
    <p>
        <strong>
            Первый элемент массива будет являться именем и уникальным
            идентификатором бина, а остальные будут его псевдонимами.
        </strong>
    </p>
    <div class="code">
        <p><an>@Bean</an>({"b1", "b2"}) //
            <span class="good">bean available as 'b1' and 'b2'</span>, <span class="bad">but not 'myBean'</span></p>
        <p>public MyBean myBean() {</p>
        <p class="tab-1">// instantiate and configure MyBean obj</p>
        <p class="tab-1">return obj;</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Аннотация @Component</h1>
    <p class="no_mb">Если хотим, <strong>чтобы из этого класса был создан бин</strong>, то используем
        <an>@Component</an></p>
    <p class="example"> Именно эту аннотацию ищет Spring Framework, когда сканирует наши классы.</p>
    <p class="no_mb"><strong>Именем бина будет название класса с маленькой буквы</strong>. </p>
    <p class="example">Можно указать имя (Id) для создаваемого бина.</p>

    <p class="no_mb"> Аннотация @Component имеет наследников: </p>
    <p class="no_mb"><an>@Repository</an>, <an>@Service</an> и <an>@Controller</an>.</p>
    <p class="example no_mb">
        Все они являются частными случаями использования @Component для слоёв DAO, сервиса и
        контроллера MVC соответственно.
    </p>
    <p class="example no_mb">Также эти аннотации могут иметь дополнительный смысл в будущих версиях Spring
        Framework.</p>
    <p class="example">В остальных же случаях достаточно использовать аннотацию @Component.</p>

    <table class="list list--dictionary" aria-label="@Component">
        <thead>
        <tr>
            <th>Аннотация</th>
            <th>Описание</th>
        <tr>
        </thead>
        <tr>
            <td>@Component</td>
            <td>Spring определяет этот класс как кандидата для создания bean.</td>
        </tr>
        <tr>
            <td>@Service</td>
            <td>
                <p>указывает, что класс содержит бизнес-логику и вызывает методы на уровне хранилища.</p>
                <p class="example">Ничем не отличается от классов с @Component.</p>
            </td>
        </tr>
        <tr>
            <td>@Repository</td>
            <td>
                <p>указывает, что класс выполняет роль хранилища (объект доступа к DAO).</p>
                <p class="example">
                    Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и
                    пробрасывать их как одно непроверенное исключение Spring Framework.
                    Для этого Spring оборачивает эти классы в прокси, и в контекст должен быть добавлен класс
                    PersistenceExceptionTranslationPostProcessor.
                </p>
            </td>
        </tr>
        <tr>
            <td>@Controller</td>
            <td>
                <p>указывает, что класс выполняет роль контроллера MVC.</p>
                <p class="example">DispatcherServlet просматривает такие классы для поиска @RequestMapping.</p>
            </td>
        </tr>
    </table>
    <p>
        <span class="bold">@RequestMapping</span> используется для мапинга (связывания) с URL для всего класса
        или для конкретного метода обработчика.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Отличия @Bean и @Component</h1>
    <p class="main-mind">
        Аннотация @Component (как и @Service и @Repository) используется для автоматического обнаружения и
        автоматической настройки бинов в ходе сканирования путей к классам.
    </p>
    <p class="main-mind no_mb">Аннотация @Bean используется для явного объявления бина.</p>
    <p class="no_mb">
        A не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам:
    </p>
    <ul class="tab-2">
        <li>прописываем <strong>вручную метод для создания бина</strong>;</li>
        <li>
            делает возможным <strong>объявление бина независимо от объявления класса</strong>,
            что позволяет использовать классы из сторонних библиотек,
            у которых мы не можем указать аннотацию @Component;
        </li>
        <li>
            аннотацией @Bean <strong>можно настроить initMethod, destroyMethod, autowireCandidate</strong>,
            делая создание бина более гибким.
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Отличия @Service и @Repository</h1>
    <p class="no_mb">
        @Service и @Repository являются частными случаями @Component.
    </p>
    <p>
        <strong>Технически они одинаковы</strong> , но мы используем их<strong>для разных целей</strong>.
    </p>
    <p class="no_mb">
        Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать
        их как одно непроверенное исключение Spring Framework.
    </p>
    <p> Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor. </p>
    <p class="no_mb"> Мы помечаем бины аннотацией @Service, чтобы указать, что они содержат бизнес-логику. </p>
    <p>Так что нет никакого другого предназначения, кроме как использовать ее на уровне сервиса.</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Аннотация @Autowired</h1>
    <p class="main-mind">
        Аннотация Spring Framework, которой отмечают конструктор, поле, сеттер-метод или метод конфигурации,
        указывая, что им обязательно требуется внедрение зависимостей.
    </p>
    <p>
        Если в контейнере не будет обнаружен необходимый для вставки бин, то будет выброшено исключение, либо можно
        указать <an>@Autowired(required = false)</an>, означающее, что внедрение зависимости в данном месте
        необязательно.
    </p>
    <p>
        Аннотация @Autowired является альтернативой Java-аннотации @Inject, не имеющей required = false (зависимость
        должна быть обязательно внедрена).
    </p>
    <p class="no_mb">
        Начиная со Spring Framework 4.3, аннотация @Autowired для конструктора больше не требуется, если целевой
        компонент определяет только один конструктор.
    </p>
    <p>
        Однако, если доступно несколько конструкторов и нет
        основного/стандартного конструктора, по крайней мере один из конструкторов должен быть аннотирован @Autowired,
        чтобы указать контейнеру, какой из них использовать.
    </p>
    <p class="no_mb">
        <strong>По умолчанию Spring распознает объекты для вставки по типу</strong>.
    </p>
    <p>
        Если в контейнере доступно более одного бина одного и того же типа, будет исключение. Для избежания этого можно
        указать аннотацию Spring Framework - <an>@Qualifier</an>("fooFormatter"), где fooFormatter — это имя (Id) одного
        из нескольких бинов одного типа, находящихся в контейнере и доступных для внедрения:
    </p>
    <div class="code">
        <p>public class FooService {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1"><an>@Qualifier("fooFormatter")</an></p>
        <p class="tab-1">private Formatter formatter;</p>
        <p>}</p>
    </div>
    <hr>
    <h4>Выбор из нескольких бинов</h4>
    <p>
        <strong>При выборе</strong> между несколькими бинами при автоматическом внедрении
        <strong>используется имя поля</strong>.
        Это поведение по умолчанию, если нет других настроек.
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@Qualifier("fooFormatter")</an></p>
        <p>public class FooFormatter implements Formatter {</p>
        <p class="tab-1">//...</p>
        <p class="mb10">}</p>
        <p><an>@Component</an></p>
        <p><an>@Qualifier("barFormatter")</an></p>
        <p>public class BarFormatter implements Formatter {</p>
        <p class="tab-1">//...</p>
        <p class="mb10">}</p>
        <p>public class FooService {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">private Formatter fooFormatter;</p>
        <p>}</p>
    </div>
    <p>
        В этом случае Spring определит, что нужно внедрить бин с именем FooFormatter, поскольку имя поля соответствует
        значению, которое мы использовали в аннотации @Component для этого бина.
    </p>
    <hr>
    <h4>Вставка всех бинов</h4>
    <p>
        Мы также можем указать Spring предоставить все бины определенного типа из ApplicationContext, добавив аннотацию
        @Autowired в поле или метод с массивом или коллекцией этого типа:
    </p>
    <div class="code">
        <p><an>@Autowired</an></p>
        <p class="mb10">private MovieCatalog[] movieCatalogs;</p>
        <p class="mb10">или</p>
        <p><an>@Autowired</an></p>
        <p class="mb10">private Set &lt;MovieCatalog&gt; movieCatalogs;</p>
        <p class="mb10">или</p>
        <p><an>@Autowired</an></p>
        <p>public void setMovieCatalogs(Set &lt;MovieCatalog&gt; movieCatalogs) {</p>
        <p class="tab-1">this.movieCatalogs = movieCatalogs;</p>
        <p>}</p>
    </div>
    <p class="no_mb">Даже коллекции типа Map могут быть подключены автоматически, если тип ключа - String.</p>
    <p>Ключами будут имена бинов, а значениями - сами бины:</p>
    <div class="code">
        <p class="mb10">public class MovieRecommender {</p>
        <p class="tab-1 mb10">private Map&lt;String, MovieCatalog&gt; movieCatalogs;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {</p>
        <p class="tab-2">this.movieCatalogs = movieCatalogs;</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1 mb10">//...</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Аннотация @Resource</h1>
    <p><strong>Java-аннотация</strong>@Resource может применяться к классам, полям и методам.</p>
    <p class="main-mind">
        Она пытается получить зависимость: сначала по имени, затем по типу, затем по описанию (Qualifier).
    </p>
    <p>
        Имя извлекается <strong>из имени аннотируемого сеттера или поля,
        либо</strong> берется из параметра <strong>name</strong>.
    </p>
    <p>
        <strong>При аннотировании классов имя не извлекается из имени класса</strong>
        по умолчанию, поэтому оно <strong>должно быть указано явно</strong>.
    </p>
    <p>
        Указав данную аннотацию у полей или методов с аргументом name, в контейнере будет произведен поиск компонентов с
        данным именем, и <strong>в контейнере должен быть бин</strong> с таким именем:
    </p>
    <div class="code">
        <p><an>@Resource(name="namedFile")</an></p>
        <p>private File defaultFile;</p>
    </div>
    <p>
        Если указать её без аргументов, то Spring Framework может найти бин по типу.
    </p>
    <p>
        Если в контейнере несколько бинов-кандидатов на внедрение, то нужно использовать аннотацию <an>@Qualifier</an>
    </p>
    <div class="code">
        <p><an>@Resource</an></p>
        <p><an>@Qualifier("defaultFile")</an></p>
        <p>private File dependency1;</p>
        <p class="mb10"></p>
        <p><an>@Resource</an></p>
        <p><an>@Qualifier("namedFile")</an></p>
        <p>private File dependency2;</p>
    </div>

    <hr>
    <h4>Разница с @Autowired:</h4>
    <ul class="tab-2 sparse-li">
        <li>ищет бин сначала по имени, а потом по типу;</li>
        <li>не нужна дополнительная аннотация для указания имени конкретного бина;</li>
        <li>@Autowired позволяет отметить место вставки бина как необязательное @Autowired(required=false);</li>
        <li>при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.</li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1>Аннотация @Inject</h1>
    <p>
        <strong>Java-аннотация</strong>
        @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:
    </p>
    <div class="code">
        <p>&lt;dependency&gt;</p>
        <p class="tab-1">&lt;groupId&gt;javax.inject&lt;/groupId&gt;</p>
        <p class="tab-1">&lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</p>
        <p class="tab-1">&lt;version&gt;1&lt;/version&gt;</p>
        <p>&lt;/dependency&gt;</p>
    </div>
    <p>Размещается над полями, методами, и конструкторами с аргументами.</p>
    <p class="main-mind">
        @Inject как и @Autowired в первую очередь пытается подключить зависимость по типу, затем по описанию и только
        потом по имени.
    </p>
    <p>
        Это означает, что даже если имя переменной ссылки на класс отличается от имени компонента, но
        они одинакового типа, зависимость все равно будет разрешена:
    </p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p>private ArbitraryDependency fieldInjectDependency;</p>
    </div>
    <p>отличается от имени компонента, настроенного в контексте приложения:</p>
    <div class="code">
        <p><an>@Bean</an></p>
        <p>public ArbitraryDependency injectDependency() {</p>
        <p class="tab-1">ArbitraryDependency injectDependency = new ArbitraryDependency();</p>
        <p class="tab-1">return injectDependency;</p>
        <p>}</p>
    </div>
    <p>
        Разность имён injectDependency и fieldInjectDependency не имеет значения, зависимость будет подобрана по типу
        ArbitraryDependency.
    </p>
    <br>
    <p>
        Если в контейнере <strong>несколько бинов-кандидатов</strong> на внедрение,
        то нужно использовать аннотацию <strong>@Qualifier</strong>:
    </p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p><an>@Qualifier("defaultFile")</an></p>
        <p class="mb10">private ArbitraryDependency defaultDependency;</p>
        <p><an>@Inject</an></p>
        <p><an>@Qualifier("namedFile")</an></p>
        <p>private ArbitraryDependency namedDependency;</p>
    </div>
    <br>
    <p>При использовании конкретного имени (Id) бина используем @Named:</p>
    <div class="code">
        <p><an>@Inject</an></p>
        <p><an>@Named("yetAnotherFieldInjectDependency")</an></p>
        <p>private ArbitraryDependency yetAnotherFieldInjectDependency;</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1>Аннотация @Lookup</h1>
    <p>
        Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей
        мы используем конструктор или сеттер.
    </p>
    <p>

    </p>
    <p>
        Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый
        экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean).
        Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз
        новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь-то и пригодится
        <strong>внедрение бина с помощью Lookup-метода</strong> . Оно происходит не при инициализации контейнера, а
        позднее: <strong>каждый раз, когда вызывается метод</strong>.
    </p>
    <p>
        Суть в том, что мы создаём метод-заглушку в бине Car и помечаем его специальным образом – аннотацией @Lookup.
        Этот метод должен возвращать бин Passenger, каждый раз новый. Контейнер Spring под капотом создаст
        прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове
        аннотированного метода. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот
        метод будет переопределен в прокси-подклассе):
    </p>
    <div class="code">
        <p>@Component</p>
        <p class="mb10">public class Car {</p>
        <p class="tab-1"><an>@Lookup</an></p>
        <p class="tab-1">public Passenger createPassenger() {</p>
        <p class="tab-2">return null;</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1">public String drive(String name) {</p>
        <p class="tab-2">Passenger passenger = createPassenger();</p>
        <p class="tab-2">passenger.setName(name);</p>
        <p class="tab-2">return "car with " + passenger.getName();</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <p>
        Допустим, в бине есть метод drive(), и при каждом вызове метода drive() бину Car требуется новый экземпляр бина
        Passenger – сегодня пассажир Петя, завтра – Вася. То есть <strong></strong>бин Passenger прототипный. Для
        получения этого бина
        надо написать метод-заглушку createPassenger() и аннотировать его с помощью @Lookup.
    </p>
    <p>
        Контейнер Spring переопределит этот метод-заглушку и будет выдавать при его вызове каждый раз новый экземпляр
        Passenger.
    </p>
    <p>
        Переопределяем бин Passenger как прототипный:
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@Scope("prototype")</an></p>
        <p class="mb10">public class Passenger {</p>
        <p class="tab-1">private String name;</p>
        <p class="tab-1">// + геттер и сеттер</p>
        <p>}</p>
    </div>
    <p>
        Теперь при вызове метода drive() мы можем везти каждый раз нового пассажира. Имя его передаётся в аргументе
        метода drive(), и затем задается сеттером во вновь созданном экземпляре пассажира.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q12">
    <h1>Можно ли вставить бин в статическое поле?</h1>
    <p class="main-mind">Spring не позволяет внедрять бины напрямую в статические поля.</p>
    <p>Пример:</p>
    <div class="code">
        <p><an>@Component</an></p>
        <p class="mb10">public class TestDataInit {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1 mb10">private static OrderItemService orderItemService;</p>
        <p>}</p>
    </div>
    <p>
        <strong>Если вы распечатать TestDataInit.orderItemService, там будет null.</strong>
    </p>
    <p>Чтобы исправить это, необходимо создать нестатический сеттер-метод:</p>
    <div class="code">
        <p><an>@Component</an></p>
        <p class="mb10">public class TestDataInit {</p>
        <p class="tab-1 mb10">private static OrderItemService orderItemService;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setOrderItemService(OrderItemService orderItemService) {</p>
        <p class="tab-2">TestDataInit.orderItemService = orderItemService;</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q13">
    <h1>Аннотации @Primary и @Qualifier</h1>
    <p class="main-mind">
        @Primary - эта аннотация указывает, какой компонент определенного типа должен внедряться по умолчанию.
    </p>
    <div class="code no_mb">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class Config { </p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public Employee JohnEmployee() {</p>
        <p class="tab-2">return new Employee("John");</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Primary</an></p>
        <p class="tab-1">public Employee TonyEmployee() {</p>
        <p class="tab-2">return new Employee("Tony");</p>
        <p class="tab-1 mb10">}</p>
        <p></p>
        <p>}</p>
    </div>
    <p class="example no_mb">или</p>
    <div class="code no_mb">
        <p><an>@Component</an></p>
        <p class="mb10">public class DepartmentManager implements Manager {</p>
        <p class="tab-1"><an>@Override</an></p>
        <p class="tab-1">public String getManagerName() {</p>
        <p class="tab-2">return "Department manager";</p>
        <p class="tab-1 mb10">}</p>
        <p class="mb10">}</p>
        <p><an>@Component</an></p>
        <p><an>@Primary</an></p>
        <p class="mb10">public class GeneralManager implements Manager {</p>
        <p class="tab-1"><an>@Override</an></p>
        <p class="tab-1">public String getManagerName() {</p>
        <p class="tab-2">return "General manager";</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <p class="example">
        Теперь, где будут требоваться бины типа Employee и Manager будут созданы и внедрены TonyEmployee и
        GeneralManager.
    </p>
    <p class="example no_mb">Когда есть несколько бинов одного типа, подходящих для внедрения</p>
    <p>
        Aннотация @Qualifier позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить.
    </p>
    <p class="example no_mb">При совместном применении</p>
    <p>Аннотация @Qualifier будет иметь над @Primary приоритет.</p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q14">
    <h1 class="mb10">Как заинжектить примитив?</h1>
    <div class="after-h1">
        <p class="tab-2"><a href="#q14_value">@Value</a></p>
        <p class="tab-2"><a href="#q14_spel">@Value with SpEL</a></p>
        <p class="tab-2"><a href="#q14_map">@Value with Map</a></p>
        <p class="tab-2"><a href="#q14_constructor">@Value with Constructor</a></p>
        <p class="tab-2"><a href="#q14_setter">@Value with Setter</a></p>

    </div>
    <h3 id="q14_value">@Value</h3>
    <p>Внедрить в поле примитив можно с помощью аннотации @Value на уровне параметров поля или конструктора/метода.</p>
    <p>Значения, которые необходимо внедрить аннотацией @Value, определяются в файле свойств (*.properties)</p>
    <p class="no_mb"></p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@PropertySource("classpath:values.properties")</an></p>
        <p>public class CollectionProvider {</p>
        <p class="tab-1">//...</p>
        <p>}</p>
    </div>
    <p class="no_mb">Содержимое файла values.properties:</p>
    <div class="code">
        <p>value.from.file=Value got from the file</p>
        <p>priority=high</p>
        <p>listOfValues=A,B,C</p>
    </div>
    <p class="no_mb">Внедряем значение value.from.file, равное “Value got from the file”:</p>
    <div class="code">
        <p><an>@Value("${value.from.file}")</an></p>
        <p>private String valueFromFile;</p>
    </div>
    <p>
        Если из файла не подтянутся значения по тем или иным причинам, то можно указать значения,
        которые будут внедрены по умолчанию.
    </p>
    <p class="no_mb">В данном примере, если не будет доступен value.from.file, то внедрится значение “some default”:</p>
    <div class="code">
        <p><an>@Value("${value.from.file:some default}")</an></p>
        <p>private String someDefault;</p>
    </div>
    <p class="no_mb">
        Если нужно внедрить несколько значений, то можно их определить в файле *.properties через запятую и Spring
        внедрит их как массив:
    </p>
    <div class="code">
        <p><an>@Value("${listOfValues}")</an></p>
        <p>private String[] valuesArray;</p>
    </div>
    <hr>
    <h3 id="q14_spel">@Value with SpEL</h3>
    <p> Кроме того, для внедрения значений можно использовать язык SpEL (Spring Expression Language):</p>
    <div class="code no_mb">
        <p><an>@Value("#{systemProperties['priority']}")</an></p>
        <p>private String spelValue;</p>
    </div>
    <p class="example no_mb">или со значениями по умолчанию:</p>
    <div class="code">
        <p><an>@Value("#{systemProperties['unknown'] ?: 'some default'}")</an></p>
        <p>private String spelSomeDefault;</p>
    </div>
    <p class="no_mb"> Можно использовать значение поля из другого бина. </p>
    <p class="example no_mb">
        Предположим, есть бин с именем someBean с полем someValue, равным 10. В поле будет записано число 10:
    </p>
    <div class="code">
        <p><an>@Value("#{someBean.someValue}")</an></p>
        <p>private Integer someBeanValue;</p>
    </div>
    <p class="no_mb">Можно манипулировать свойствами, чтобы получить список значений.</p>
    <p class="example no_mb">Получаем список строковых значений A, B и C:</p>
    <div class="code">
        <p><an>@Value("#{'${listOfValues}'.split(',')}")</an></p>
        <p>private List&lt;String&gt; valuesList;</p>
    </div>
    <hr>
    <h3 id="q14_map">@Value with Map</h3>
    <p>Можно использовать аннотацию @Value для добавления свойств в Map.</p>
    <p class="no_mb">Свойство в файле свойств должно быть определено в формате {key: 'value'}:</p>
    <div class="code">
        <p>valuesMap={key1: '1', key2: '2', key3: '3'}</p>
    </div>
    <p class="no_mb">Вставка:</p>
    <div class="code">
        <p><an>@Value("#{${valuesMap}}")</an></p>
        <p>private Map &lt;String, Integer&gt; valuesMap;</p>
    </div>
    <p class="no_mb">Можем просто внедрить значение по ключу:</p>
    <div class="code">
        <p><an>@Value("#{${valuesMap}.key1}")</an></p>
        <p>private Integer valuesMapKey1;</p>
    </div>
    <p class="no_mb">
        Если достоверно не известно, содержит ли Map определенный ключ, то нужно выбрать более безопасное выражение,
        которое не будет генерировать исключение, а установит значение в null, если ключ не найден:
    </p>
    <div class="code">
        <p><an>@Value("#{${valuesMap}['unknownKey']}")</an></p>
        <p>private Integer unknownMapKey;</p>
    </div>
    <p class="no_mb"> Можно установить значения по умолчанию для свойств или ключей, которые могут не существовать: </p>
    <div class="code">
        <p><an>@Value("#{${unknownMap : {key1: '1', key2: '2'}}}")</an></p>
        <p class="mb10">private Map&lt;String, Integer&gt; unknownMap;</p>
        <p><an>@Value("#{${valuesMap}['unknownKey'] ?: 5}")</an></p>
        <p>private Integer unknownMapKeyWithDefaultValue;</p>
    </div>
    <p class="no_mb"> Записи карты также могут быть отфильтрованы перед внедрением.</p>
    <p class="example no_mb"> Предположим, нам нужно получить только те записи, значения которых больше единицы: </p>
    <div class="code">
        <p><an>@Value("#{${valuesMap}.?[value>'1']}")</an></p>
        <p>private Map&lt;String, Integer&gt; valuesMapFiltered;</p>
    </div>
    <p class="no_mb"> Мы также можем использовать аннотацию @Value для добавления всех текущих системных свойств: </p>
    <div class="code">
        <p><an>@Value("#{systemProperties}")</an></p>
        <p>private Map&gt;String, String&gt; systemPropertiesMap;</p>
    </div>
    <hr>
    <h3 id="q14_constructor">@Value with Constructor</h3>
    <p class="no_mb">
        Можно внедрять значения в конструкторе, если оно не найдено, то будет внедрено значение по умолчанию:
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@PropertySource("classpath:values.properties")</an></p>
        <p class="mb10">public class PriorityProvider {</p>
        <p class="tab-1 mb10">private String priority;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public PriorityProvider(<an>@Value("${priority:normal}")</an> String priority) {</p>
        <p class="tab-2">this.priority = priority;</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1 mb10">//standard getter</p>
        <p>}</p>
    </div>
    <hr>
    <h3 id="q14_setter">@Value with Setter</h3>
    <p>В приведенном коде используется выражение SpEL для добавления списка значений в метод setValues:</p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@PropertySource("classpath:values.properties")</an></p>
        <p class="mb10">public class CollectionProvider {</p>
        <p class="tab-1 mb10">private List&lt;String&gt; values = new ArrayList<>();</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setValues(<an>@Value("#{'${listOfValues}'.split(',')}")</an>
            List&lt;String&gt; values) {</p>
        <p class="tab-2">this.values.addAll(values);</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q15">
    <h1 class="mb10">Как заинжектить коллекцию?</h1>
    <div class="after-h1">
        <p class="tab-2"><a href="#q15_array">Array Injection</a></p>
        <p class="tab-2"><a href="#q15_collection">Collections Injection</a></p>
        <p class="tab-2"><a href="#q15_beans">Коллекции бинов одного типа</a></p>
        <p class="tab-2"><a href="#q15_qualifier">Использование @Qualifier</a></p>
        <p class="tab-2"><a href="#q15_sort">Упорядочивание элементов массивов/списков</a></p>
    </div>
    <hr>
    <h3 id="q15_array">Array Injection</h3>
    <p>
        Можно вставлять массивы примитивов и ссылочных типов. Со всеми массивами и коллекциями можно использовать
        внедрение через конструкторы, сеттеры или поля:
    </p>
    <div class="code">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class ArrayExample {</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public TestBean testBean() {</p>
        <p class="tab-2">return new TestBean();</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public String[] strArray() {</p>
        <p class="tab-2">return new String[]{"two", "three", "four"};</p>
        <p class="tab-1 mb10">}</p>
        <p class="mb10">}</p>
        <p class="mb10">public class TestBean {</p>
        <p class="tab-1 mb10">private String[] stringArray;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setStringArray (String[] stringArray) {</p>
        <p class="tab-2">this.stringArray = stringArray;</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>

    <hr>
    <h3 id="q15_collection">Collections Injection</h3>
    <div class="code">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class ListExample {</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public TestBean testBean() {</p>
        <p class="tab-2">return new TestBean();</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public List&lt;String&gt; strList() {</p>
        <p class="tab-2">return Arrays.asList("two", "three", "four");</p>
        <p class="tab-1">}</p>
        <p class="mb10">}</p>
        <p class="mb10">public class TestBean {</p>
        <p class="tab-1 mb10">private List &lt;String&gt; stringList;</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1">public void setStringList (List&lt;String&gt; stringList) {</p>
        <p class="tab-2">this.stringList = stringList;</p>
        <p class="tab-1">}</p>
        <p>}</p>
    </div>

    <hr>
    <h3 id="q15_beans">Коллекции бинов одного типа</h3>
    <p class="no_mb">
        Можно собрать все бины одного типа, находящиеся в контейнере, и внедрить их в коллекцию или массив:
    </p>
    <div class="code">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class SetInjection {</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public TestBean testBean() {</p>
        <p class="tab-2">return new TestBean();</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public RefBean refBean1() {</p>
        <p class="tab-2">return new RefBean("bean 1");</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public RefBean refBean2() {</p>
        <p class="tab-2">return new RefBean2("bean 2");</p>
        <p class="tab-1 mb10">}</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public RefBean refBean3() {</p>
        <p class="tab-2">return new RefBean3("bean 3");</p>
        <p class="tab-1 mb20">}</p>

        <p class="tab-1 mb10">public static class TestBean {</p>
        <p class="tab-2 example">// All bean instances of type RefBean will be injecting here</p>
        <p class="tab-2"><an>@Autowired</an></p>
        <p class="tab-2 mb10">private Set&lt;RefBean&gt; refBeans;</p>
        <p class="tab-2 mb10">...</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1 mb10">public static class RefBean {</p>
        <p class="tab-2 mb10"> private String str;</p>
        <p class="tab-2">public RefBean(String str) {</p>
        <p class="tab-3">this.str = str;</p>
        <p class="tab-2 mb10">}</p>
        <p class="tab-2 mb10">...</p>
        <p class="tab-1 mb10">}</p>

        <p>}</p>
    </div>

    <p class="no_mb">
        Если нужно внедрить вышеупомянутые бины RefBean в Map, то значениями Map будут сами бины, а ключами будут
        имена бинов:
    </p>
    <div class="code">
        <p>{refBean1 = RefBean{str='bean 1'}, refBean2 = RefBean{str='bean 2'},
            refBean3 = RefBean{str='bean 3'}}</p>
    </div>

    <hr>
    <h3 id="q15_qualifier">Использование @Qualifier</h3>
    <p class="no_mb">
        Методы класса JavaConfig (те, которые аннотированы @Bean) могут быть объявлены с определенным квалифицирующим
        типом, используя @Qualifier. Используя параметр 'name' у аннотации @Bean, чтобы указать конкретный
        классификатор для бина, указывается не имя, а идентификатор бина, который должен быть уникальным,
        потому что все бины хранятся в контейнере в Map.
    </p>
    <p>
        В случае если необходимо чтобы несколько бинов имели одно и то же имя квалификатора, чтобы их можно было
        внедрить в одну коллекцию с одним и тем же квалификатором, нужно использовать аннотацию @Qualifier вместе с
        @Bean вместо элемента name.
    </p>
    <div class="code">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class SetInjection {</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public TestBean testBean() {</p>
        <p class="tab-2">return new TestBean();</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public RefBean refBean1() {</p>
        <p class="tab-2">return new RefBean("bean 1");</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Qualifier("myRefBean")</an></p>
        <p class="tab-1">public RefBean refBean2() {</p>
        <p class="tab-2">return new RefBean2("bean 2");</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Qualifier("myRefBean")</an></p>
        <p class="tab-1">public RefBean refBean3() {</p>
        <p class="tab-2">return new RefBean3("bean 3");</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1 mb10">public static class TestBean {</p>
        <p class="tab-2"><an>@Autowired</an></p>
        <p class="tab-2"><an>@Qualifier("myRefBean")</an></p>
        <p class="tab-2 mb10">private Set&lt;RefBean&gt; refBeans;</p>
        <p class="tab-2 mb10">...</p>
        <p class="tab-1 mb10">}</p>

        <p>}</p>
    </div>
    <p><strong>
        Только бины с именами refBean2 и refBean3 попадут в коллекцию, так как у них одинаковые квалификаторы -
        myRefBean.
    </strong></p>

    <hr>
    <h3 id="q15_sort">Упорядочивание элементов массивов/списков</h3>
    <p class="no_mb">Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы.</p>
    <p>Поддерживаются как аннотация @Order, так и интерфейс Ordered.</p>
    <p class="no_mb">Например:</p>
    <div class="code no_mb">
        <p><an>@Configuration</an></p>
        <p class="mb10">public class ArrayExample {</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public TestBean testBean() {</p>
        <p class="tab-2">return new TestBean();</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Order(3)</an></p>
        <p class="tab-1">public String refString1() {</p>
        <p class="tab-2">return "my string 1";</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Order(1)</an></p>
        <p class="tab-1">public String refString2() {</p>
        <p class="tab-2">return "my string 2";</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1"><an>@Order(2)</an></p>
        <p class="tab-1">public String refString3() {</p>
        <p class="tab-2">return "my string 3";</p>
        <p class="tab-1 mb10">}</p>

        <p class="tab-1 mb10">private static class TestBean {</p>
        <p class="tab-2 mb10">private String[] stringArray;</p>

        <p class="tab-2"><an>@Autowired</an></p>
        <p class="tab-2">public void setStringArray (String[] stringArray) {</p>
        <p class="tab-3">this.stringArray = stringArray;</p>
        <p class="tab-2 mb10">}</p>

        <p class="tab-2">public String[] getStringArray() {</p>
        <p class="tab-3">return stringArray;</p>
        <p class="tab-2 mb10">}</p>

        <p class="tab-1 mb10">}</p>

        <p>}</p>
    </div>
    <p class="example no_mb">Массив строк будет выглядеть так:</p>
    <p class="example">[my string 2, my string 3, my string 1]</p>

    <hr>
    <br>
    <div class="image-box">
        <img class="image" src="./img/inject.png" alt="схема внедрения">
    </div>
    <br>
    <hr>
    <h4>Также можно объявить бин-коллекцию и внедрять её в другие бины:</h4>
    <div class="code">
        <p><an>@Service</an></p>
        <p><an>@Getter</an></p>
        <p class="mb10">public class ActionHeroesService {</p>
        <p class="tab-1"><an>@Autowired</an></p>
        <p class="tab-1 mb10">List&lt;Hero&gt; actionHeroes;</p>
        <p class="mb10">}</p>
        <p><an>@Configuration</an></p>
        <p class="mb10">public class HeroesConfig {</p>
        <p class="tab-1"><an>@Bean</an></p>
        <p class="tab-1">public List&lt;Hero&gt; action() {</p>
        <p class="tab-2">List&lt;Hero&gt; result = new ArrayList<>();</p>
        <p class="tab-2">result.add(new Terminator());</p>
        <p class="tab-2">result.add(new Rambo());</p>
        <p class="tab-2">return result;</p>
        <p class="tab-1 mb10">}</p>
        <p>}</p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q16">
    <h1>Аннотация @Conditional</h1>
    <p>
        Часто бывает полезно включить или отключить весь класс @Configuration, @Component или отдельные методы @Bean в
        зависимости от каких-либо условий.
    </p>
    <p class="main-mind">
        Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все
        условия соответствуют.
    </p>
    <p class="no_mb">Может применяться:</p>
    <ul class="tab-2">
        <li>над классами прямо или косвенно аннотированными @Component, включая классы @Configuration;</li>
        <li>над методами @Bean;</li>
        <li>как мета-аннотация при создании наших собственных аннотаций-условий.</li>
    </ul>
    <p>
        Условия проверяются непосредственно перед тем, как должно быть зарегистрировано BeanDefinition компонента, и они
        могут помешать регистрации данного BeanDefinition. Поэтому нельзя допускать, чтобы при проверке условий мы
        взаимодействовали с бинами (которых еще не существует), с их BeanDefinition-ами можно.
    </p>
    <p class="no_mb">
        Условия мы определяем в специально создаваемых нами классах, которые должны имплементировать функциональный
        интерфейс Condition с одним единственным методом, возвращающим true или false:
    </p>
    <div class="code">
        <p>boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)</p>
    </div>

    <p class="no_mb">
        Создав свой класс и переопределив в нем метод matches() со своей логикой, необходимо передать этот класс в
        аннотацию @Conditional в качестве параметра:
    </p>
    <div class="code">
        <p><an>@Configuration</an></p>
        <p><an>@Conditional(OurConditionClass.class)</an></p>
        <p>class MySQLAutoconfiguration {</p>
        <p class="tab-1">//...</p>
        <p>}</p>
    </div>

    <p class="no_mb">
        Для того, чтобы проверить несколько условий, можно передать в @Conditional несколько классов с условиями:
    </p>
    <div class="code">
        <p><an>@Bean</an></p>
        <p><an>@Conditional(HibernateCondition.class, OurConditionClass.class)</an></p>
        <p>Properties additionalProperties() {</p>
        <p>//...</p>
        <p>}</p>
    </div>

    <p class="main-mind">
        Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации
        @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.
    </p>
    <p><strong>Для детальной настройки</strong> классов, аннотированных @Configuration используется интерфейс
        <strong>ConfigurationCondition</strong></p>
    <p class="no_mb"><strong>В одном классе - одно условие</strong>.</p>
    <p>
        Для создания более сложных условий можно использовать классы AnyNestedCondition,
        AllNestedConditions и NoneNestedConditions.
    </p>

    <p class="no_mb">
        В Spring Framework имеется множество готовых аннотаций (и связанных с ними склассами-условиями,
        имплементирующими интерфейс Condition), которые можно применять совместно над одним определением бина:
    </p>
    <table class="list list--dictionary" aria-label="Conditional annotation">
        <thead>
        <tr>
            <th>Аннотация</th>
            <th>Описание</th>
        <tr>
        </thead>
        <tr>
            <td>ConditionalOnBean</td>
            <td>Условие выполняется, в случае если присутствует нужный бин в BeanFactory.</td>
        </tr>
        <tr>
            <td>ConditionalOnClass</td>
            <td>Условие выполняется, если нужный класс есть в classpath.</td>
        </tr>
        <tr>
            <td>ConditionalOnCloudPlatform</td>
            <td>Условие выполняется, когда активна определенная платформа.</td>
        </tr>
        <tr>
            <td>ConditionalOnExpression</td>
            <td>Условие выполняется, когда SpEL выражение вернуло положительное значение.</td>
        </tr>
        <tr>
            <td>ConditionalOnJava</td>
            <td>Условие выполняется, когда приложение запущено с определенной версией JVM.</td>
        </tr>
        <tr>
            <td>ConditionalOnJndi</td>
            <td>Условие выполняется, только если через JNDI доступен определенный ресурс.</td>
        </tr>
        <tr>
            <td>ConditionalOnMissingBean</td>
            <td>Условие выполняется, в случае если нужный бин отсутствует в контейнере.</td>
        </tr>
        <tr>
            <td>ConditionalOnMissingClass</td>
            <td>Условие выполняется, если нужный класс отсутствует в classpath.</td>
        </tr>
        <tr>
            <td>ConditionalOnNotWebApplication</td>
            <td>Условие выполняется, если контекст приложения не является веб контекстом.</td>
        </tr>
        <tr>
            <td>ConditionalOnProperty</td>
            <td>Условие выполняется, если в файле настроек заданы нужные параметры.</td>
        </tr>
        <tr>
            <td>ConditionalOnResource</td>
            <td>Условие выполняется, если присутствует нужный ресурс в classpath.</td>
        </tr>
        <tr>
            <td>ConditionalOnSingleCandidate</td>
            <td>
                Условие выполняется, если bean-компонент указанного класса уже содержится в контейнере и он
                единственный.
            </td>
        </tr>
        <tr>
            <td>ConditionalOnWebApplication</td>
            <td>Условие выполняется, если контекст приложения является веб контекстом.</td>
        </tr>
    </table>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q17">
    <h1>Аннотация @ComponentScan</h1>
    <p class="no_mb">
        Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим
        сканировать на наличие компонентов, из которых нужно сделать бины.
    </p>
    <p class="no_mb">
        @ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты.
    </p>
    <p>
        Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan.
    </p>
    <p class="no_mb">В контейнер попадут:</p>
    <ul class="tab-2">
        <li>бин конфигурационного класса;</li>
        <li>бины, объявленные в конфигурационном классе с помощью @Bean;</li>
        <li>все бины из пакета и его подпакетов.</li>
    </ul>
    <p>
        Аннотация <strong>@SpringBootApplication включает</strong> в себя аннотации <strong>
        @ComponentScan, @SpringBootConfiguration и @EnableAutoConfiguration </strong>,
        но это не мешает разместить её ещё раз отдельно для указания конкретного пакета.
    </p>

    <p class="no_mb">
        Если указать @ComponentScan с атрибутом <strong>basePackages</strong>, то это
        <strong>изменит пакет</strong> по умолчанию <strong>на указанный</strong>:</p>
    <div class="code">
        <p><an>@ComponentScan(basePackages = "com.baeldung.componentscan.springapp.animals") </an></p>
        <p><an>@Configuration</an></p>
        <p>public class SpringComponentScanApp {</p>
        <p class="tab-1">//...</p>
        <p>}</p>
    </div>

    <p class="no_mb">
        Если указать @ComponentScan с атрибутом <strong>excludeFilters</strong>, то это позволит использовать
        <strong>фильтр</strong> и исключить ненужные классы из процесса сканирования:
    </p>
    <div class="code">
        <p><an>@ComponentScan(excludeFilters =
        </an></p>
        <p class="tab-1"><an>
            @ComponentScan.Filter(type=FilterType.REGEX,
        </an></p>
        <p class="tab-2"><an>
            pattern="com\\.baeldung\\.componentscan\\.springapp\\.flowers\\..*"))
        </an></p>
    </div>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q18">
    <h1>Аннотация @Profile</h1>
    <p class="no_mb">
        Профили — это ключевая особенность Spring Framework, позволяющая нам относить бины к разным профилям
        (логическим группам), например, dev, test, prod.
    </p>
    <p>
        Можно активировать разные профили в разных средах, чтобы загрузить только те бины, которые нужны.
    </p>
    <p class="main-mind no_mb">Аннотацию @Profile, относит бин к конкретному профилю.</p>
    <p class="example">Можно применять на уровне класса или метода.</p>
    <p class="no_mb">Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей.</p>
    <p class="example">Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional.</p>

    <h4>Пример:</h4>
    <p class="no_mb">
        Есть бин, который должен быть активным только во время разработки, но не должен использоваться в продакшене.
    </p>
    <p class="no_mb">
        Аннотируем этот компонент с профилем <span class="code-word">«dev»</span>, и он будет присутствовать в
        контейнере только во время разработки - во время продакшена профиль dev просто не будет активен:
    </p>
    <div class="code">
        <p><an>@Component</an></p>
        <p><an>@Profile("dev")</an></p>
        <p>public class DevDatasourceConfig {...}</p>
    </div>
    <p class="no_mb">
        В качестве быстрого обозначения имена профилей также могут начинаться с оператора NOT, например «!dev», чтобы
        исключить их из профиля:
    </p>
    <div class="code no_mb">
        <p><an>@Component</an></p>
        <p><an>@Profile("!dev")</an></p>
        <p>public class DevDatasourceConfig {...}</p>
    </div>
    <p class="example">Тут компонент активируется, только если профиль «dev» не активен.</p>
    <p>
        Следующим шагом является активация нужного профиля для того, чтобы в контейнере были зарегистрированы только
        бины, соответствующие данному профилю.
        <strong>Одновременно могут быть активны несколько профилей.</strong>
    </p>
    <p class="no_mb">
        По умолчанию, <strong>если профиль бина не определен</strong>, то он относится
        <strong>к профилю "default"</strong>.
    </p>
    <p>
        Spring также предоставляет способ установить профиль по умолчанию, когда другой профиль не активен, используя
        свойство «spring.profiles.default».
    </p>
    <p>
        В Spring Boot есть возможность иметь один файл настроек application.properties, в котором будут основные
        настройки для всех профилей, и иметь по файлу настроек для каждого профиля application-dev.properties и
        application-prod.properties, содержащие свои собственные дополнительные настройки.
    </p>

    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q19">
    <h1 class="no_mb">ApplicationContext и BeanFactory</h1>
    <div class="after-h1">
        <p>Чем отличаются? В каких случаях что стоит использовать?</p>
        <p class="tab-2"><a href="#q19_bf">BeanFactory</a></p>
        <p class="tab-2"><a href="#q19_ac">ApplicationContext</a></p>
        <p class="tab-2"><a href="#q19_eq">ApplicationContext vs. BeanFactory</a></p>
    </div>
    <h3 id="q19_bf">BeanFactory</h3>
    <p class="main-mind">
        BeanFactory — это интерфейс, который предоставляет механизм конфигурации, способный управлять объектами любого
        типа.
    </p>
    <p class="no_mb">
        В общем, BeanFactory предоставляет инфраструктуру конфигурации и основные функциональные возможности.
    </p>
    <p>BeanFactory легче по сравнению с ApplicationContext.</p>

    <hr>
    <h3 id="q19_ac">ApplicationContext</h3>
    <p class="main-mind">
        ApplicationContext является наследником BeanFactory и полностью реализует его функционал, добавляя больше
        специфических enterprise-функций.
    </p>
    <hr>
    <h3 id="q19_eq">ApplicationContext vs. BeanFactory</h3>
    <table class="list list--content-center" aria-label="">
        <thead>
        <tr>
            <th>Особенность</th>
            <th>BeanFactory</th>
            <th>ApplicationContext</th>
        <tr>
        </thead>
        <tr>
            <td>Bean instantiation/wiring</td>
            <td>Yes</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Integrated lifecycle management</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Automatic BeanPostProcessor registration</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Automatic BeanFactoryPostProcessor registration</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Convenient MessageSource access (for internalization)</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Built-in ApplicationEvent publication mechanism</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
    </table>

    <ul class="sparse-li">
        <li>ApplicationContext загружает все бины при запуске, а BeanFactory - по требованию.</li>
        <li>
            <p class="mb10">
                ApplicationContext расширяет BeanFactory и предоставляет функции, которые подходят для корпоративных
                приложений:
            </p>
            <ul class="sparse-li">
                <li>поддержка внедрения зависимостей на основе аннотаций;</li>
                <li>удобный доступ к MessageSource (для использования в интернационализации);</li>
                <li>публикация ApplicationEvent - для бинов, реализующих интерфейс ApplicationListener, с помощью
                    интерфейса ApplicationEventPublisher;
                </li>
                <li>простая интеграция с функциями Spring AOP.</li>
            </ul>
        </li>
        <li>
            <p>ApplicationContext поддерживает автоматическую регистрацию BeanPostProcessor и
                BeanFactoryPostProcessor.</p>
            <p class="example">
                Поэтому всегда желательно использовать ApplicationContext, потому что Spring 2.0 (и выше) интенсивно
                использует BeanPostProcessor.
            </p>
        </li>
        <li>
            ApplicationContext поддерживает практически все типы scope для бинов, а BeanFactory поддерживает только два
            - Singleton и Prototype.
        </li>
        <li>
            В BeanFactory не будут работать транзакции и Spring AOP. Это может привести к путанице, потому что
            конфигурация с виду будет корректной.
        </li>
    </ul>

    <a href="#" class="button button--top"></a>
</section>


<section class="container" id="q20">
    <h1>Жизненный цикл бина, аннотации @PostConstruct и @PreDestroy </h1>
    <div class="after-h1">
        <p class="tab-2"><a href="#q20_beans">Жизненный цикл бинов</a></p>
        <p class="tab-2"><a href="#q20_predestroy">@PreDestroy</a></p>
        <p class="tab-2"><a href="#q20_postconstuct">@PostConstruct</a></p>
    </div>
    <h3 id="q20_beans">Жизненный цикл бинов</h3>
    <ul class="tab-2">
        <li class="no_mb">Парсирование конфигурации и создание BeanDefinition</li>
        <li class="no_mb">Настройка созданных BeanDefinition</li>
        <li class="no_mb">Создание кастомных FactoryBean (только для XML-конфигурации)</li>
        <li class="no_mb">Создание экземпляров бинов</li>
        <li class="no_mb">Настройка созданных бинов</li>
        <li class="no_mb">Бины готовы к использованию</li>
        <li class="no_mb">Закрытие контекста</li>
    </ul>
    <hr>
    <h3 id="q20_predestroy">Аннотация @PreDestroy</h3>
    <hr>
    <h3 id="q20_postconstuct">Аннотация @PostConstruct</h3>
    <a href="#" class="button button--top"></a>
</section>
<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

<script src="../../../js/spoiler.js"></script>
<script src="../../../js/script.js"></script>

</html>



