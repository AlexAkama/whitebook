<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA</title>
    <link rel="stylesheet" href="../../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">JAVA</h1>
    <div class="after-h1">Вопросы к собеседованию</div>
    <ol class="menu">
        <li><a href="#q1">Какая основная идея языка?</a></li>
        <li><a href="#q2">За счет чего обеспечивается кроссплатформенность?</a></li>
        <li><a href="#q3">Какие преимущества у JAVA?</a></li>
        <li><a href="#q4">Какие недостатки у JAVA?</a></li>
        <li><a href="#q5">Что такое JDK? Что в него входит?</a></li>
        <li><a href="#q6">Что такое JRE? Что в него входит?</a></li>
        <li><a href="#q7">Что такое JVM?</a></li>
        <li><a href="#q8">Что такое byte code?</a></li>
        <li><a href="#q9">Что такое загрузчик классов (classloader)?</a></li>
        <li><a href="#q10">Что такое JIT?</a></li>
        <li><a href="#q11">Что такое сборщик мусора? (Garbage collector)</a></li>
        <li><a href="#q12">Что такое Heap и Stack память в Java? Чем они отличаются?</a></li>
    </ol>
    <div class="back-panel">
        <a href=".." class="button button--back">Назад</a>
    </div>
</section>

<section class="container" id="q1">
    <h1>Какая основная идея языка?</h1>
    <p>
        <strong>Кроссплатформенность</strong> -
        «написано/скомпилировано однажды, запускается везде» (compile once, run anywhere).
    </p>
    <p>
        Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать
        на любой компьютерной архитектуре, для которой существует реализация виртуальной Java- машины.
    </p>
    <p class="no_mb"><strong><a href="#q8">Байт-код Java</a></strong>
        - набор инструкций, исполняемых виртуальной машиной Java.
    </p>
    <p class="no_mb">
        Каждый код операции байт-кода - один байт. Используются не все 256 возможных значений кодов операций.
    </p>
    <p class="no_mb">51 из них зарезервированы для использования в будущем.</p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q2">
    <h1>За счет чего обеспечивается кросс-платформенность?</h1>
    <p class="no_mb">
        <strong>Java Virtual Machine (JVM)</strong>
        - виртуальная машина Java - основная часть исполняющей системы Java, так называемой
        <strong>Java Runtime Environment (JRE)</strong>.
    </p>
    <p class="no_mb">
        Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы
        компилятором Java (javac). JVM может также использоваться для выполнения программ,
        написанных на других языках программирования.
    </p>
    <p class="example">
        Например, исходный код на языке Ada может быть скомпилирован в байт-код Java, который затем может выполниться с
        помощью JVM.
    </p>
    <div class="image-box">
        <img src="img/ebc.png" alt="EBC">
    </div>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q3">
    <h1>Какие преимущества&nbsp;у JAVA?</h1>
    <ul>
        <li>
            <strong>Объектно-ориентированный:</strong>
            все является объектом. Дополнение может быть легко расширено.
        </li>
        <li><strong>Платформонезависимый</strong></li>
        <li><strong>Простой для понимания:</strong> основные концепции ООП.</li>
        <li>
            <strong>Безопасный:</strong>
            методы проверки подлинности основаны на шифровании с открытым ключом.
        </li>
        <li>
            <strong>Архитектурно-нейтральным:</strong>
            компилятор генерирует архитектурно-нейтральные объекты формата файла, что делает скомпилированный код
            исполняемым на многих процессорах, с наличием системе Java Runtime.
        </li>
        <li>
            <strong>Портативный:</strong>
            архитектурно-нейтральный и не имеющий зависимости от реализации аспектов спецификаций -
            все это делает Java портативным. Компилятор в Java написан на ANSI C с чистой переносимостью,
            который является подмножеством POSIX.
        </li>
        <li>
            <strong>Прочный:</strong>
            прилагает усилия, чтобы устранить ошибки в различных ситуациях, делая упор в
            основном на время компиляции, проверку ошибок и проверку во время выполнения.
        </li>
        <li>
            Язык для распределенного программирования и комфортной удаленной совместной работы.
            <p class="example no_mb">
                Специфическая для Java методология распределенных вычислений называется Remote Method
                Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность,
                независимость от платформы и объектно-ориентированное программирование для
                распределенных вычислений.
            </p>
        </li>
        <li>
            <strong>Автоматическое управление памятью</strong>
        </li>
        <li>
            <strong>Многопоточность</strong>
        </li>
        <li>
            <strong>Стабильность и сообщество</strong>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q4">
    <h1>Какие недостатки&nbsp;у JAVA?</h1>
    <ul>
        <li>
            Платное коммерческое использование. Oracle с 2019 взимает плату за использование Java
            Standard Edition 8 в «коммерческих целях».
        </li>
        <li>
            Низкая производительность (из-за компиляции и абстракции с помощью виртуальной
            машины, очистки памяти, взаимная блокировка потоков).
        </li>
        <li>
            Отсутствие нативного дизайна для создания графического интерфейса пользователя (GUI).
            Есть Swing, SWT, JavaFX, JSF …но не катят.
        </li>
        <li>
            Многословный и сложный код. длинные, чрезмерно сложные предложения затрудняют чтение
            и просмотр кода. Как и естественные языки, многие языки программирования высокого уровня
            содержат лишнюю информацию.
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q5">
    <h1>Что такое JDK? Что в него входит?</h1>
    <p>
        <strong>Java Development Kit (JDK)</strong>
        - комплект разработчика приложений на языке Java:
    </p>
    <ul>
        <li>исполнительная система Java (JRE: Java Virtual Machine (JVM) + библиотеки Java-классов).</li>
        <li>компилятор Java (javac)</li>
        <li>
            стандартные библиотеки классов Java, примеры, документацию, утилиты (вспомогательная
            компьютерная программа в составе общего программного обеспечения для выполнения
            специализированных типовых задач, связанных с работой оборудования и операционной системы)
        </li>
    </ul>
    <p class="important">
        JDK позволяет разработчикам создавать программы, которые могут выполняться и запускаться посредством JVM и JRE;
    </p>
    <div class="image-box">
        <img src="img/jdk.png" alt="JDK">
    </div>
    <a class="link-to-source" href="https://topjava.ru/blog/what-is-the-jdk" target="_blank">Источник</a>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q6">
    <h1>Что такое JRE? Что в него входит?</h1>
    <p>
        <strong> Java Runtime Environment (JRE среда выполнения для Java)</strong>
        - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и
        других средств разработки: Java Virtual Machine + и библиотеки Java-классов.
    </p>
    <h3>Как JRE работает с JVM</h3>
    <p class="no_mb">
        Виртуальная машина Java — программное обеспечение, отвечающее за выполнение Java-программ. JRE — это программа,
        которая берет ваш Java-код, объединяет его с необходимыми библиотеками и запускает JVM для его выполнения.
        JRE содержит программное обеспечение и библиотеки, которые требуются для работы вашей программы. Например,
        загрузчик классов Java является частью JRE. Эта важная часть программного обеспечения загружает скомпилированный
        Java-код в память и соединяет с соответствующими библиотеками.
        В этом многоуровневом представлении JVM создается средой выполнения Java. С точки зрения пакета, JRE содержит
        JVM, как показано на рисунке:
    </p>
    <div class="image-box">
        <img src="img/jre.png" alt="JRE">
    </div>
    <a class="link-to-source" href="https://topjava.ru/blog/what-is-the-jre" target="_blank">Подробнее</a>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q7">
    <h1>Что такое JVM?</h1>
    <p>
        <strong>Java Virtual Machine (JVM)</strong>
        - это программа, предназначенная для выполнения других программ.
    </p>
    <p class="no_mb">
        Это основная часть JRE. Исполняет байт-код Java, предварительно созданный из исходного текста
        Java-программы компилятором Java (javac). JVM может также использоваться для выполнения
        программ, написанных на других языках программирования.
    </p>
    <p class="example">
        Например, исходный код на языке Ada может быть скомпилирован в байт-код Java,
        который затем может выполниться с помощью JVM
    </p>
    <p class="no_mb">JVM имеет две основные функции:</p>
    <ol>
        <li>Позволяет запускать Java-приложения на любых устройствах или операционных системах.</li>
        <li>Управляет и оптимизирует память, используемую приложением.</li>
    </ol>
    <a class="link-to-source" href="https://topjava.ru/blog/what-is-the-jvm" target="_blank">Подробнее</a>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q8">
    <h1>Что такое byte code?</h1>
    <p>
        Промежуточное представление кода, в которое может быть переведена компьютерная программа автоматическими
        средствами. Машинно-независимый код низкого уровня, генерируемый транслятором из исходного кода
        - набор валидных (соответствующих спецификации Java) команд.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q9">
    <h1>Что такое загрузчик классов (classloader)?</h1>
    <p>
        <strong>Загрузчик классов</strong>
        является частью JRE, которая динамически загружает Java классы в JVM.
    </p>
    <p>
        Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых
        системах благодаря загрузчику классов. Делегирование является важной концепцией, которую выполняет загрузчик.
    </p>
    <p>
        Загрузчик классов отвечает за поиск библиотек, чтение их содержимого и загрузку классов,
        содержащихся в библиотеках. Эта загрузка обычно выполняется «по требованию», поскольку она не
        происходит до тех пор, пока программа не вызовет класс. Класс с именем может быть загружен только
        один раз данным загрузчиком классов.
    </p>
    <p class="no_mb">
        При запуске JVM, используются три загрузчика классов:
    </p>
    <ul>
        <li><strong>Bootstrap class loader</strong> (Загрузчик класса Bootstrap)</li>
        <li><strong>Extensions class loader</strong> (Загрузчик класса расширений)</li>
        <li><strong>System class loader</strong> (Системный загрузчик классов)</li>
    </ul>
    <p>
        <strong>Загрузчик класса Bootstrap</strong> - загружает основные библиотеки Java, расположенные в папке
        &lt;JAVA_HOME&gt;/jre/lib. Этот загрузчик является частью ядра JVM, написан на нативном коде.
    </p>
    <p>
        <strong>Загрузчик класса расширений</strong> - загружает код в каталоги расширений. &lt;JAVA_HOME&gt;/jre/lib/ext,
        или любой другой каталог, указанный системным свойством java.ext.dirs.
    </p>
    <p>
        <strong>Системный загрузчик</strong> - загружает код, найденный в java.class.path, который сопоставляется с
        переменной среды CLASSPATH. Это реализуется классом sun.misc.Launcher$AppClassLoader.
    </p>
    <p class="no_mb">
        Загрузчик классов выполняет три основных действия в строгом порядке:
    </p>
    <ul>
        <li>
            <strong>Загрузка:</strong>
            находит и импортирует двоичные данные для типа.
        </li>
        <li>
            <strong>Связывание:</strong>
            выполняет проверку, подготовку и (необязательно) разрешение.
            <ul class="no_mb">
                <li><strong>Проверка:</strong> обеспечивает правильность импортируемого типа.</li>
                <li><strong>Подготовка:</strong>
                    выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
                </li>
                <li><strong>Разрешение:</strong> преобразует символические ссылки из типа в прямые ссылки.</li>
            </ul>
        </li>
        <li>
            <strong>Инициализация:</strong>
            вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.
        </li>
    </ul>

    <h3 class="no_mb">Пользовательский загрузчик классов</h3>
    <p>
        Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не
        понимая тонких деталей JVM. У каждого загрузчика классов Java есть родительский загрузчик классов,
        определенный при создании экземпляра нового загрузчика классов или в качестве системного загрузчика
        классов по умолчанию для виртуальной машины.
    </p>
    <p class="no_mb">Что делает возможным следующее:</p>
    <ul>
        <li>загружать или выгружать классы во время выполнения (например, динамически загружать
            библиотеки во время выполнения, даже из ресурса HTTP). Это важная особенность для:
            <ul class="no_mb">
                <li>реализация скриптовых языков;</li>
                <li>использование bean builders;</li>
                <li>добавить пользовательскую расширение;</li>
                <li>позволяя нескольким пространствам имен общаться.
                    <p class="example no_mb">Например, это одна из основ протоколов CORBA / RMI;</p>
                </li>
            </ul>
        </li>
        <li>изменить способ загрузки байт-кода
            <p class="example no_mb">(например, можно использовать зашифрованный байт-код класса Java);</p>
        </li>
        <li>модифицировать загруженный байт-код
            <p class="example no_mb">(например, для переплетения аспектов во время загрузки при использовании
                аспектно-ориентированного программирования);</p>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q10">
    <h1>Что такое JIT?</h1>
    <p>
        <strong> JIT-компиляция</strong>
        (англ. Just-in-time compilation, компиляция «на лету»), динамическая компиляция (англ. dynamic translation)
        - технология увеличения производительности программных систем, использующих байт-код, путём компиляции
        байт-кода в машинный код или в другой формат непосредственно во время работы программы.
    </p>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q11">
    <h1>Что такое сборщик мусора?</h1>
    <p class="important">Способ автоматического управления памятью.</p>
    <p class="no_mb">Сборщик мусора (Garbage Collector) должен делать всего две вещи:</p>
    <ul>
        <li><strong>Находить мусор</strong> - неиспользуемые объекты.
            <p class="no_mb">Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный
                момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой
                сущностью приложения, обрывается.</p>
        </li>
        <li><strong>Освобождать память от мусора.</strong></li>
    </ul>
    <p>Работа сборщика мусора не бесплатная, она оплачивается ресурсами компьютера и задержками в
        выполнении программы.</p>
    <hr>
    <h3>Обнаружение мусора</h3>
    <p class="no_mb">Существует два подхода к обнаружению мусора:</p>
    <div class="tab-1">
        <ul>
            <li>Reference counting;</li>
            <li>Tracing;</li>
        </ul>
    </div>

    <p class="no_mb"><strong>Reference counting</strong> (подсчёт ссылок).</p>
    <p class="no_mb">
        Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько
        ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю -
        объект можно считать мусором.
    </p>
    <p>
        Главным минусом такого подхода является сложность обеспечения точности
        счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на
        друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.
    </p>
    <p class="no_mb"><strong>Tracing</strong> (трассировка)</p>
    <p>
        - живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (GC Root) и те
        объекты, которые доступны с живого объекта. Всё остальное - мусор.
    </p>
    <div class="tab-1">
        <p class="no_mb">Существует 4 типа корневых точки:</p>
        <div class="tab-1">
            <ul>
                <li>Локальные переменные и параметры методов;</li>
                <li>Потоки;</li>
                <li>Статические переменные;</li>
                <li>Ссылки из JNI.</li>
            </ul>
        </div>
        <p class="no_mb">Самое простое java приложение будет иметь корневые точки:</p>
        <div class="tab-1">
            <ul>
                <li>Локальные переменные внутри main() метода и параметры main() метода;</li>
                <li>Поток который выполняет main();</li>
                <li>Статические переменные класса, внутри которого находится main() метод.</li>
            </ul>
        </div>
        <p>
            Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам
            нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы
            сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические
            зависимости легко выявляются. HotSpot VM использует именно такой подход.
        </p>
    </div>
    <hr>
    <h3>Очистка от мусора</h3>
    <p class="no_mb">Для очистки памяти от мусора существуют два основных метода:</p>
    <div class="tab-1">
        <ul>
            <li>Copying collectors</li>
            <li>Mark-and-sweep</li>
        </ul>
    </div>
    <p class="no_mb">
        При <strong>Copying collectors</strong> подходе память делится на две части «from-space» и «to-space», при
        этом сам принцип работы такой:
    </p>
    <div class="tab-1">
        <ul>
            <li>Объекты создаются в «from-space»;</li>
            <li>Когда «from-space» заполняется, приложение приостанавливается;</li>
            <li>Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;</li>
            <li>Когда все объекты скопированы «from-space» полностью очищается;</li>
            <li>«to-space» и «from-space» меняются местами.</li>
        </ul>
    </div>

    <p class="no_mb"><strong>Главный плюс</strong> такого подхода в том, что объекты плотно забивают память.</p>
    <p class="no_mb"><strong>Минусы</strong> подхода:</p>
    <ol>
        <li>Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;</li>
        <li>В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового
            размера.
        </li>
    </ol>
    <p class="no_mb">Алгоритм работы <strong>mark-and-sweep</strong> можно описать так:</p>
    <div class="tab-1">
        <ul>
            <li>Объекты создаются в памяти;</li>
            <li>В момент, когда нужно запустить сборщик мусора приложение приостанавливается;</li>
            <li>Сборщик проходится по дереву объектов, помечая живые объекты;</li>
            <li>Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
            </li>
            <li>Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».</li>
        </ul>
    </div>
    <p class="no_mb"><strong>Минусы</strong> этого способа:</p>
    <div class="tab-1">
        <ol>
            <li>Приложение не работает пока происходит сборка мусора;</li>
            <li>Время остановки напрямую зависит от размеров памяти и количества объектов;</li>
            <li>Если не использовать «compacting» память будет использоваться не эффективно.</li>
        </ol>
    </div>
    <hr>
    <h3>Сборщики мусора HotSpot VM</h3>
    <p>Они используют комбинированный подход
        <strong>Generational Garbage Collection</strong>
        , который позволяет использовать разные алгоритмы для разных этапов сборки мусора.
    </p>

    <p class="no_mb">Этот подход опирается на том, что:</p>
    <ul>
        <li>большинство создаваемых объектов быстро становятся мусором;</li>
        <li>существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.
        </li>
    </ul>
    <hr>
    <h3>Как работает сборщик мусора?</h3>
    <p> Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов. </p>
    <p class="no_mb">
        Объекты создаются посредством оператора <span class="example--word bold">new</span>
        , тем самым присваивая объекту ссылку.
    </p>
    <p class="no_mb">
        Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив
        переменной ссылку на другой объект или значение null. Так же можно прекратить выполнение метода, чтобы его
        локальные переменные завершили свое существование естественным образом.
    </p>
    <p> Объекты, на которые отсутствуют ссылки, принято называть мусором (garbage), который будет удален. </p>
    <p>
        Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект,
        обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого
        кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти.
        Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим
        посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно
        существующей в выполняемом коде.
    </p>
    <p>
        Память освобождается сборщиком мусора по его собственному «усмотрению». Программа
        может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не
        приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.
    </p>
    <p>
        Мусор собирается системой автоматически, без вмешательства пользователя или
        программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость
        создания и удаления большого количества объектов существенным образом сказывается на
        производительности приложений и если быстродействие программы является важным фактором,
        следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь,
        уменьшит и объем мусора, подлежащего утилизации.
    </p>
    <hr>
    <h3>Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?</h3>
    <p class="no_mb">Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:</p>
    <ul>
        <li>
            <p class="no_mb">
                <strong>Serial (последовательный)</strong> — самый простой вариант для приложений с небольшим объемом
                данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на
                слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.
            </p>
            <p class="no_mb example">Использование Serial GC включается опцией:</p>
            <div class="code">XX:+UseSerialGC</div>
        </li>
        <li>
            <p class="no_mb">
                <strong>Parallel (параллельный)</strong> — наследует подходы к сборке от последовательного сборщика, но
                добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под
                требуемые параметры производительности.
            </p>
            <p class="no_mb example">Параллельный сборщик включается опцией:</p>
            <div class="code">XX:+UseParallelGC</div>
        </li>
        <li>
            <p class="no_mb">
                <strong>Concurrent Mark Sweep (CMS)</strong> — нацелен на снижение максимальных задержек путем
                выполнения части работ по сборке мусора параллельно с основными потоками приложения.
                Подходит для работы с относительно большими объемами данных в памяти.
            </p>
            <p class="no_mb example">Использование CMS GC включается опцией:</p>
            <div class="code">XX:+UseConcMarkSweepGC</div>
        </li>
        <li>
            <p class="no_mb">
                <strong>Garbage-First (G1)</strong> — создан для замены CMS, особенно в серверных приложениях,
                работающих на многопроцессорных серверах и оперирующих большими объемами данных.
            </p>
            <p class="no_mb example">G1 включается опцией Java:</p>
            <div class="code">XX:+UseG1GC</div>
        </li>
    </ul>
    <a href="#" class="button button--top"></a>
</section>

<section class="container" id="q12">
    <h1></h1>
    <a href="#" class="button button--top"></a>
</section>

<div class="navi">
    <a class="navi-button navi--prev" href="../oop/">ООП</a>
    <a class="navi-button navi--next" href="">Процедурная JAVA</a>
</div>

<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

</html>