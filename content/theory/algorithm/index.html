<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALGORITHMS</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Алгоритмы</h1>
    <div class="after-h1">Краткое описание</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="../../theory/">Теория</a></p>
        <p>Алгоритмы</p>
    </div>
    <ol class="menu">
        <li><a href="#fast-n-slow">Алгоритм Заяц и Черепаха</a></li>
        <li><a href="#binary_search">Бинарный поиск</a></li>
        <li><a href="#poly_hash">Полиномиальные хеши</a></li>
        <li><a href="#find_union">Алгоритм FIND-UNION</a></li>
    </ol>
</section>

<section class="container" id="fast-n-slow">
    <h1><a href="#">Алгоритм Заяц и Черепаха</a></h1>
    <p class="main-mind">
        Принцип достаточно прост - делаем два указателя и пускаем их по списку с разной скоростью.
        Первый медленный или черепаха идет по каждому узлу списка, а второй, быстрый Заяц - скачет через один.
    </p>
    <p class="no_mb">Что из этого можно получить?</p>
    <p>В магию математики погружаться не будем...</p>

    <h4>1. Найти середину списка</h4>
    <p class="no_mb">Если заяц доскакал до конца, то черепаха будет как раз на середине. Красота! </p>
    <p>Возвращаем указатель "черепаха" вот вам и решение задачи.</p>

    <div class="image-box">
        <img src="./img/midle1.jpg" alt="Поиск среднего 1">
        <img src="./img/midle2.jpg" alt="Поиск среднего 2">
    </div>

    <h4>2. Определить цикличен список или нет?</h4>
    <p class="no_mb">
        Опять запускаем наших животных и ждем когда они встретятся. А они точно встретятся (магия математики).
    </p>
    <p class="no_mb">
        Т.е. если последний узел зациклен на любой из узлов списка, то заяц обязательно войдет в цикл и
        догонит черепаху.
    </p>
    <p> И вот если два указателя показывают на одно и то же место, то список однозначно зациклен.</p>
    <div class="image-box">
        <img src="./img/circular.png" alt="Цикличный список">
    </div>

    <h4>3. Определить начала цикла.</h4>
    <p class="no_mb">
        Если наш список зациклен, то исходя их пункта 2 мы можем узнать где "встретились" черепаха и заяц.
    </p>
    <p class="no_mb">
        А дальше опять магия, если начать движение по каждому следующему узлу от головы списка и от точки встречи,
        то точка пересечения, т.е. когда оба указателя дойдут до одного узла, то этот узел и будет первым узлом цикла.
    </p>
    <p>Не верите, проверьте! Магия работает!!!</p>


    <h4>4. Определить последний элемент замкнутого списка</h4>
    <p>
        Ну тут совсем просто, нашли первый узел цикла, и топаем дальше пока не найдем узел который на него ссылается.
        Вот вам и последний элемент.
    </p>

    <p style="margin-top: 40px">И еще парочка задач, когда дано два списка</p>

    <h4>1. Узнать пересекаются они или нет?</h4>
    <p>Тут сначала проходим эти списки до конца, если конец один и тот же элемент значит пересекаются.</p>

    <div class="image-box">
        <img src="img/intersection.png" alt="Пересечение списков">
    </div>
    <h4>2. Если пресекаются, то где?</h4>
    <p class="no_mb">А тут опять магия, берем "хвост" и зацикливаем его на одну из голов.</p>
    <p class="no_mb">А со второй ищем первую точку цикла - которая и есть точка пересечения.</p>
    <p class="example">Только после не забывайте убрать цикл с хвоста, что бы чего не вышло...</p>

</section>

<section class="container" id="binary_search">
    <h1><a href="#">Бинарный поиск (Binary Search)</a></h1>

    <p>
        Основная мысль бинарного поиска заключается в эффективном нахождении заданного элемента в упорядоченном массиве
        данных. Основная идея состоит в том, чтобы разделить массив пополам и проверить, находится ли искомый элемент в
        левой или правой половине массива. Затем процесс повторяется для выбранной половины, пока не будет найден
        искомый элемент или пока не останется только один элемент в массиве.
    </p>

    <div class="image-box">
        <img class="image-box" src="img/binary_search.png" alt="Бинарный поиск">
    </div>

    <p class="no_mb">Основной алгоритм бинарного поиска:</p>
    <ol>
        <li>
            Установите начальные значения для переменных low (нижняя граница) и high (верхняя граница) равными 0 и
            length&nbsp;-&nbsp;1, где length - это длина массива.
        </li>
        <li>
            <p>Пока low не превышает high, выполните следующие шаги:</p>
            <ul class="no_mb">
                <li>Вычислите средний индекс как (low&nbsp;+&nbsp;high)&nbsp;/&nbsp;2</li>
                <li>Если элемент с индексом mid равен искомому элементу, верните&nbsp;mid</li>
                <li>Если элемент с индексом mid меньше искомого элемента, обновите low как mid&nbsp;+&nbsp;1</li>
                <li>Если элемент с индексом mid больше искомого элемента, обновите high как mid&nbsp;-&nbsp;1</li>
            </ul>
        </li>
        <li> Если цикл завершается без нахождения искомого элемента, верните -1</li>
    </ol>

    <p class="main-mind">
        Бинарный поиск работает ТОЛЬКО на отсортированных массивах.
    </p>

    <p class="no_mb">Пример кода:</p>
    <div class="code">
    <pre>    public static int <method>binarySearch</method>(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }</pre>
    </div>

</section>

<section class="container" id="poly_hash">
    <h1><a href="#">Полиномиальные хеши</a></h1>
    <div>
        <h3>Теория</h3>
        <p>Много где используются, но мне попадались в задачах на сравнение строк.</p>
        <p>Представим, что у нас есть строка, где s<sub>i</sub> - это символ (или его код)</p>
        <p class="tab-1 bold">
            s<sub>0</sub>s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub>...s<sub>n</sub>
        </p>
        <p>Считаем полиномиальный хеш, где <span class="bold">p</span> - это основание хеша</p>
        <div class="scroll">
            <p class="tab-1 bold no_wrap">
                h<sub>[0,n]</sub> =
                s<sub>0</sub>p<sup>0</sup> +
                s<sub>1</sub>p<sup>1</sup> +
                s<sub>2</sub>p<sup>2</sup> +
                s<sub>3</sub>p<sup>3</sup> +
                s<sub>4</sub>p<sup>4</sup> +
                ... +
                s<sub>n</sub>p<sup>n</sup>
            </p>
        </div>
        <p class="example tab-1">Это прямой полиномиальный хеш, а есть еще обратный -
            это когда идут с максимальной степени основания вниз.</p>
        <p>Далее если мы хотим посчитать хеш подстроки с индекса l до индекса r, для примера пусть l=1 и r=3,
            он будет выглядеть так:</p>
        <p class="tab-1 bold">
            h<sub>[1,3]</sub> =
            s<sub>1</sub>p<sup>0</sup> +
            s<sub>2</sub>p<sup>1</sup> +
            s<sub>3</sub>p<sup>2</sup>
        </p>
        <p>т.е. это не что иное, как этот кусок на <span class="bold">p<sup>1</sup></span></p>
        <div class="scroll">
            <p class="tab-1 bold no_wrap">
                h<sub>[0,n]</sub> =
                s<sub>0</sub>p<sup>0</sup> +
                <span class="bad">[s<sub>1</sub>p<sup>1</sup> +
            s<sub>2</sub>p<sup>2</sup> +
            s<sub>3</sub>p<sup>3</sup>]</span> +
                s<sub>4</sub>p<sup>4</sup> +
                ...
                s<sub>n</sub>p<sup>n</sup>
            </p>
        </div>
        <p>Таким не сложным образом мы можем получить форму для вычисления хеша подстроки</p>
        <div class="scroll">
            <p class="tab-1 bold mb20 no_wrap">
                h<sub>[k,m]</sub> = (h<sub>[0,m]</sub> - h<sub>[0,k-1]</sub>) / p<sup>k</sup>
            </p>
        </div>
        <p>Но как это работает при больших n?</p>
        <p> Например, если p=29, то в уже в 15й степени длинна числа будем 22 символа, а в лонге всего 19
            (если мне память не изменяет). Т.е. реализовав это в "как есть" у нас не получится полностью
            рабочий вариант для больших n.</p>
        <p>B тут включается магия математики мы проводим операции по модулю.</p>
    </div>
    <div>
        <h3>Реализация</h3>
        <div>
            <p>Первое что надо сдетать это определить основание P и модуль MODULE.<br>
                Это два простых числа, первое маленькое, второе - большое.</p>
            <div class="code">
                <pre>private static final int <field>P</field> = 29;
private static final long <field>MODULE</field> = 1_000_000_007L;</pre>
            </div>
            <p>Что бы не считать каждый раз степени модуля вычисляем их сразу столько сколько надо:</p>
            <div class="code no_mb">
                <pre>private static void <method>initPower</method>(int n) {
    power = new long[n + 1];
    power[0] = 1;
    for (int i = 1; i < n + 1; i++) {
        power[i] = (power[i - 1] * P) % MODULE;
    }
}</pre>
            </div>
            <p class="example">Тут уже используется модуль.</p>
            <p>Теперь считаем и заполняем массив префиксных хэшей для того с чем будем работать:</p>
            <div class="code no_mb">
                <pre>private static void <method>buildPrefixHashArray</method>(String s) {
    prefixHashArray = new long[s.length() + 1];
    for (int i = 1; i < s.length() + 1; i++) {
        prefixHashArray[i] = (prefixHashArray[i - 1] + (s.charAt(i - 1) - 'a' + 1) * power[i - 1]) % MODULE;
    }
}</pre>
            </div>
            <p class="example">Запись "char-'a'+1" тут использована просто для получения порядкового номера
                символа в алфавите, т.к. в моей задаче строка состоит только из маленьких английских букв.
                Но использование кода символа тоже работает.</p>
            <p>Так же нам понадобится просо вычислять хеш строки:</p>
            <div class="code">
                <pre>private static long <method>calculateHash</method>(String s) {
    long hash = 0;
    int p = 0;
    for (char c : s.toCharArray()) {
        hash = (hash + getCharPowerValue(c) * power[p++]) % MODULE;
    }
    return hash;
}</pre>
            </div>
            <p>И последнее - надо научится получать хеш подстроки, а это достаточно просто:</p>
            <div class="code">
                <pre>private static long <method>getIntervalHash</method>(int startIndex, int finishIndex) {
    long sub = prefixHashArray[finishIndex] - prefixHashArray[startIndex];
    return sub > -1 ? sub : sub + MODULE;
}</pre>
            </div>
            <p> Обратите внимание на то, как метод <span class="bold">getIntervalHash</span>
                возвращает ответ - это магия циклических колец. Этот момент я долго не мог понять,
                а поэтому и не учитывал в коде.</p>
        </div>

        <p>Теперь у нас есть все инструменты, что бы сравнивать строки или подстроки.</p>
        <a class="link-to-source" href="https://ru.algorithmica.org/cs/hashing/polynomial/"
           target="_blank">Один из источников вдохновения.</a>
    </div>
    <div>
        <h3>Краткое резюме от ИИ</h3>
        <div>
            <p>Преимущества использования полиномиальных хешей при сравнении строк заключаются в следующем:</p>

            <p class="term mb10">
                <span>Эффективность</span>:
                <br>Полиномиальные хеши позволяют вычислять хеш-коды строки за линейное время и сравнивать их
                за константное время. Это значительно ускоряет задачу сравнения строк по сравнению с посимвольным
                сравнением, особенно для длинных строк. </p>
            <p class="term mb10">
                <span>Сравнение подстрок</span>:
                <br>Полиномиальные хеши поддерживают эффективное вычисление хешей для подстрок, что
                полезно в задачах, связанных с поиском подстрок и алгоритмами поиска шаблонов. </p>
            <p class="term mb10">
                <span>Устойчивость к коллизиям</span>:
                <br>При правильно выбранных параметрах (в том числе модуле и базе) вероятность
                коллизий хешей низка. Это делает подход надежным на практике. </p>
            <p class="term mb10">
                <span>Простота реализации</span>:
                <br>Алгоритм полиномиального хеширования прост в реализации и может быть легко
                адаптирован для различных задач, связанных с обработкой строк. </p>

            <p> Эти качества делают полиномиальные хеши распространённым выбором для задач, связанных со сравнением
                строк, таких как текстовые алгоритмы и структуры данных,
                например, "суффиксные массивы" или "интервалные деревья". </p>
        </div>
    </div>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="find_union">
    <h1><a href="#">Алгоритм <span class="no_wrap">FIND-UNION</span></a></h1>
    <div>
        <div>
            <h3>Основные операции</h3>
            <ol>
                <li><p class="term mb10">
                    <span>Find (Найти)</span>:
                    <br> Определяет, к какому множеству принадлежит элемент. Это может быть использовано для проверки
                    принадлежности двух элементов одному множеству.
                </p></li>
                <li><p class="term mb10">
                    <span>Union (Объединить)</span>:
                    <br>Объединяет два множества в одно.
                </p></li>
            </ol>
        </div>
        <div>
            <h3>Основные концепции</h3>
            <ul>
                <li><p class="term mb10">
                    <span>Репрезентатив (Представитель)</span>:
                    <br>Каждый элемент множества имеет некоторое представительное значение (обычно голову дерева),
                    которое является корнем дерева представления данного множества.
                </p></li>
                <li><p class="term mb10">
                    <span>Ранговое дерево и сжатие путей</span>:
                    <br>Используются для оптимизации работы алгоритма.
                    Сжатие путей помогает уменьшить глубину дерева, быстро находя представителя,
                    а ранговое дерево помогает поддерживать низкую высоту дерева при объединении.
                </p></li>
            </ul>
        </div>
        <div>
            <h3>Реализация</h3>
            <p>Реализуем это как отдельную структуру данных, т.е. сделаем отдельный класс</p>
            <div>
                <h4>Конструктор</h4>
                <p>Создаем массивы, представляющие "родителей" каждого узла и их "ранги" (глубину деревьев). </p>
                <div>
                    <div class="code">
                        <pre>    private int[] <field>parent</field>;
    private int[] <field>rank</field>;</pre>
                    </div>
                    <p>Инициализирует массивы.
                        Изначально каждый элемент является своим собственным родителем и имеет ранг 1.</p>
                    <div class="code no_mb">
                        <pre>    public <method>UnionFind</method>(int size) {
        init(size);
    }

    private void <method>init</method>(int size) {
        parent = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            parent[i] = i;
            rank[i] = 1;
        }
    }</pre>
                    </div>
                    <p class="example">Можно конечно всю инициализацию сделать в конструкторе.</p>
                </div>
            </div>
            <div>
                <h4>FIND</h4>
                <div>
                    <p>Метод находит корень узла p с помощью рекурсивного сжатия путей,
                        что позволяет быстро находить корень и уменьшает глубину существующих деревьев.</p>
                    <details>
                        <summary class="mb10">Немного теории: FIND</summary>
                        <div>
                            <p class="term mb10">
                                <span>Рекурсивное сжатие путей</span>
                                <br>Это оптимизация, используемая в структуре данных Union-Find
                                для ускорения операции&nbsp;find.
                                <br>Основная идея заключается в том, чтобы сделать деревья более плоскими,
                                что уменьшает время выполнения последующих операций. </p>
                        </div>
                        <div>
                            <h4>Как работает сжатие путей?</h4>
                            <p>Когда мы выполняем операцию find, цель состоит в том, чтобы определить корень элемента p.
                                При стандартной реализации достаточно следовать по цепочке родительских связей до корня.
                                Но, применяя сжатие путей, мы не просто ищем корень,
                                но и изменяем родителя каждого посещённого узла на реальный корень.
                                Это помогает в будущем значительно сократить путь поиска для других узлов,
                                проходящих через те же промежуточные узлы. </p>
                        </div>
                        <div>
                            <h4>Пример работы</h4>
                            <div>
                                <p class="term">
                                    Предположим, у нас есть цепочка узлов:
                                    <span>5&nbsp;->&nbsp;3&nbsp;->&nbsp;1</span>, где&nbsp;1&nbsp;—&nbsp;корень.
                                </p>
                                <ol>
                                    <li><p class="term mb10">
                                        Обычная операция <span>find(5)</span> (без сжатия путей):
                                        <br>Идём от&nbsp;5&nbsp;к&nbsp;3, затем от&nbsp;3&nbsp;к&nbsp;1.
                                        Находим, что корень — это&nbsp;1.</p></li>
                                    <li><p class="term mb10">
                                        Операция <span>find(5)</span> с сжатием путей:
                                        <br>После поиска корня&nbsp;(1), мы меняем так,
                                        чтобы 5 указывал непосредственно на&nbsp;1. Теперь 5&nbsp;->&nbsp;1.
                                        <br>Это уменьшает глубину дерева и позволяет в следующий раз быстрее находить
                                        корень.
                                    </p></li>
                                </ol>
                            </div>
                        </div>
                        <div>
                            <h4>Преимущества</h4>
                            <div>
                                <p class="term mb10">
                                    <span>Уменьшение глубины дерева</span>:
                                    <br>Чем более плоские деревья, тем быстрее операции.
                                </p>
                                <p class="term mb10">
                                    <span>Оптимизация времени</span>:
                                    <br>После применения сжатия путей, операции find работают почти за постоянное время
                                    — O(α(n)), где α(n) — обратная функция Аккермана, которая растет чрезвычайно
                                    медленно. На практике это фактически O(1) для вычислимых значений.
                                </p>
                            </div>
                        </div>
                    </details>
                    <div class="code">
                        <pre>   public int <method>find</method>(int p) {
        if (parent[p] != p) {
            parent[p] = find(parent[p]); <comment>// Рекурсивное сжатие путей</comment>
        }
        return parent[p];
    }</pre>
                    </div>
                    <details>
                        <summary>Пояснение к коду</summary>
                        <div>
                            <p class="term mb10">
                                <span>Базовый случай</span>:
                                <br>Если parent[p]&nbsp;==&nbsp;p, значит p&nbsp;—&nbsp;корень,
                                и мы просто возвращаем его.</p>
                            <p class="term mb10">
                                <span>Рекурсивный случай</span>:
                                <br>Если parent[p]&nbsp;!=&nbsp;p, мы рекурсивно находим корень p и при этом
                                изменяем parent[p] напрямую на найденный корень. Это основное сжатие путей.</p>
                            <p>Таким образом, в следующий раз, когда мы попытаемся найти корень узла в том же наборе,
                                путь будет значительно короче, а во многих случаях — даже прямым переходом к корню.</p>
                        </div>
                    </details>
                </div>
            </div>
            <div>
                <h4>UNION</h4>
                <div>
                    <p>Метод union в структуре данных Union-Find используется для объединения двух множеств,
                        которые содержат заданные элементы.
                        Он объединяет два поддерева в одно, следуя определённой стратегии,
                        чтобы минимизировать глубину полученного дерева.
                        Это ключевая операция для обеспечения эффективности Union-Find.</p>
                </div>
                <details>
                    <summary class="mb10">Немного теории: UNION</summary>
                    <div>
                        <p class="term mb10">
                            <span>Основная мысль</span>
                            <br>Цель операции union — сделать так,
                            чтобы корень одного из деревьев стал родителем корня другого, effectively merging the trees.
                            Чтобы минимизировать высоту дерева, применяется стратегия "сжатия по рангу"
                            (или по размеру).
                        </p>
                        <p class="term mb10">
                            <span>Сжатие по рангу</span>
                            <br>Ранг узла часто коррелируется с высотой дерева, хотя это не обязательно абсолютная
                            высота. Идея в том, что банально объединять деревья по этому рангу.
                        </p>
                        <p class="term mb10">
                            <span>Объединение по рангу</span>
                            <br>При объединении деревьев мы делаем корневым родителем то дерево,
                            ранг (высота) которого выше.
                            Это помогает поддерживать как можно более плоскую структуру дерева.
                            <br>Если ранги одинаковы, одно из деревьев становится корнем,
                            и его ранг увеличивается на единицу, так как глубина увеличилась.
                        </p>
                    </div>
                </details>
                <div class="code">
                    <pre>   public void <method>union</method>(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);

        if (rootP != rootQ) {
            <comment>// Объединяем более низкое дерево под более высокое</comment>
            if (rank[rootP] > rank[rootQ]) {
                parent[rootQ] = rootP;
            } else if (rank[rootP] < rank[rootQ]) {
                parent[rootP] = rootQ;
            } else {
                parent[rootQ] = rootP;
                rank[rootP]++; <comment>// увеличиваем ранг, если высоты равны</comment>
            }
        }
    }
</pre>
                </div>
                <details>
                    <summary class="mb10">Пояснение к коду</summary>
                    <div>
                        <ol>
                            <li><p class="term mb10">
                                <span>Нахождение корней</span>:
                                <br>Сначала мы находим корни p и q с помощью метода find,
                                применяя сжатие путей для сокращения деревьев.
                            </p></li>
                            <li><p class="term mb10">
                                <span>Проверка равенства корней</span>:
                                <br>Если корни этих элементов равны, они уже в одном множестве,
                                и union ничего не делает.
                            </p></li>
                            <li><p class="term mb10">
                                <span>Сравнение и объединение по рангам</span>:
                                <br>Если ранг корня rootP больше, то rootQ присоединяется к rootP.
                                <br>Если ранг rootQ больше, то наоборот: rootP присоединяется к rootQ.
                                <br>Если ранги равны, выбирается один из них в качестве нового корня,
                                и его ранг увеличивается на&nbsp;1.
                            </p></li>
                        </ol>
                    </div>
                </details>
            </div>
        </div>
    </div>
    <a class="button button--to_top_menu" href="#"></a>
</section>

<a href="#" class="button button--top"></a>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

</body>

</html>