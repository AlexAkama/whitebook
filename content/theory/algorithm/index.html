<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALGORITHMS</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">Алгоритмы</h1>
    <div class="after-h1">Краткое описание</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="../../theory/">Теория</a></p>
        <p>Алгоритмы</p>
    </div>
    <ol class="menu">
        <li><a href="#q1">Алгоритм Заяц и Черепаха</a></li>
        <li><a href="#q2">Бинарный поиск</a></li>
    </ol>
</section>

<section class="container" id="q1">
    <h1><a href="#">Алгоритм Заяц и Черепаха</a></h1>
    <p class="main-mind">
        Принцип достаточно прост - делаем два указателя и пускаем их по списку с разной скоростью.
        Первый медленный или черепаха идет по каждому узлу списка, а второй, быстрый Заяц - скачет через один.
    </p>
    <p class="no_mb">Что из этого можно получить?</p>
    <p>В магию математики погружаться не будем...</p>

    <h4>1. Найти середину списка</h4>
    <p class="no_mb">Если заяц доскакал до конца, то черепаха будет как раз на середине. Красота! </p>
    <p>Возвращаем указатель "черепаха" вот вам и решение задачи.</p>

    <div class="image-box">
        <img src="./img/midle1.jpg" alt="Поиск среднего 1">
        <img src="./img/midle2.jpg" alt="Поиск среднего 2">
    </div>

    <h4>2. Определить цикличен список или нет?</h4>
    <p class="no_mb">
        Опять запускаем наших животных и ждем когда они встретятся. А они точно встретятся (магия математики).
    </p>
    <p class="no_mb">
        Т.е. если последний узел зациклен на любой из узлов списка, то заяц обязательно войдет в цикл и
        догонит черепаху.
    </p>
    <p> И вот если два указателя показывают на одно и то же место, то список однозначно зациклен.</p>
    <div class="image-box">
        <img src="./img/circular.png" alt="Цикличный список">
    </div>

    <h4>3. Определить начала цикла.</h4>
    <p class="no_mb">
        Если наш список зациклен, то исходя их пункта 2 мы можем узнать где "встретились" черепаха и заяц.
    </p>
    <p class="no_mb">
        А дальше опять магия, если начать движение по каждому следующему узлу от головы списка и от точки встречи,
        то точка пересечения, т.е. когда оба указателя дойдут до одного узла, то этот узел и будет первым узлом цикла.
    </p>
    <p>Не верите, проверьте! Магия работает!!!</p>


    <h4>4. Определить последний элемент замкнутого списка</h4>
    <p>
        Ну тут совсем просто, нашли первый узел цикла, и топаем дальше пока не найдем узел который на него ссылается.
        Вот вам и последний элемент.
    </p>

    <p style="margin-top: 40px">И еще парочка задач, когда дано два списка</p>

    <h4>1. Узнать пересекаются они или нет?</h4>
    <p>Тут сначала проходим эти списки до конца, если конец один и тот же элемент значит пересекаются.</p>

    <div class="image-box">
        <img src="img/intersection.png" alt="Пересечение списков">
    </div>
    <h4>2. Если пресекаются, то где?</h4>
    <p class="no_mb">А тут опять магия, берем "хвост" и зацикливаем его на одну из голов.</p>
    <p class="no_mb">А со второй ищем первую точку цикла - которая и есть точка пересечения.</p>
    <p class="example">Только после не забывайте убрать цикл с хвоста, что бы чего не вышло...</p>

</section>

<section class="container" id="q2">
    <h1><a href="#">Бинарный поиск (Binary Search)</a></h1>

    <p>
        Основная мысль бинарного поиска заключается в эффективном нахождении заданного элемента в упорядоченном массиве
        данных. Основная идея состоит в том, чтобы разделить массив пополам и проверить, находится ли искомый элемент в
        левой или правой половине массива. Затем процесс повторяется для выбранной половины, пока не будет найден
        искомый элемент или пока не останется только один элемент в массиве.
    </p>

    <div class="image-box">
        <img class="image-box" src="img/binary_search.png" alt="Бинарный поиск">
    </div>

    <p class="no_mb">Основной алгоритм бинарного поиска:</p>
    <ol>
        <li>
            Установите начальные значения для переменных low (нижняя граница) и high (верхняя граница) равными 0 и
            length&nbsp;-&nbsp;1, где length - это длина массива.
        </li>
        <li>
            <p>Пока low не превышает high, выполните следующие шаги:</p>
            <ul class="no_mb">
                <li>Вычислите средний индекс как (low&nbsp;+&nbsp;high)&nbsp;/&nbsp;2</li>
                <li>Если элемент с индексом mid равен искомому элементу, верните&nbsp;mid</li>
                <li>Если элемент с индексом mid меньше искомого элемента, обновите low как mid&nbsp;+&nbsp;1</li>
                <li>Если элемент с индексом mid больше искомого элемента, обновите high как mid&nbsp;-&nbsp;1</li>
            </ul>
        </li>
        <li> Если цикл завершается без нахождения искомого элемента, верните -1</li>
    </ol>

    <p class="main-mind">
        Бинарный поиск работает ТОЛЬКО на отсортированных массивах.
    </p>

    <p class="no_mb">Пример кода:</p>
    <div class="code">
    <pre><code>    public static int <method>binarySearch</method>(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            }
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }</code></pre>
    </div>

</section>

<a href="#" class="button button--top"></a>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

</body>

</html>