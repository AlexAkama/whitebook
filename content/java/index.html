<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAVA</title>
    <link rel="stylesheet" href="../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb">JAVA</h1>
    <div class="after-h1">Тонкости и всякие полезности</div>
    <ul class="menu">
        <li><a href="./clearcode">Оформление кода</a></li>
        <li><a href="#core">Core</a></li>
        <li><a href="#json">JSON</a></li>
        <li><a href="#example">Базовые задачки</a></li>
        <li><a href="#optional">Optional</a></li>
        <li><a href="#null">Почему нельзя возвращать NULL?</a></li>
    </ul>
    <div class="back-panel">
        <a href="../../" class="button button--to-home">На главную</a>
    </div>
</section>

<section class="container" id="core">
    <h1>CORE</h1>
    <hr>
    <h3>Примитивы</h3>
    <table class="schema" aria-label="Primitives">
        <tr>
            <th id="primitives"></th>
        </tr>
        <tr>
            <td rowspan="10">Object</td>
            <td rowspan="8">Number</td>
            <td class="p0">Numeric types</td>
        </tr>
        <tr>
            <td>Byte</td>
        </tr>
        <tr>
            <td>Short</td>
        </tr>
        <tr>
            <td>Long</td>
        </tr>
        <tr>
            <td>Integer</td>
        </tr>
        <tr>
            <td class="p0">Floating-Point Types</td>
        </tr>
        <tr>
            <td>Double</td>
        <tr>
            <td>Float</td>
        </tr>
        <tr>
            <td>Character</td>
        </tr>
        <tr>
            <td>Boolean</td>
        </tr>
    </table>
    <hr>
    <h3>Object</h3>
    <p class="bold">Методы</p>
    <table class="tab-1 test" aria-label="object-methods">
        <tr>
            <th id="object-methods"></th>
        </tr>
        <tr>
            <td class="bold">hashCode()</td>
            <td class="tab-1" rowspan="3" style="vertical-align: middle;">Три часто используемых метода</td>
        </tr>
        <tr>
            <td class="bold">equals()</td>
        </tr>
        <tr>
            <td class="bold">toString()</td>
        </tr>
        <tr>
            <td class="bold">notify()</td>
            <td class="tab-1">пробуждает поток</td>
        </tr>
        <tr>
            <td class="bold">notifyAll()</td>
            <td class="tab-1">пробуждает все потоки на мониторе</td>
        </tr>
        <tr>
            <td class="bold">wait()</td>
            <td class="tab-1">останавливает поток (засыпает)</td>
        </tr>
        <tr>
            <td class="bold">getClass()</td>
            <td class="tab-1">объект с именем класса</td>
        </tr>
        <tr>
            <td class="bold">clone()</td>
            <td class="tab-1">копия</td>
        </tr>
        <tr>
            <td class="bold">finalize()</td>
            <td class="tab-1">вызывается непосредственно перед удалением объекта сборщиком мусора</td>
        </tr>
    </table>
    <hr>
    <h3>HashCode & Equals</h3>
    <p class="no_mb"><strong>HashCode</strong> - Общий контракт:</p>
    <ul>
        <li>одно и то же число каждый раз когда объект не меняется;</li>
        <li>
            если два объекта равны через вызов equals(),
            то вызов у них hashCode() должен приводить к одному результату;
        </li>
        <li>если hashCode() у объектов разные, то объекты разные;</li>
    </ul>
    <p class="no_mb"><strong> Equals</strong> - Основные принципы:</p>
    <ol>
        <li>
            <p class="no_mb">Рефлексивность</p>
            <div class="code no_mb">
                <p>x.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Симметричность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(x) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Транзитивность</p>
            <div class="code no_mb">
                <p>x.equals(y) = true</p>
                <p>y.equals(z) = true</p>
                <p>x.equals(z) = true</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Постоянство</p>
            <div class="code no_mb">
                <p>Результат одно и то же число пока объект не изменится</p>
            </div>
        </li>
        <li>
            <p class="no_mb">Если объекта нет - ложь</p>
            <div class="code no_mb">
                <p>x.equals(null) = false</p>
            </div>
        </li>
    </ol>
    <hr>
    <h3>Сеарилизация & Десериализация</h3>
    <p class="no_mb"><strong>Сеарилизация</strong> - процесс преобразования объекта в поток байтов для хранения.</p>
    <p><strong>Десереализация</strong> - процесс извлечения объекта из потока байтов.</p>
    <p class="no_mb">
        Объект должен реализовывать интерфейс
        <strong>Serializable</strong>(интерфейс-маркер)
        либо
        <strong>Externalizable</strong>(переопределяем readObject()/writeObject())
    </p>
    <p>Поля класса, если они объекты, так же должны реализовывать данные интерфейсы</p>
    <p class="important">Поля
        <span class="example">transient</span>
        и
        <span class="example">static</span>
        НЕ СЕРЕАЛИЗУЮТСЯ (не сохраняются)</p>
    <p class="no_mb">Есть исключение:</p>
    <p class="tab-1 bold">private static final long serialVersionUID</p>
    <p class="no_mb">При десереализации:</p>
    <table aria-label="deseralization">
        <tr>
            <th id="deseralization"></th>
        </tr>
        <tr>
            <td class="tab-1">transient</td>
            <td class="tab-1">- восстанавливаются значения по умолчанию, ссылочные -> null;</td>
        </tr>
        <tr>
            <td class="tab-1">static</td>
            <td class="tab-1">- восстанавливаются по умолчанию в случае отсутствия объекта в области видимости. Иначе
                значения актуальные в данный момент;
            </td>
        </tr>
    </table>
    <p>Для записи объекта используется метод writeObject() класса ObjectOutputStream,
        для чтения readObject() класса ObjectInputStream</p>
    <p class="important">При десереализации данные заполняются из потока, конструктор не используется.</p>
    <hr>
    <h3>Преобразование и приведение примитивных типов</h3>
    <p class="no_mb">2 типа преобразований:</p>
    <ul>
        <li><strong>Автоматическое</strong>(не явное) расширяющее преобразование;</li>
        <li><strong>Приведение типов</strong>(явное) сужающее преобразование;</li>
    </ul>

</section>

<section class="container" id="json">
    <h1>JSON</h1>
    <p><a href="https://jsonformatter.curiousconcept.com" target="_blank">Валидатор JSON</a></p>
    <p>
        <a href="http://tutorials.jenkov.com/java-json/jackson-annotations.html" target="_blank">Аннотации по JSON</a>
        и то же, но <a href="https://nsergey.com/jackson-annotations/" target="_blank">на русском</a>
    </p>
    <hr>
    <h3>Полезные аннотации</h3>
    <p class="important no_mb">@JsonPropertyOrder({"id", name"})</p>
    <p>Для классов порядок сериализации полей объекта в JSON</p>
    <p class="important no_mb">@JsonInclude(JsonInclude. Include .NON_NULL)</p>
    <p>не включать параметр если он равен null, можно для всего класса или для конкретного поля</p>
    <p class="important no_mb">@JsonProperty("&lt;имя_в_json&gt;")</p>
    <p>Аннотация ставится над переменной и в json вместо имени переменной попадет указанное в аннотации значение</p>
    <hr>
    <h3>JsonInclude атрибуты</h3>
    <table aria-label="JSON annotation">
        <tr>
            <th id="annotation"></th>
        </tr>
        <tr>
            <td class="bold">ALWAYS</td>
            <td class="tab-1">всегда включать свойство</td>
        </tr>
        <tr>
            <td class="bold">NON_NULL</td>
            <td class="tab-1">не включать свойство с нулевым значением</td>
        </tr>
        <tr>
            <td class="bold">NON_ABSENT</td>
            <td class="tab-1">нет нулевых значений, включая нулевые значения содержимого, такие как Optional,
                AtomicReference и т.
                д.
            </td>
        </tr>
        <tr>
            <td class="bold">NON_EMPTY</td>
            <td class="tab-1">значения вроде пустых коллекций/карт/массивов/строк и т. д. исключаются (NON_NULL&nbsp;+&nbsp;NON_ABSENT)</td>
        </tr>
        <tr>
            <td class="bold">NON_DEFAULT</td>
            <td class="tab-1">без значений по умолчанию, например нет примитивов со значениями по умолчанию</td>
        </tr>
        <tr>
            <td class="bold">CUSTOM</td>
            <td class="tab-1">настраиваемый фильтр для исключения, заданный JsonInclude.valueFilter()</td>
        </tr>
        <tr>
            <td class="bold">USE_DEFAULTS</td>
            <td class="tab-1">использовать значения по умолчанию либо из уровня класса, либо из уровня ObjectMapper</td>
        </tr>
    </table>
    <a href="#" class="button button--to-top"></a>
</section>

<section class="container" id="optional">
    <h1>Optional</h1>
    <hr>
    <table aria-label="optional">
        <tr>
            <th id="opt"></th>
        </tr>
        <tr>
            <td class="bold">Optional.of</td>
            <td class="tab-1">возвращает Optional-объект</td>
        </tr>
        <tr>
            <td class="bold">Optional.ofNullable</td>
            <td class="tab-1">возвращает Optional-объект, а если нет дженерик-объекта, возвращает пустой
                Optional-объект
            </td>
        </tr>
        <tr>
            <td class="bold">Optional.empty</td>
            <td class="tab-1">возвращает пустой Optional-объект</td>
        </tr>
    </table>
    <hr>
    <h3>Почитать</h3>
    <p><a href="https://habr.com/ru/post/346782/" target="_blank">Optional: Кот Шрёдингера в Java 8</a></p>
    <p><a href="https://vertex-academy.com/tutorials/ru/java-8-optional/" target="_blank">Java 8 Optional</a></p>
    <a href="#" class="button button--to-top"></a>
    <hr>
    <h3>РАБОТА С OPTIONAL</h3>
    <p class="no_mb">Обычно с Optional работают так:</p>
    <ul>
        <li>Проверить наличие через <strong>isPresent()</strong></li>
        <li>Вытащить значение через <strong>get()</strong></li>
        <li>Обработать результат</li>
    </ul>
    <p>Это ок, но встроенные методы Optional позволяют обойтись без связки isPresent + get.</p>
    <ol>
        <li>
            <p class="bold">Значение по умолчанию: orElse / orElseGet</p>
            <p class="no_mb">Вместо сложной конструкции</p>
            <p class="bad no_mb"><span>NO:</span> if (opt.isPresent()) { return opt.get(); } else return "default";</p>
            <p class="no_mb">используйте метод <span>orElse</span>:</p>
            <p class="good"><span> YES:</span> return opt.orElse("default");</p>

            <p class="bold no_mb">ВАЖНО!!!</p>
            <p>Используйте orElse только с константами или простыми операциями, потому что выражение в
                orElse вычисляется всегда:</p>
            <p class="bad no_mb"><span>BAD:</span> getFromCache(id) .orElse(getFromDB(id);</p>
            <p>getFromDB выполнится, даже если getFromCache вернёт результат.</p>
            <p class="no_mb">Для тяжёлых операций используйте метод orElseGet:</p>
            <p class="good no_mb"><span>GOOD:</span> getFromCache(id) .orElseGet(() → getFromDB(id));</p>
            <p>Здесь getFromDB выполнится, только если результат getFromCache пустой.</p>
        </li>
        <li>
            <p class="bold no_mb">Бросить эксепшн, если результата нет: orElseThrow</p>
            <p class="good">return opt.orElseThrow(NotFoundException::new)</p>
            <p class="no_mb">В Java 10 появился метод без параметров: <strong>opt.orElseThrow()</strong></p>
            <p>Если в opt нет значения, код выбросит <span class="bad">NoSuchElementException</span>.</p>
        </li>
        <li>
            <p class="bold no_mb">Проверка условия: filter</p>
            <p class="no_mb">Вместо isPresent + get + проверка условия используйте метод filter:</p>
            <p class="good">value.filter(v→v.length()<4) .ifPresent(…)</p>
        </li>
        <li>
            <p class="bold">Преобразования: map / flatMap</p>
            <p class="no_mb">Для манипуляций значением Optional используйте метод map:</p>
            <p class="good">opt.map(Account::getAddress) .map(String::toUpperCase) .orElse("default");</p>
            <p class="no_mb">flatMap используется, если метод отображения возвращает Optional:</p>
            <p class="good no_mb">Optional&lt;String&gt; getAddress() {…}</p>
            <p class="good">opt.flatMap(Account::getAddress);</p>
        </li>
        <li>
            <p class="bold">Методы для Stream API (Java 9)</p>
            <p class="no_mb">Когда в стриме один метод возвращает Optional, его часто обрабатывают так:</p>
            <p class="bad"><span>BAD:</span> .filter(Optional::isPresent) .map(Optional::get)</p>
            <p class="no_mb">Метод flatMap пригодится и здесь. Все пустые значения отфильтруются:</p>
            <p class="good"><span>GOOD:</span> .flatMap(Optional::stream)</p>
        </li>
        <li>
            <p class="bold">Сравнение Optional</p>
            <p class="bad no_mb"><span>BAD:</span> Обычно делают так: op1.get().equals(op2.get())</p>
            <p>Если хотя бы один Optional пустой, будет <span class="bad">NullPointerException</span></p>
            <p class="good"><span>GOOD:</span> Сравнивайте Optional напрямую: op1.equals(op2)</p>
        </li>
    </ol>
    <hr>
    <h3>5 ошибок при использовании Optional</h3>
    <p>
        Optional — удобный инструмент, который появился в java 8. В
        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" target="_blank">
            документации
        </a>
        его цель явно обозначена — возвращаемое значение из метода, когда результата может не быть.
    </p>
    <p class="no_mb">Например, функция поиска может найти нужный элемент, а может и не найти. В этой ситуации отлично
        подойдёт Optional:</p>
    <div class="code">Optional &lt;String&gt; search();</div>
    <p class="bold">Самые частые ошибки при использовании:</p>
    <ol>
        <li>
            <p class="bold no_mb">Входные параметры Optional в методах и конструкторах</p>
            <p>Класс становится неудобным, приходится добавлять лишние обёртки и подгонять параметры.</p>
            <p class="bad"><span>BAD:</span> void init(Optional&lt;String&gt; value) {…}</p>
            <p class="good no_mb"><span>GOOD:</span> Проверяйте параметры на null в начале метода: </p>
            <div class="code">
                <p>void init (String value) {</p>
                <p class="tab-1">if (value == null) …</p>
                <p>}</p>
            </div>
        </li>
        <li>
            <p class="bold">Усложнение кода</p>
            <p> С появлением Stream API усилился тренд на Fluent API: это когда действия соединяются в одну цепочку. Не
                создавайте Optional только ради этого, пишите простой код.</p>
            <p class="bad"><span>BAD:</span> return Optional.ofNullable(value) .orElse("default");</p>
            <p class="good"><span>GOOD:</span> return value == null ? "default" : value;</p>
        </li>
        <li>
            <p class="bold">Отложенная обработка Optional</p>
            <p class="no_mb">Идеально, если обработка происходит сразу после возвращения из метода:</p>
            <div class="code">
                <p>Optional &lt;String&gt; valueOpt = … ;</p>
                <p>String value = valueOpt.orElse("default");</p>
            </div>
        </li>
        <li>
            <p class="bold"> Optional с коллекциями</p>
            <p>Возвращайте пустой список, если элементов нет:</p>
            <p class="bad"><span>BAD:</span> public Optional &lt;List&lt;Integer&gt;&gt; search(…)</p>
            <p class="good"><span>GOOD:</span> public List &lt;Integer&gt; search(…)</p>
        </li>
        <li>
            <p class="bold">Работа с примитивами</p>
            <p class="no_mb">Для примитивов <strong>int</strong>, <strong>long</strong> и <strong>double</strong>
                используйте специальные Optional классы:</p>
            <p class="tab-1 no_mb">- OptionalInt</p>
            <p class="tab-1 no_mb">- OptionalDouble</p>
            <p class="tab-1">- OptionalLong</p>
            <p>
                Нет затрат на создание объекта, а код становится чуть короче и понятнее. Методов меньше, чем в
                Optional, но при интенсивной работе с примитивами возможен прирост производительности.
            </p>
        </li>
    </ol>
</section>

<section class="container" id="null">
    <h1>Почему нельзя возвращать NULL?</h1>
    <p>Смотрите <a href="https://youtu.be/QwycPnpp6uQ" target="_blank">видосик</a></p>
    <a href="#" class="button button--to-top"></a>
</section>

<footer>
    <div class="footer__text">Алексей Маслов, 2021-2022</div>
</footer>

</body>

</html>