<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kafka</title>
    <link rel="stylesheet" href="../../../css/style.css">
</head>

<body>

<section class="container">
    <h1 class="no_mb"><a href="../">Kafka</a></h1>
    <div class="after-h1">Базовые знания</div>
    <div class="breadcrumbs">
        <p><a href="../../../">главная</a></p>
        <p><a href="../">курсы</a></p>
        <p>Kafka</p>
    </div>
    <h3 class="no_mt">Содержание:</h3>
    <ul class="menu tab-3">
        <li><a href="#term">Термины</a></li>
        <li><a href="#vs_queue">Kafka vs Queue</a></li>
        <li><a href="#structure">Структура данных</a></li>
        <li><a href="#consumer_groups">Consumer Groups</a></li>
    </ul>
</section>

<section class="container" id="term">
    <h1><a href="#">Термины</a></h1>
    <p class="term no_mb">
        <span>Распределенное хранилище</span>
        - это система, которая, как правило, работает на нескольких машинах, каждая из этих машин
        в свою очередь является кусочком хранилища.
    </p>
    <p>Для пользователя это все представляется в виде единого целого.</p>

    <p class="term no_mb">
        <span>Вертикальное масштабирование</span>
        - это когда мы добавляем нашей машине ресурсы (проц, память, винт и т.п.).
    </p>
    <p>
        Такое масштабирование имеет явный предел и требует обязательного времени простоя (downtime) на проведение работ.
    </p>

    <p class="term">
        <span>Горизонтальное масштабирование</span>
        - техника, в которой мы вместо увеличения мощностей одной машины, добавляем в систему
        дополнительные машины, тем самым увеличивая доступные ресурсы.
    </p>

    <p class="term">
        <span>Отказоустойчивость</span>
        - это свойство системы, позволяющее ей не иметь единую точку отказа. Т.е. если что-то пошло не
        так и какая-то из машин вышла из строя, система может продолжить работу.
    </p>

    <p class="term">
        <span>Лог</span>
        - это упорядоченная по времени append-only структура данных.
    </p>

    <p class="term">
        <span>Kafka</span>
        - это распределенное, отказоустойчивое, горизонтально масштабируемое хранилище, основной структурой данных
        которой является append-only лог, которое поддерживает потоковую обработку данных и имеет развитую экосистему
        коннекторов для интеграции с базами данных и другими хранилищами.
    </p>

    <p class="no_mb">Плюсы Kafka:</p>
    <ol>
        <li>Может работать с огромным числом продюсеров которые могут использовать как один так и несколько топиков.
        </li>
        <li>Консьюмеры могут читать из любого количества топиков не мешая друг другу.</li>
    </ol>

    <a class="link-to-source" target="_blank"
       href="https://www.youtube.com/watch?v=w7HSY8L1bsk&list=PL8D2P0ruohOAR7DAkEjhOqlQreg9rxBMu&index=1&t=321s">
        Источник
    </a>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="vs_queue">
    <h1><a href="#">Kafka vs Queue</a></h1>

    <p>
        Очередь обычно используются для отложенной обработки событий или для организации буфера перед сервисами защищая
        их от всплесков нагрузки.
    </p>
    <p>
        Принципиальная организация очереди:
    </p>
    <p class="accent-mono tab-2">
        Producer -> Server <-> Consumer
    </p>
    <p>
        Producer отправляют запросы в именованную очередь заранее сконфигурированную на сервере.
    </p>

    <p class="no_mb">Модели запросов Consumer'ов к серверу:</p>
    <ul class="tab-3">
        <li>
            <p class="term">
                <span>pull</span>
                - consumer раз в n-секунд отправляют запрос на сервер для получения новой информации.
            </p>
            <p class="term">
                <span>Плюсы:</span>
                потребители сами регулируют свою нагрузку, сообщения можно объединять в группы(батч) для достижения
                лучшей пропускной способности.
            </p>
            <p class="term">
                <span>Минусы:</span>
                разбалансированность нагрузки разных consumer'ов и высокая задержка при обработке данных.
            </p>
        </li>
        <li>
            <p class="term"><span>push</span> - сервер сам посылает запросы консьюмерам (ex: RabbitMQ)</p>
            <p class="term">
                <span> Плюсы:</span>
                снижает время обработки сообщений (по сравнению с pull) и позволяет балансировать нагрузку консьюмеров
            </p>
        </li>
    </ul>

    <p class="no_mb">Жизненный цикл сообщение в очереди:</p>
    <ol class="tab-3">
        <li>
            <p class="term">
                <span>send</span>
                - продюсер послал сообщение
            </p>
        </li>
        <li>
            <p class="term">
                <span>fetch</span>
                - консьюмер забрал сообщение (сообщению присвоен уникальный идентификатор), сервер сообщение пометил что
                сообщение недоступно (сообщение все еще хранится на сервере)
            </p>
        </li>
        <li>
            <p class="term">
                <span>process</span>
                - сообщение обрабатывается консьюмером, после он шлет запрос либо об удачной обработке либо об ошибке
                (ack/nack)
            </p>
        </li>
        <li>
            <p class="term">
                <span>ack/nack</span>
                - сервер получает сообщение от консьюмера об окончании обработки.
            </p>
            <p>
                Если успешно - сообщение удаляется навсегда, если ошибка или таймаут - сообщение передается другому
                консьюмеру.
            </p>
        </li>
    </ol>

    <p class="main-mind no_mb">
        Основное отличие Kafka от очередей - сообщения НЕ УДАЛЯЮТСЯ по мере их обработки консьюмерами.
    </p>
    <p class="main-mind">
        Одни и те же сообщения могут быть обработаны СКОЛЬКО УГОДНО РАЗ!
    </p>

    <p>Схема кафки похожа на очередь:</p>
    <p class="accent-mono tab-2">Producer -> Kafka Broker <- Consumer</p>


    <p class="no_mb"> Структура сообщений в кафке:</p>
    <div class="code">
        <p>{</p>
        <p class="tab-1">key: "Warrning",</p>
        <p class="tab-1">value:"Help me!!",</p>
        <p class="tab-1">timestamp: ...,</p>
        <p class="tab-1">headers: [{}, ...] - опционально (метаданные или заголовки)</p>
        <p>}</p>
    </div>

    <a class="link-to-source" target="_blank"
       href="https://www.youtube.com/watch?v=9SWCdRe7mtM&list=PL8D2P0ruohOAR7DAkEjhOqlQreg9rxBMu&index=2&t=30s">
        Источник
    </a>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="structure">
    <h1><a href="#">Структура данных</a></h1>

    <p class="term"> Сообщения отправляются и хранятся в именованных топиках (<span>Topic</span>)</p>

    <p class="term">Каждый топик состоит из 1й или более партиций (<span>Partition</span>)</p>

    <p class="no_mb">Если ключи повторяются что сообщения записываются в одну и туже партицию.</p>
    <p>Это гарантирует порядок записи и чтения.</p>

    <p class="no_mb">Каждая партиция может быть реплицирована n раз, где n - replication factor (настраивается).</p>
    <p>Нужно для сохранности данных.</p>

    <p class="term"><span>Партиция</span> - это распределенный отказоустойчивый лог.</p>

    <p class="term no_mb">
        У каждой партиции есть 1 бокер - лидер
        (<span>Leader</span> - брокер, который работает с клиентом)</p>
    <p></p>

    <p>Сообщения всегда отправляются лидеру и, в общем случае, читаются с лидера.</p>

    <p class="term">У каждого лидера может быть 0..N фоловеров (<span>Follower</span>)</p>

    <p class="main-mind">Каждая партиция и есть лог</p>

    <p class="term">
        Каждое новое сообщение, отправленное продюсеров в партицию, сохраняется в голову этого лога и получает
        уникальный <span>монотонно возрастающий offset</span>. Offset это <span>64bit число, назначаемое брокером</span>.
    </p>

    <p class="no_mb">Удаление сообщений происходит согласно конфигурации ренетшена (retention):</p>
    <ul class="tab-3">
        <li>retention.ms - минимальное время хранения сообщений.</li>
        <li>retention.bytes - максимальный размер партиции.</li>
    </ul>

    <a class="link-to-source" target="_blank"
       href="https://www.youtube.com/watch?v=9SWCdRe7mtM&list=PL8D2P0ruohOAR7DAkEjhOqlQreg9rxBMu&index=2&t=337s">
        Источник
    </a>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<section class="container" id="consumer_groups">
    <h1><a href="#">Consumer Groups</a></h1>

    <p class="no_mb">Каждый консьюмер обычно является частью консьюмер-группы или набора таких же консьюмеров.</p>
    <p>Каждая такая группа регистрируется брокером в кластере кафки.</p>

    <p>Данные из одного топика могут читаться множеством консьюмеров из множества групп.</p>

    <p>
        Когда несколько консьюмеров читают сообщения из одного топика, то они получают сообщения из разных патриций,
        чтобы распределить нагрузку.
    </p>

    <p class="main-mind no_mb">Партиции внутри группы назначаются консьюмерам уникально.</p>
    <p class="main-mind">Партиция - это основной инструмент масштабирования.</p>

    <p class="no_mb">Своими словами:</p>
    <p class="no_mb">Кафка назначает одному консьюмеру в рамках группы одну партицию.</p>
    <p class="no_mb">
        Если консьюмеров больше чем партиций, то консьюмеры с не назначенными партициями просто не будут использованы.
    </p>
    <p class="no_mb">
        Если один их косьюмеров рухнет, то партиция будет перераспределена, и в случае наличия незадействованного
        консьюмера будет назначена ему. Т.о. обеспечиваем отказоустойчивость.
    </p>

    <p>
        Если консьюмеры не справляются с объемом данных, или необходимо распределить нагрузку между брокерами -
        добавляем партиции в топик.
    </p>

    <p class="no_mb">Партиции можно добавить в любой момент, но:</p>
    <ul>
        <li>Нужно помнить про гарантию очередности в рамках одной партиции</li>
        <li>Индивидуальные партиции нельзя удалить после создания, можно удалить только топик целиком.</li>
    </ul>

    <p>
        Для каждой группы хранится свой consumer offset для партиции, что позволяет разным группам обрабатывать
        сообщения независимо друг от друга с разной скорость.
    </p>

    <p class="no_mb">
        Консьюмеры коммитят в брокер свой offset (т.е. записывают последнее обработанное сообщение)
    </p>
    <p>
        При старте консьюмер запрашивают у брокера свой offset и стартуют с последнего обработанного сообщения.
    </p>

    <a class="link-to-source" target="_blank"
       href="https://www.youtube.com/watch?v=9SWCdRe7mtM&list=PL8D2P0ruohOAR7DAkEjhOqlQreg9rxBMu&index=2&t=515s">
        Источник
    </a>

    <a class="button button--to_top_menu" href="#"></a>
</section>

<a href="#" class="button button--top"></a>

<footer>
    <div class="footer__text"><a href="https://t.me/java40plus" title="Мой блог в телеграм" target="_blank">
        Ⓒ Алексей Маслов, 2021-2024
    </a></div>
</footer>

</body>

</html>